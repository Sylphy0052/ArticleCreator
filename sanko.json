{"files":[{"id":"ce66464d-df91-4454-8dc9-0545ebeba6d4","name":"appsscript","type":"json","source":"{\n  \"timeZone\": \"Etc/GMT-9\",\n  \"dependencies\": {},\n  \"exceptionLogging\": \"STACKDRIVER\",\n  \"runtimeVersion\": \"V8\",\n  \"webapp\": {\n    \"executeAs\": \"USER_DEPLOYING\",\n    \"access\": \"MYSELF\"\n  }\n}"},{"id":"14eb20be-13cb-4a1d-9287-60e91ad246e1","name":"コード","type":"server_js","source":"/**\n* @license\n* Copyright 2025 majin (https://note.com/majin_108)\n*\n* 【まじん式 ご利用条件 (メンバー・法人版)】\n*\n* 本スクリプト（コード.gs）は、以下の「まじん式 ご利用条件」に基づき提供されます。\n* 利用条件の詳細は、noteの記事 ( https://note.com/majin_108 ) にある\n* 「まじん式 v4」関連記事の最新版をご確認ください。\n*\n* 1. コードの商用利用: 【不可】\n* コードの全部または一部を有償無償にかかわらずサービスに組み込むなどの商用利用は一切禁止です。\n*\n* 2. コードの改変: 【可】\n* ご自身の利用のためのカスタマイズは可能です。\n*\n* 3. 改変後の配布: 【法人ライセンスで社内のみ可】\n* 法人ライセンスでは、ライセンスを購入した社内でのみ改変後の配布が可能です。\n* メンバーシップライセンスでは改変後の配布はできません。\n*\n* 4. セミナー等での利用: 【条件付きで可】\n* 無料のセミナーやブログでの紹介は歓迎します。\n* 有料のセミナーや講座での解説・紹介は禁止です。\n*\n* 5. 法人利用: 【可】\n* 法人ライセンスで購入の場合には組織全体で利用が可能です。\n* メンバーシップライセンスの場合にはメンバーの方のみ利用可能です。\n*\n*【サードパーティライセンス】\n* 本スクリプトは、以下のサードパーティ製ライブラリに依存しています。\n* これらのライブラリは、本利用条件とは別に、それぞれのオリジナルライセンスに基づき提供されます。\n* - pako.js (https://github.com/nodeca/pako) : MIT License\n* - UPNG.js (https://github.com/photopea/UPNG.js) : MIT License\n*\n* 【免責事項】\n* 本ソフトウェアを使用したことによって生じたいかなる損害についても、作者は一切の責任を負いません。\n*\n*/\n\nfunction hexToRgb(hex) {\n  const result \u003d /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n  return result ? {\n    r: parseInt(result[1], 16),\n    g: parseInt(result[2], 16),\n    b: parseInt(result[3], 16)\n  } : null;\n}\nfunction rgbToHsl(r, g, b) {\n  r /\u003d 255;\n  g /\u003d 255;\n  b /\u003d 255;\n  const max \u003d Math.max(r, g, b),\n    min \u003d Math.min(r, g, b);\n  let h, s, l \u003d (max + min) / 2;\n  if (max \u003d\u003d\u003d min) {\n    h \u003d s \u003d 0;\n  } else {\n    const d \u003d max - min;\n    s \u003d l \u003e 0.5 ? d / (2 - max - min) : d / (max + min);\n    switch (max) {\n      case r:\n        h \u003d (g - b) / d + (g \u003c b ? 6 : 0);\n        break;\n      case g:\n        h \u003d (b - r) / d + 2;\n        break;\n      case b:\n        h \u003d (r - g) / d + 4;\n        break;\n    }\n    h /\u003d 6;\n  }\n  return {\n    h: h * 360,\n    s: s * 100,\n    l: l * 100\n  };\n}\nfunction hslToHex(h, s, l) {\n  s /\u003d 100;\n  l /\u003d 100;\n  const c \u003d (1 - Math.abs(2 * l - 1)) * s,\n    x \u003d c * (1 - Math.abs((h / 60) % 2 - 1)),\n    m \u003d l - c / 2;\n  let r \u003d 0,\n    g \u003d 0,\n    b \u003d 0;\n  if (0 \u003c\u003d h \u0026\u0026 h \u003c 60) {\n    r \u003d c;\n    g \u003d x;\n    b \u003d 0;\n  } else if (60 \u003c\u003d h \u0026\u0026 h \u003c 120) {\n    r \u003d x;\n    g \u003d c;\n    b \u003d 0;\n  } else if (120 \u003c\u003d h \u0026\u0026 h \u003c 180) {\n    r \u003d 0;\n    g \u003d c;\n    b \u003d x;\n  } else if (180 \u003c\u003d h \u0026\u0026 h \u003c 240) {\n    r \u003d 0;\n    g \u003d x;\n    b \u003d c;\n  } else if (240 \u003c\u003d h \u0026\u0026 h \u003c 300) {\n    r \u003d x;\n    g \u003d 0;\n    b \u003d c;\n  } else if (300 \u003c\u003d h \u0026\u0026 h \u003c 360) {\n    r \u003d c;\n    g \u003d 0;\n    b \u003d x;\n  }\n  r \u003d Math.round((r + m) * 255);\n  g \u003d Math.round((g + m) * 255);\n  b \u003d Math.round((b + m) * 255);\n  return \"#\" + ((1 \u003c\u003c 24) + (r \u003c\u003c 16) + (g \u003c\u003c 8) + b).toString(16).slice(1).toUpperCase();\n}\nfunction generateTintedGray(tintColorHex, saturation, lightness) {\n  const rgb \u003d hexToRgb(tintColorHex);\n  if (!rgb) return \u0027#F8F9FA\u0027;\n  const hsl \u003d rgbToHsl(rgb.r, rgb.g, rgb.b);\n  return hslToHex(hsl.h, saturation, lightness);\n}\nfunction generatePyramidColors(baseColor, levels) {\n  const colors \u003d [];\n  for (let i \u003d 0; i \u003c levels; i++) {\n    const lightenAmount \u003d (i / Math.max(1, levels - 1)) * 0.6;\n    colors.push(lightenColor(baseColor, lightenAmount));\n  }\n  return colors;\n}\nfunction lightenColor(color, amount) {\n  const rgb \u003d hexToRgb(color);\n  if (!rgb) return color;\n  const lighten \u003d (c) \u003d\u003e Math.min(255, Math.round(c + (255 - c) * amount));\n  const newR \u003d lighten(rgb.r);\n  const newG \u003d lighten(rgb.g);\n  const newB \u003d lighten(rgb.b);\n  return `#${newR.toString(16).padStart(2, \u00270\u0027)}${newG.toString(16).padStart(2, \u00270\u0027)}${newB.toString(16).padStart(2, \u00270\u0027)}`;\n}\nfunction darkenColor(color, amount) {\n  const rgb \u003d hexToRgb(color);\n  if (!rgb) return color;\n  const darken \u003d (c) \u003d\u003e Math.max(0, Math.round(c * (1 - amount)));\n  const newR \u003d darken(rgb.r);\n  const newG \u003d darken(rgb.g);\n  const newB \u003d darken(rgb.b);\n  return `#${newR.toString(16).padStart(2, \u00270\u0027)}${newG.toString(16).padStart(2, \u00270\u0027)}${newB.toString(16).padStart(2, \u00270\u0027)}`;\n}\nfunction generateStepUpColors(baseColor, steps) {\n  const colors \u003d [];\n  for (let i \u003d 0; i \u003c steps; i++) {\n    const lightenAmount \u003d 0.6 * (1 - (i / Math.max(1, steps - 1)));\n    colors.push(lightenColor(baseColor, lightenAmount));\n  }\n  return colors;\n}\nfunction generateProcessColors(baseColor, steps) {\n  const colors \u003d [];\n  for (let i \u003d 0; i \u003c steps; i++) {\n    const lightenAmount \u003d 0.5 * (1 - (i / Math.max(1, steps - 1)));\n    colors.push(lightenColor(baseColor, lightenAmount));\n  }\n  return colors;\n}\nfunction generateTimelineCardColors(baseColor, milestones) {\n  const colors \u003d [];\n  for (let i \u003d 0; i \u003c milestones; i++) {\n    const lightenAmount \u003d 0.4 * (1 - (i / Math.max(1, milestones - 1)));\n    colors.push(lightenColor(baseColor, lightenAmount));\n  }\n  return colors;\n}\nfunction generateCompareColors(baseColor) {\n  return {\n    left: darkenColor(baseColor, 0.3),\n    right: baseColor\n  };\n}\nconst CONFIG \u003d {\n  BASE_PX: {\n    W: 960,\n    H: 540\n  },\n  BACKGROUND_IMAGES: {\n    title: \u0027\u0027,\n    closing: \u0027\u0027,\n    section: \u0027\u0027,\n    main: \u0027\u0027\n  },\n  POS_PX: {\n    titleSlide: {\n      logo: {\n        left: 55,\n        top: 60,\n        width: 135\n      },\n      title: {\n        left: 50,\n        top: 200,\n        width: 830,\n        height: 90\n      },\n      date: {\n        left: 50,\n        top: 450,\n        width: 250,\n        height: 40\n      }\n    },\n    contentSlide: {\n      headerLogo: {\n        right: 20,\n        top: 20,\n        width: 75\n      },\n      title: {\n        left: 25,\n        top: 20,\n        width: 830,\n        height: 65\n      },\n      titleUnderline: {\n        left: 25,\n        top: 80,\n        width: 260,\n        height: 4\n      },\n      subhead: {\n        left: 25,\n        top: 90,\n        width: 910,\n        height: 40\n      },\n      body: {\n        left: 25,\n        top: 132,\n        width: 910,\n        height: 330\n      },\n      twoColLeft: {\n        left: 25,\n        top: 132,\n        width: 440,\n        height: 330\n      },\n      twoColRight: {\n        left: 495,\n        top: 132,\n        width: 440,\n        height: 330\n      }\n    },\n    compareSlide: {\n      headerLogo: {\n        right: 20,\n        top: 20,\n        width: 75\n      },\n      title: {\n        left: 25,\n        top: 20,\n        width: 830,\n        height: 65\n      },\n      titleUnderline: {\n        left: 25,\n        top: 80,\n        width: 260,\n        height: 4\n      },\n      subhead: {\n        left: 25,\n        top: 90,\n        width: 910,\n        height: 40\n      },\n      leftBox: {\n        left: 25,\n        top: 112,\n        width: 445,\n        height: 350\n      },\n      rightBox: {\n        left: 490,\n        top: 112,\n        width: 445,\n        height: 350\n      }\n    },\n    processSlide: {\n      headerLogo: {\n        right: 20,\n        top: 20,\n        width: 75\n      },\n      title: {\n        left: 25,\n        top: 20,\n        width: 830,\n        height: 65\n      },\n      titleUnderline: {\n        left: 25,\n        top: 80,\n        width: 260,\n        height: 4\n      },\n      subhead: {\n        left: 25,\n        top: 90,\n        width: 910,\n        height: 40\n      },\n      area: {\n        left: 25,\n        top: 132,\n        width: 910,\n        height: 330\n      }\n    },\n    timelineSlide: {\n      headerLogo: {\n        right: 20,\n        top: 20,\n        width: 75\n      },\n      title: {\n        left: 25,\n        top: 20,\n        width: 830,\n        height: 65\n      },\n      titleUnderline: {\n        left: 25,\n        top: 80,\n        width: 260,\n        height: 4\n      },\n      subhead: {\n        left: 25,\n        top: 90,\n        width: 910,\n        height: 40\n      },\n      area: {\n        left: 25,\n        top: 132,\n        width: 910,\n        height: 330\n      }\n    },\n    diagramSlide: {\n      headerLogo: {\n        right: 20,\n        top: 20,\n        width: 75\n      },\n      title: {\n        left: 25,\n        top: 20,\n        width: 830,\n        height: 65\n      },\n      titleUnderline: {\n        left: 25,\n        top: 80,\n        width: 260,\n        height: 4\n      },\n      subhead: {\n        left: 25,\n        top: 90,\n        width: 910,\n        height: 40\n      },\n      lanesArea: {\n        left: 25,\n        top: 132,\n        width: 910,\n        height: 330\n      }\n    },\n    cardsSlide: {\n      headerLogo: {\n        right: 20,\n        top: 20,\n        width: 75\n      },\n      title: {\n        left: 25,\n        top: 20,\n        width: 830,\n        height: 65\n      },\n      titleUnderline: {\n        left: 25,\n        top: 80,\n        width: 260,\n        height: 4\n      },\n      subhead: {\n        left: 25,\n        top: 90,\n        width: 910,\n        height: 40\n      },\n      gridArea: {\n        left: 25,\n        top: 120,\n        width: 910,\n        height: 340\n      }\n    },\n    tableSlide: {\n      headerLogo: {\n        right: 20,\n        top: 20,\n        width: 75\n      },\n      title: {\n        left: 25,\n        top: 20,\n        width: 830,\n        height: 65\n      },\n      titleUnderline: {\n        left: 25,\n        top: 80,\n        width: 260,\n        height: 4\n      },\n      subhead: {\n        left: 25,\n        top: 90,\n        width: 910,\n        height: 40\n      },\n      area: {\n        left: 25,\n        top: 130,\n        width: 910,\n        height: 330\n      }\n    },\n    progressSlide: {\n      headerLogo: {\n        right: 20,\n        top: 20,\n        width: 75\n      },\n      title: {\n        left: 25,\n        top: 20,\n        width: 830,\n        height: 65\n      },\n      titleUnderline: {\n        left: 25,\n        top: 80,\n        width: 260,\n        height: 4\n      },\n      subhead: {\n        left: 25,\n        top: 90,\n        width: 910,\n        height: 40\n      },\n      area: {\n        left: 25,\n        top: 132,\n        width: 910,\n        height: 330\n      }\n    },\n    quoteSlide: {\n      headerLogo: {\n        right: 20,\n        top: 20,\n        width: 75\n      },\n      title: {\n        left: 25,\n        top: 20,\n        width: 830,\n        height: 65\n      },\n      titleUnderline: {\n        left: 25,\n        top: 80,\n        width: 260,\n        height: 4\n      },\n      subhead: {\n        left: 25,\n        top: 100,\n        width: 910,\n        height: 40\n      }\n    },\n    kpiSlide: {\n      headerLogo: {\n        right: 20,\n        top: 20,\n        width: 75\n      },\n      title: {\n        left: 25,\n        top: 20,\n        width: 830,\n        height: 65\n      },\n      titleUnderline: {\n        left: 25,\n        top: 80,\n        width: 260,\n        height: 4\n      },\n      subhead: {\n        left: 25,\n        top: 90,\n        width: 910,\n        height: 40\n      },\n      gridArea: {\n        left: 25,\n        top: 132,\n        width: 910,\n        height: 330\n      }\n    },\n    triangleSlide: {\n      headerLogo: {\n        right: 20,\n        top: 20,\n        width: 75\n      },\n      title: {\n        left: 25,\n        top: 20,\n        width: 830,\n        height: 65\n      },\n      titleUnderline: {\n        left: 25,\n        top: 80,\n        width: 260,\n        height: 4\n      },\n      subhead: {\n        left: 25,\n        top: 90,\n        width: 910,\n        height: 40\n      },\n      area: {\n        left: 25,\n        top: 110,\n        width: 910,\n        height: 350\n      }\n    },\n    flowChartSlide: {\n      headerLogo: {\n        right: 20,\n        top: 20,\n        width: 75\n      },\n      title: {\n        left: 25,\n        top: 20,\n        width: 830,\n        height: 65\n      },\n      titleUnderline: {\n        left: 25,\n        top: 80,\n        width: 260,\n        height: 4\n      },\n      subhead: {\n        left: 25,\n        top: 90,\n        width: 910,\n        height: 40\n      },\n      singleRow: {\n        left: 25,\n        top: 160,\n        width: 910,\n        height: 180\n      },\n      upperRow: {\n        left: 25,\n        top: 150,\n        width: 910,\n        height: 120\n      },\n      lowerRow: {\n        left: 25,\n        top: 290,\n        width: 910,\n        height: 120\n      }\n    },\n    stepUpSlide: {\n      headerLogo: {\n        right: 20,\n        top: 20,\n        width: 75\n      },\n      title: {\n        left: 25,\n        top: 20,\n        width: 830,\n        height: 65\n      },\n      titleUnderline: {\n        left: 25,\n        top: 80,\n        width: 260,\n        height: 4\n      },\n      subhead: {\n        left: 25,\n        top: 90,\n        width: 910,\n        height: 40\n      },\n      stepArea: {\n        left: 25,\n        top: 130,\n        width: 910,\n        height: 330\n      }\n    },\n    imageTextSlide: {\n      headerLogo: {\n        right: 20,\n        top: 20,\n        width: 75\n      },\n      title: {\n        left: 25,\n        top: 20,\n        width: 830,\n        height: 65\n      },\n      titleUnderline: {\n        left: 25,\n        top: 80,\n        width: 260,\n        height: 4\n      },\n      subhead: {\n        left: 25,\n        top: 90,\n        width: 910,\n        height: 40\n      },\n      leftImage: {\n        left: 25,\n        top: 140,\n        width: 440,\n        height: 310\n      },\n      leftImageCaption: {\n        left: 25,\n        top: 470,\n        width: 440,\n        height: 30\n      },\n      rightText: {\n        left: 485,\n        top: 140,\n        width: 450,\n        height: 310\n      },\n      leftText: {\n        left: 25,\n        top: 140,\n        width: 450,\n        height: 310\n      },\n      rightImage: {\n        left: 495,\n        top: 140,\n        width: 440,\n        height: 310\n      },\n      rightImageCaption: {\n        left: 495,\n        top: 430,\n        width: 470,\n        height: 30\n      }\n    },\n      pyramidSlide: {\n        headerLogo: {\n          right: 20,\n          top: 20,\n          width: 75\n        },\n        title: {\n          left: 25,\n          top: 20,\n          width: 830,\n          height: 65\n        },\n        titleUnderline: {\n          left: 25,\n          top: 80,\n          width: 260,\n          height: 4\n        },\n        subhead: {\n          left: 25,\n          top: 90,\n          width: 910,\n          height: 40\n        },\n        pyramidArea: {\n          left: 25,\n          top: 120,\n          width: 910,\n          height: 360\n        }\n      },\n    sectionSlide: {\n      title: {\n        left: 55,\n        top: 230,\n        width: 840,\n        height: 80\n      },\n      ghostNum: {\n        left: 35,\n        top: 120,\n        width: 400,\n        height: 200\n      }\n    },\n    footer: {\n      leftText: {\n        left: 15,\n        top: 511,\n        width: 250,\n        height: 20\n      },\n      creditImage: {\n        right: 55,\n        top: 518,\n        width: 150,\n        height: 10\n      },\n      rightPage: {\n        right: 15,\n        top: 511,\n        width: 50,\n        height: 20\n      }\n    },\n    bottomBar: {\n      left: 0,\n      top: 534,\n      width: 960,\n      height: 6\n    }\n  },\n  FONTS: {\n    family: \u0027Noto Sans JP\u0027,\n    sizes: {\n      title: 41,\n      date: 16,\n      sectionTitle: 38,\n      contentTitle: 24,\n      subhead: 16,\n      body: 14,\n      footer: 9,\n      chip: 11,\n      laneTitle: 13,\n      small: 10,\n      processStep: 14,\n      axis: 12,\n      ghostNum: 180\n    }\n  },\n  COLORS: {\n    primary_color: \u0027#4285F4\u0027,\n    text_primary: \u0027#333333\u0027,\n    text_small_font: \u0027#1F2937\u0027,\n    background_white: \u0027#FFFFFF\u0027,\n    card_bg: \u0027#f6e9f0\u0027,\n    background_gray: \u0027\u0027,\n    faint_gray: \u0027\u0027,\n    ghost_gray: \u0027\u0027,\n    table_header_bg: \u0027\u0027,\n    lane_border: \u0027\u0027,\n    card_border: \u0027\u0027,\n    neutral_gray: \u0027\u0027,\n    process_arrow: \u0027\u0027\n  },\n  DIAGRAM: {\n    laneGap_px: 24,\n    lanePad_px: 10,\n    laneTitle_h_px: 30,\n    cardGap_px: 12,\n    cardMin_h_px: 48,\n    cardMax_h_px: 70,\n    arrow_h_px: 10,\n    arrowGap_px: 8\n  },\n  LOGOS: {\n    header: \u0027\u0027,\n    closing: \u0027\u0027\n  },\n  FOOTER_TEXT: `© ${new Date().getFullYear()} Your Company`\n};\nconst APP_VERSION \u003d \u0027v4.2\u0027; \nconst APP_TITLE \u003d \u0027まじん式 \u0027 + APP_VERSION;\nfunction doGet(e) {\n  const activationData \u003d checkUserActivation();\n  const htmlTemplate \u003d HtmlService.createTemplateFromFile(\u0027無題.html\u0027);\n  const baseSettings \u003d loadSettings();\n  htmlTemplate.settings \u003d baseSettings;\n  htmlTemplate.activationData \u003d activationData;\n  htmlTemplate.appVersion \u003d APP_VERSION; \n  return htmlTemplate.evaluate()\n    .setTitle(APP_TITLE) \n    .setXFrameOptionsMode(HtmlService.XFrameOptionsMode.DEFAULT);\n}\nfunction saveSettings(settings) {\n  try {\n    const storableSettings \u003d Object.assign({}, settings);\n    storableSettings.showTitleUnderline \u003d String(storableSettings.showTitleUnderline);\n    storableSettings.showBottomBar \u003d String(storableSettings.showBottomBar);\n    storableSettings.showDateColumn \u003d String(storableSettings.showDateColumn);\n    storableSettings.enableGradient \u003d String(storableSettings.enableGradient);\n    storableSettings.showPageNumber \u003d String(storableSettings.showPageNumber);\n    PropertiesService.getUserProperties().setProperties(storableSettings, false);\n    return {\n      status: \u0027success\u0027,\n      message: \u0027設定を保存しました。\u0027\n    };\n  } catch (e) {\n    return {\n      status: \u0027error\u0027,\n      message: `設定の保存中にエラーが発生しました: ${e.message}`\n    };\n  }\n}\nfunction saveSelectedPreset(presetName) {\n  try {\n    PropertiesService.getUserProperties().setProperty(\u0027selectedPreset\u0027, presetName);\n    return {\n      status: \u0027success\u0027,\n      message: \u0027プリセット選択を保存しました。\u0027\n    };\n  } catch (e) {\n    return {\n      status: \u0027error\u0027,\n      message: `プリセットの保存中にエラーが発生しました: ${e.message}`\n    };\n  }\n}\nfunction loadSettings() {\n  const properties \u003d PropertiesService.getUserProperties().getProperties();\n  const scriptProperties \u003d PropertiesService.getScriptProperties().getProperties();\n  const DEFAULT_DRIVE_URL \u003d \"https://drive.google.com/drive/my-drive\";\n  const driveFolderUrl \u003d (properties.driveFolderUrl \u003d\u003d\u003d undefined || properties.driveFolderUrl \u003d\u003d\u003d \"\") ?\n    DEFAULT_DRIVE_URL : properties.driveFolderUrl;\n  return {\n    primaryColor: properties.primaryColor || \u0027#4285F4\u0027,\n    largeFontColor: properties.largeFontColor || \u0027#333333\u0027,\n    smallFontColor: properties.smallFontColor || \u0027#1F2937\u0027,\n    backgroundColor: properties.backgroundColor || \u0027#FFFFFF\u0027,\n    gradientStart: properties.gradientStart || \u0027#4285F4\u0027,\n    gradientEnd: properties.gradientEnd || \u0027#ff52df\u0027,\n    fontFamily: properties.fontFamily || \u0027Noto Sans JP\u0027,\n    showTitleUnderline: properties.showTitleUnderline \u003d\u003d\u003d \u0027false\u0027 ? false : true,\n    showBottomBar: properties.showBottomBar \u003d\u003d\u003d \u0027false\u0027 ? false : true,\n    showDateColumn: properties.showDateColumn \u003d\u003d\u003d \u0027false\u0027 ? false : true,\n    showPageNumber: properties.showPageNumber \u003d\u003d\u003d \u0027false\u0027 ? false : true,\n    enableGradient: properties.enableGradient \u003d\u003d\u003d \u0027false\u0027 ? false : true,\n    footerText: (properties.footerText \u003d\u003d\u003d undefined) ? \u0027© Google Inc.\u0027 : properties.footerText,\n  headerLogoUrl: (properties.headerLogoUrl \u003d\u003d\u003d undefined) ? \u0027https://upload.wikimedia.org/wikipedia/commons/thumb/8/8a/Google_Gemini_logo.svg/2560px-Google_Gemini_logo.svg.png\u0027 : properties.headerLogoUrl,\n    closingLogoUrl: (properties.closingLogoUrl \u003d\u003d\u003d undefined) ? \u0027https://upload.wikimedia.org/wikipedia/commons/thumb/8/8a/Google_Gemini_logo.svg/2560px-Google_Gemini_logo.svg.png\u0027 : properties.closingLogoUrl,\n    titleBgUrl: properties.titleBgUrl || \u0027\u0027,\n    sectionBgUrl: properties.sectionBgUrl || \u0027\u0027,\n    mainBgUrl: properties.mainBgUrl || \u0027\u0027,\n    closingBgUrl: properties.closingBgUrl || \u0027\u0027,\n    driveFolderUrl: properties.driveFolderUrl || driveFolderUrl,\n    selectedPreset: properties.selectedPreset || \u0027default\u0027,\n    geminiGemUrl: scriptProperties.geminiGemUrl || null,\n    graphColorTheme: properties.graphColorTheme || \u0027primary\u0027,\n  };\n}\nfunction createBlankPresentation(slideData, settings) {\n  try {\n    const rawTitle \u003d (slideData[0] \u0026\u0026 slideData[0].type \u003d\u003d\u003d \u0027title\u0027 ? String(slideData[0].title || \u0027\u0027) : \u0027Google Slide Generator Presentation\u0027);\n    const singleLineTitle \u003d rawTitle.replace(/\\r?\\n/g, \u0027 \u0027).replace(/\\s+/g, \u0027 \u0027).trim();\n    let finalName;\n    if (settings.showDateColumn) {\n      const dateStr \u003d Utilities.formatDate(new Date(), Session.getScriptTimeZone(), \u0027yyyy.MM.dd\u0027);\n      finalName \u003d singleLineTitle ? (singleLineTitle + \u0027 \u0027 + dateStr) : (\u0027Google Slide Generator Presentation \u0027 + dateStr);\n    } else {\n      finalName \u003d singleLineTitle || \u0027Google Slide Generator Presentation\u0027;\n    }\n    const presentation \u003d SlidesApp.create(finalName);\n    const defaultSlide \u003d presentation.getSlides()[0];\n    if (defaultSlide) {\n      defaultSlide.remove();\n    }\n    let extractedId \u003d null;\n    const url \u003d settings.driveFolderUrl;\n    if (url) {\n      const drivePatterns \u003d [\n        /\\/folders\\/([a-zA-Z0-9_-]+)/,\n        /\\?id\u003d([a-zA-Z0-9_-]+)/\n      ];\n      for (let i \u003d 0; i \u003c drivePatterns.length; i++) {\n        const match \u003d url.match(drivePatterns[i]);\n        if (match \u0026\u0026 match[1]) {\n          extractedId \u003d match[1];\n          break;\n        }\n      }\n      if (!extractedId \u0026\u0026 /^[a-zA-Z0-9_-]{25,}$/.test(url)) {\n        extractedId \u003d url;\n      }\n    }\n    if (extractedId \u0026\u0026 extractedId.trim()) {\n      try {\n        DriveApp.getFileById(presentation.getId()).moveTo(DriveApp.getFolderById(extractedId.trim()));\n      } catch (e) {\n      }\n    }\n    addToUserHistory(presentation.getId());\n    return presentation.getUrl();\n  } catch (e) {\n    throw new Error(`Server error in createBlankPresentation: ${e.message}`);\n  }\n}\nfunction updateDynamicColors(settings) {\n  const primary \u003d settings.primaryColor;\n  CONFIG.COLORS.background_gray \u003d generateTintedGray(primary, 10, 99.5); \n  CONFIG.COLORS.faint_gray \u003d generateTintedGray(primary, 10, 93);\n  CONFIG.COLORS.ghost_gray \u003d generateTintedGray(primary, 38, 88);\n  CONFIG.COLORS.table_header_bg \u003d generateTintedGray(primary, 20, 94);\n  CONFIG.COLORS.lane_border \u003d generateTintedGray(primary, 15, 92);\n  CONFIG.COLORS.card_border \u003d generateTintedGray(primary, 15, 88);\n  CONFIG.COLORS.neutral_gray \u003d generateTintedGray(primary, 5, 62);\n  CONFIG.COLORS.process_arrow \u003d CONFIG.COLORS.ghost_gray;\n}\nfunction generateSlidesFromWebApp(slideDataString, settings, presentationId \u003d null, imageUpdateOption \u003d \u0027update\u0027) {\n  try {\n    const slideData \u003d JSON.parse(slideDataString);\n    const url \u003d createPresentation(slideData, settings, presentationId, imageUpdateOption);\n    if (presentationId) {\n      addToUserHistory(presentationId);\n    } else {\n      const match \u003d url.match(/\\/d\\/([a-zA-Z0-9_-]+)/);\n      if (match \u0026\u0026 match[1]) addToUserHistory(match[1]);\n    }\n    try {\n      let targetId \u003d null;\n      if (presentationId) {\n        targetId \u003d presentationId;\n      } \n      else if (url) {\n        const matchStandard \u003d url.match(/\\/d\\/([a-zA-Z0-9_-]+)/);\n        const matchOpen \u003d url.match(/id\u003d([a-zA-Z0-9_-]+)/);\n        if (matchStandard \u0026\u0026 matchStandard[1]) {\n          targetId \u003d matchStandard[1];\n        } else if (matchOpen \u0026\u0026 matchOpen[1]) {\n          targetId \u003d matchOpen[1];\n        }\n      }\n      if (targetId) {\n        saveGenerationState(targetId, slideData, settings);\n      } else {\n      }\n    } catch (e) {\n    }\n    return url;\n  } catch (e) {\n    throw new Error(`Server error: ${e.message}`);\n  }\n}\nlet __SECTION_COUNTER \u003d 0;\nlet __SLIDE_DATA_FOR_AGENDA \u003d [];\nlet __CREDIT_IMAGE_BLOB \u003d null;\nlet __CACHED_GRADIENT_BOTTOM_BAR \u003d null;\nlet __CACHED_GRADIENT_UNDERLINE_RECT \u003d null;\nlet __CACHED_HEADER_LOGO_GROUP \u003d null;\nlet __CACHED_CREDIT_IMAGE_GROUP \u003d null;\nconst CREDIT_IMAGE_LINK \u003d \u0027https://note.com/majin_108\u0027;\nfunction createPresentation(slideData, settings, presentationId \u003d null, imageUpdateOption \u003d \u0027update\u0027) {\n  __CACHED_GRADIENT_BOTTOM_BAR \u003d null;\n  __CACHED_GRADIENT_UNDERLINE_RECT \u003d null;\n  __CACHED_HEADER_LOGO_GROUP \u003d null;\n  __CACHED_CREDIT_IMAGE_GROUP \u003d null;\n  updateDynamicColors(settings);\n  CONFIG.COLORS.primary_color \u003d settings.primaryColor || CONFIG.COLORS.primary_color;\n  CONFIG.COLORS.text_primary \u003d settings.largeFontColor || \u0027#333333\u0027;\n  CONFIG.COLORS.text_small_font \u003d settings.smallFontColor || \u0027#1F2937\u0027;\n  if (settings.backgroundColor \u0026\u0026 settings.backgroundColor.toUpperCase() !\u003d\u003d \u0027#FFFFFF\u0027) {\n    CONFIG.COLORS.background_white \u003d settings.backgroundColor;\n  } else {\n    CONFIG.COLORS.background_white \u003d \u0027#FFFFFF\u0027;\n  }\n  CONFIG.FOOTER_TEXT \u003d settings.footerText;\n  CONFIG.FONTS.family \u003d settings.fontFamily || CONFIG.FONTS.family;\n  CONFIG.LOGOS.header \u003d settings.headerLogoUrl;\n  CONFIG.LOGOS.closing \u003d settings.closingLogoUrl;\n  CONFIG.BACKGROUND_IMAGES.title \u003d settings.titleBgUrl;\n  CONFIG.BACKGROUND_IMAGES.closing \u003d settings.closingBgUrl;\n  CONFIG.BACKGROUND_IMAGES.section \u003d settings.sectionBgUrl;\n  CONFIG.BACKGROUND_IMAGES.main \u003d settings.mainBgUrl;\n  __SLIDE_DATA_FOR_AGENDA \u003d slideData;\n  __CREDIT_IMAGE_BLOB \u003d null;\n  if (settings.creditImageBase64) {\n    try {\n      const parts \u003d settings.creditImageBase64.split(\u0027,\u0027);\n      if (parts.length !\u003d\u003d 2) throw new Error(\u0027Invalid Base64 format for credit image.\u0027);\n      const mimeType \u003d parts[0].match(/:(.*?);/)[1];\n      const decodedData \u003d Utilities.base64Decode(parts[1]);\n      __CREDIT_IMAGE_BLOB \u003d Utilities.newBlob(decodedData, mimeType, \u0027credit.png\u0027);\n    } catch (e) {\n    }\n  } else {\n  }\n  const rawTitle \u003d (slideData[0] \u0026\u0026 slideData[0].type \u003d\u003d\u003d \u0027title\u0027 ? String(slideData[0].title || \u0027\u0027) : \u0027Google Slide Generator Presentation\u0027);\n  const singleLineTitle \u003d rawTitle.replace(/\\r?\\n/g, \u0027 \u0027).replace(/\\s+/g, \u0027 \u0027).trim();\n  let finalName;\n  if (settings.showDateColumn) {\n    const dateStr \u003d Utilities.formatDate(new Date(), Session.getScriptTimeZone(), \u0027yyyy.MM.dd\u0027);\n    finalName \u003d singleLineTitle ? (singleLineTitle + \u0027 \u0027 + dateStr) : (\u0027Google Slide Generator Presentation \u0027 + dateStr);\n  } else {\n    finalName \u003d singleLineTitle || \u0027Google Slide Generator Presentation\u0027;\n  }\n  let presentation;\n  let isUpdating \u003d false;\n  if (presentationId) {\n    try {\n      const file \u003d DriveApp.getFileById(presentationId);\n      presentation \u003d SlidesApp.openById(file.getId());\n      presentation.setName(finalName);\n      if (settings.driveFolderId \u0026\u0026 settings.driveFolderId.trim()) {\n        try {\n          file.moveTo(DriveApp.getFolderById(settings.driveFolderId.trim()));\n        } catch (moveError) {\n        }\n      } else {\n        try {\n          file.moveTo(DriveApp.getRootFolder());\n        } catch (moveError) {\n        }\n      }\n      isUpdating \u003d true;\n    } catch (e) {\n      presentation \u003d SlidesApp.create(finalName);\n      const defaultSlide \u003d presentation.getSlides()[0];\n      if (defaultSlide) {\n        defaultSlide.remove();\n      }\n      if (settings.driveFolderId \u0026\u0026 settings.driveFolderId.trim()) {\n        try {\n          DriveApp.getFileById(presentation.getId()).moveTo(DriveApp.getFolderById(settings.driveFolderId.trim()));\n        } catch (moveError) {\n        }\n      }\n    }\n  } else {\n    presentation \u003d SlidesApp.create(finalName);\n    const defaultSlide \u003d presentation.getSlides()[0];\n    if (defaultSlide) {\n      defaultSlide.remove();\n    }\n    if (settings.driveFolderId \u0026\u0026 settings.driveFolderId.trim()) {\n      try {\n        DriveApp.getFileById(presentation.getId()).moveTo(DriveApp.getFolderById(settings.driveFolderId.trim()));\n      } catch (e) {\n      }\n    }\n  }\n  __SECTION_COUNTER \u003d 0;\n  const layout \u003d createLayoutManager(presentation.getPageWidth(), presentation.getPageHeight());\n  let pageCounter \u003d 0;\n  const existingSlides \u003d presentation.getSlides();\n  const numExistingSlides \u003d existingSlides.length;\n  const numNewSlides \u003d slideData.length;\n  for (let i \u003d 0; i \u003c numNewSlides; i++) {\n    const data \u003d slideData[i];\n    let slide;\n    let slideAction \u003d \u0027\u0027;\n    if (data.type !\u003d\u003d \u0027title\u0027 \u0026\u0026 data.type !\u003d\u003d \u0027closing\u0027) {\n      pageCounter++;\n    }\n    let generator \u003d slideGenerators[data.type];\n    if (!generator) {\n      generator \u003d createUnsupportedTypeSlide;\n    }\n    try {\n      if (isUpdating \u0026\u0026 i \u003c numExistingSlides) {\n        slide \u003d existingSlides[i];\n        clearSlideContents(slide, imageUpdateOption);\n        slideAction \u003d \u0027updated\u0027;\n      } else {\n        slide \u003d presentation.appendSlide(SlidesApp.PredefinedLayout.BLANK);\n        slideAction \u003d \u0027created\u0027;\n      }\n      generator(slide, data, layout, pageCounter, settings, imageUpdateOption);\n      if (data.notes) {\n        const cleanedNotes \u003d cleanSpeakerNotes(data.notes);\n        slide.getNotesPage().getSpeakerNotesShape().getText().setText(cleanedNotes);\n      }\n    } catch (e) {\n      if (slide \u0026\u0026 slideAction \u003d\u003d\u003d \u0027created\u0027) {\n        try { slide.remove(); } catch (removeError) {}\n      } else if (slide \u0026\u0026 slideAction \u003d\u003d\u003d \u0027updated\u0027) {\n        try {\n          clearSlideContents(slide, \u0027update\u0027);\n          const errorBox \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, 50, 50, 400, 100);\n          errorBox.getText().setText(`Error generating this slide:\\n${e.message}`);\n        } catch (errorBoxError) {}\n      }\n    }\n  }\n  if (isUpdating \u0026\u0026 numExistingSlides \u003e numNewSlides) {\n    for (let i \u003d numExistingSlides - 1; i \u003e\u003d numNewSlides; i--) {\n      try {\n        existingSlides[i].remove();\n      } catch (removeError) {\n      }\n    }\n  }\n  return presentation.getUrl();\n}\nfunction createUnsupportedTypeSlide(slide, data, layout, pageNum, settings, imageUpdateOption) {\n  slide.getBackground().setSolidFill(\u0027#FFFFFF\u0027);\n  const pageWidth \u003d layout.pageW_pt;\n  const pageHeight \u003d layout.pageH_pt;\n  const titleBox \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, 0, 0, pageWidth, pageHeight);\n  const textRange \u003d titleBox.getText();\n  textRange.setText(`⚠️ 未定義のスライドタイプが選択されています\\n\\n指定されたタイプ: \"${data.type}\"\\nGeminiでスライド構成データを再度作成してください。`);\n  textRange.getTextStyle()\n    .setFontSize(24)\n    .setForegroundColor(\u0027#FF0000\u0027)\n    .setBold(true)\n    .setFontFamily(settings.fontFamily || \u0027Noto Sans JP\u0027);\n  titleBox.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n  textRange.getParagraphStyle().setParagraphAlignment(SlidesApp.ParagraphAlignment.CENTER);\n  drawBottomBarAndFooter(slide, layout, pageNum, settings);\n}\nfunction clearSlideContents(slide, imageUpdateOption) {\n  const pageElements \u003d slide.getPageElements();\n  pageElements.forEach(element \u003d\u003e {\n    try {\n      if (imageUpdateOption \u003d\u003d\u003d \u0027keep\u0027 \u0026\u0026 element.getPageElementType() \u003d\u003d\u003d SlidesApp.PageElementType.IMAGE) {\n      } else {\n        element.remove();\n      }\n    } catch (e) {\n    }\n  });\n  try {\n    slide.getBackground().setSolidFill(\u0027#FFFFFF\u0027);\n  } catch(e) {\n  }\n}\nfunction updateSingleSlide(presentationId, slideIndex, singleSlideDataString, settings, imageUpdateOption) {\n  if (!presentationId || slideIndex \u003d\u003d null || slideIndex \u003c 0 || !singleSlideDataString) {\n    return { status: \u0027error\u0027, message: \u0027無効なパラメータが指定されました。\u0027 };\n  }\n  try {\n    __CREDIT_IMAGE_BLOB \u003d null;\n    if (settings.creditImageBase64) {\n      try {\n        const parts \u003d settings.creditImageBase64.split(\u0027,\u0027);\n        if (parts.length \u003d\u003d\u003d 2) {\n          const mimeType \u003d parts[0].match(/:(.*?);/)[1];\n          const decodedData \u003d Utilities.base64Decode(parts[1]);\n          __CREDIT_IMAGE_BLOB \u003d Utilities.newBlob(decodedData, mimeType, \u0027credit.png\u0027);\n        }\n      } catch (e) {}\n    }\n    let presentation;\n    try {\n      presentation \u003d SlidesApp.openById(presentationId);\n    } catch (e) {\n      return { status: \u0027error\u0027, message: `プレゼンテーション (ID: ${presentationId}) を開けませんでした: ${e.message}` };\n    }\n    const slides \u003d presentation.getSlides();\n    if (slideIndex \u003e\u003d slides.length) {\n      return { status: \u0027error\u0027, message: `指定されたページ番号 (${slideIndex + 1}) のスライドが存在しません。` };\n    }\n    const slide \u003d slides[slideIndex];\n    let newData;\n    try {\n      newData \u003d JSON.parse(singleSlideDataString);\n    } catch (e) {\n      return { status: \u0027error\u0027, message: `スライドデータのJSON形式が不正です: ${e.message}` };\n    }\n    if (!newData || !newData.type) {\n       return { status: \u0027error\u0027, message: \u0027スライドデータに type プロパティが含まれていません。\u0027 };\n    }\n    updateDynamicColors(settings);\n    CONFIG.COLORS.primary_color \u003d settings.primaryColor || CONFIG.COLORS.primary_color;\n    CONFIG.COLORS.text_primary \u003d settings.largeFontColor || \u0027#333333\u0027;\n    CONFIG.COLORS.text_small_font \u003d settings.smallFontColor || \u0027#1F2937\u0027;\n    CONFIG.COLORS.background_white \u003d (settings.backgroundColor \u0026\u0026 settings.backgroundColor.toUpperCase() !\u003d\u003d \u0027#FFFFFF\u0027) ? settings.backgroundColor : \u0027#FFFFFF\u0027;\n    CONFIG.FOOTER_TEXT \u003d settings.footerText;\n    CONFIG.FONTS.family \u003d settings.fontFamily || CONFIG.FONTS.family;\n    CONFIG.LOGOS.header \u003d settings.headerLogoUrl;\n    CONFIG.LOGOS.closing \u003d settings.closingLogoUrl;\n    CONFIG.BACKGROUND_IMAGES.title \u003d settings.titleBgUrl;\n    CONFIG.BACKGROUND_IMAGES.closing \u003d settings.closingBgUrl;\n    CONFIG.BACKGROUND_IMAGES.section \u003d settings.sectionBgUrl;\n    CONFIG.BACKGROUND_IMAGES.main \u003d settings.mainBgUrl;\n    const layout \u003d createLayoutManager(presentation.getPageWidth(), presentation.getPageHeight());\n    clearSlideContents(slide, imageUpdateOption);\n    const generator \u003d slideGenerators[newData.type];\n    if (!generator) {\n      return { status: \u0027error\u0027, message: `スライドタイプ \"${newData.type}\" に対応する生成関数が見つかりません。` };\n    }\n    let pageCounterForFooter \u003d 0;\n    if (newData.type !\u003d\u003d \u0027title\u0027 \u0026\u0026 newData.type !\u003d\u003d \u0027closing\u0027) {\n        pageCounterForFooter \u003d slideIndex + 1;\n    }\n    generator(slide, newData, layout, pageCounterForFooter, settings, imageUpdateOption);\n    if (newData.notes) {\n      const cleanedNotes \u003d cleanSpeakerNotes(newData.notes);\n      slide.getNotesPage().getSpeakerNotesShape().getText().setText(cleanedNotes);\n    } else {\n      slide.getNotesPage().getSpeakerNotesShape().getText().setText(\u0027\u0027);\n    }\n    try {\n       const loadResult \u003d loadLatestGenerationState(presentationId);\n       let fullSlideDataToSave \u003d [];\n       if (loadResult.status \u003d\u003d\u003d \u0027success\u0027 \u0026\u0026 loadResult.data \u0026\u0026 Array.isArray(loadResult.data.slideData)) {\n         fullSlideDataToSave \u003d JSON.parse(JSON.stringify(loadResult.data.slideData));\n         if (slideIndex \u003c fullSlideDataToSave.length) {\n           fullSlideDataToSave[slideIndex] \u003d newData;\n         } else {\n           fullSlideDataToSave \u003d [newData];\n         }\n       } else {\n         fullSlideDataToSave \u003d [newData]; \n       }\n       saveGenerationState(presentationId, fullSlideDataToSave, settings);\n    } catch (e) {\n    }\n    addToUserHistory(presentationId);\n    return { status: \u0027success\u0027, message: `ページ ${slideIndex + 1} を更新しました。` };\n  } catch (e) {\n    return { status: \u0027error\u0027, message: `ページ ${slideIndex + 1} の更新中にエラーが発生しました: ${e.message}` };\n  }\n}\nconst slideGenerators \u003d {\n  title: createTitleSlide,\n  section: createSectionSlide,\n  content: createContentSlide,\n  agenda: createAgendaSlide,\n  compare: createCompareSlide,\n  process: createProcessSlide,\n  processList: createProcessListSlide,\n  timeline: createTimelineSlide,\n  diagram: createDiagramSlide,\n  cycle: createCycleSlide,\n  cards: createCardsSlide,\n  headerCards: createHeaderCardsSlide,\n  table: createTableSlide,\n  progress: createProgressSlide,\n  quote: createQuoteSlide,\n  kpi: createKpiSlide,\n  closing: createClosingSlide,\n  bulletCards: createBulletCardsSlide,\n  faq: createFaqSlide,\n  statsCompare: createStatsCompareSlide,\n  barCompare: createBarCompareSlide,\n  triangle: createTriangleSlide,\n  pyramid: createPyramidSlide,\n  flowChart: createFlowChartSlide,\n  stepUp: createStepUpSlide,\n  imageText: createImageTextSlide,\n  fullImage: createFullImageSlide\n};\nfunction createLayoutManager(pageW_pt, pageH_pt) {\n  const pxToPt \u003d (px) \u003d\u003e px * 0.75;\n  const baseW_pt \u003d pxToPt(CONFIG.BASE_PX.W),\n    baseH_pt \u003d pxToPt(CONFIG.BASE_PX.H);\n  const scaleX \u003d pageW_pt / baseW_pt,\n    scaleY \u003d pageH_pt / baseH_pt;\n  const getPositionFromPath \u003d (path) \u003d\u003e path.split(\u0027.\u0027).reduce((obj, key) \u003d\u003e obj[key], CONFIG.POS_PX);\n  return {\n    scaleX,\n    scaleY,\n    pageW_pt,\n    pageH_pt,\n    pxToPt,\n    getRect: (spec) \u003d\u003e {\n      const pos \u003d typeof spec \u003d\u003d\u003d \u0027string\u0027 ? getPositionFromPath(spec) : spec;\n      let left_px \u003d pos.left;\n      if (pos.right !\u003d\u003d undefined \u0026\u0026 pos.left \u003d\u003d\u003d undefined) {\n        left_px \u003d CONFIG.BASE_PX.W - pos.right - pos.width;\n      }\n      if (left_px \u003d\u003d\u003d undefined \u0026\u0026 pos.right \u003d\u003d\u003d undefined) {\n        left_px \u003d 0;\n      }\n      return {\n        left: left_px !\u003d\u003d undefined ? pxToPt(left_px) * scaleX : 0,\n        top: pos.top !\u003d\u003d undefined ? pxToPt(pos.top) * scaleY : 0,\n        width: pos.width !\u003d\u003d undefined ? pxToPt(pos.width) * scaleX : 0,\n        height: pos.height !\u003d\u003d undefined ? pxToPt(pos.height) * scaleY : 0,\n      };\n    }\n  };\n}\nfunction adjustAreaForSubhead(area, subhead, layout) {\n  return area;\n}\nfunction createContentCushion(slide, area, settings, layout) {\n  if (!area || !area.width || !area.height || area.width \u003c\u003d 0 || area.height \u003c\u003d 0) {\n    return;\n  }\n  const cushionColor \u003d CONFIG.COLORS.background_gray;\n  const cushion \u003d slide.insertShape(SlidesApp.ShapeType.RECTANGLE, \n    area.left, area.top, area.width, area.height);\n  cushion.getFill().setSolidFill(cushionColor, 1.0);\n  const border \u003d cushion.getBorder();\n  border.setTransparent();\n}\nfunction createTitleSlide(slide, data, layout, pageNum, settings, imageUpdateOption \u003d \u0027update\u0027) {\n  setBackgroundImageFromUrl(slide, layout, CONFIG.BACKGROUND_IMAGES.title, CONFIG.COLORS.background_white, imageUpdateOption);\n  if (imageUpdateOption \u003d\u003d\u003d \u0027update\u0027) {\n    const logoRect \u003d layout.getRect(\u0027titleSlide.logo\u0027);\n    try {\n      if (CONFIG.LOGOS.header) {\n        const imageData \u003d insertImageFromUrlOrFileId(CONFIG.LOGOS.header);\n        if (imageData) {\n          const logo \u003d slide.insertImage(imageData);\n          const aspect \u003d logo.getHeight() / logo.getWidth();\n          logo.setLeft(logoRect.left).setTop(logoRect.top).setWidth(logoRect.width).setHeight(logoRect.width * aspect);\n        }\n      }\n    } catch (e) {\n    }\n  }\n  const titleRect \u003d layout.getRect(\u0027titleSlide.title\u0027);\n  const newTop \u003d (layout.pageH_pt - titleRect.height) / 2;\n  const newWidth \u003d titleRect.width + layout.pxToPt(60);\n  const titleShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, titleRect.left, newTop, newWidth, titleRect.height);\n  setStyledText(titleShape, data.title, {\n    size: CONFIG.FONTS.sizes.title,\n    bold: true,\n    fontType: \u0027large\u0027\n  });\n  try {\n    titleShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n  } catch (e) {\n  }\n  try {\n    const titleText \u003d data.title || \u0027\u0027;\n    if (titleText.indexOf(\u0027\\n\u0027) \u003d\u003d\u003d -1) {\n      const preCalculatedWidth \u003d (data \u0026\u0026 typeof data._title_widthPt \u003d\u003d\u003d \u0027number\u0027) ?\n  data._title_widthPt : null;\n      if (preCalculatedWidth !\u003d\u003d null \u0026\u0026 preCalculatedWidth \u003c 900) {\n        const adjustmentLog \u003d adjustShapeText_External(titleShape, preCalculatedWidth);\n      } else if (preCalculatedWidth !\u003d\u003d null) {\n      } else {\n        const adjustmentLog \u003d adjustShapeText_External(titleShape, null);\n  }\n    } else {\n    }\n  } catch (e) {\n  }\n  try {\n    const titleTextRange \u003d titleShape.getText();\n    if (!titleTextRange.isEmpty()) {\n      const firstRun \u003d titleTextRange.getRuns()[0];\n      if (firstRun) {\n        const currentFontSize \u003d firstRun.getTextStyle().getFontSize();\n        if (currentFontSize \u003d\u003d\u003d 41) {\n          titleTextRange.getTextStyle().setFontSize(40);\n        }\n      }\n    }\n  } catch (e) {\n  }\n  if (settings.showDateColumn) {\n    const dateRect \u003d layout.getRect(\u0027titleSlide.date\u0027);\n    const dateShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, dateRect.left, dateRect.top, dateRect.width, dateRect.height);\n    dateShape.getText().setText(data.date || \u0027\u0027);\n    applyTextStyle(dateShape.getText(), {\n      size: CONFIG.FONTS.sizes.date,\n      fontType: \u0027large\u0027\n    });\n  }\n  if (settings.showBottomBar) {\n    drawBottomBar(slide, layout, settings);\n  }\n  if (__CREDIT_IMAGE_BLOB) {\n    drawCreditImage(slide, layout, __CREDIT_IMAGE_BLOB, CREDIT_IMAGE_LINK);\n  }\n}\nfunction createSectionSlide(slide, data, layout, pageNum, settings, imageUpdateOption \u003d \u0027update\u0027) {\n  const imageUrl \u003d CONFIG.BACKGROUND_IMAGES.section || CONFIG.BACKGROUND_IMAGES.main || \u0027\u0027;\n  let fallbackColor;\n  if (imageUrl) {\n    fallbackColor \u003d CONFIG.COLORS.background_white;\n  } else {\n    if (CONFIG.COLORS.background_white.toUpperCase() !\u003d\u003d \u0027#FFFFFF\u0027) {\n      fallbackColor \u003d CONFIG.COLORS.background_white;\n    } else {\n      fallbackColor \u003d CONFIG.COLORS.background_gray;\n    }\n  }\n  setBackgroundImageFromUrl(slide, layout, imageUrl, fallbackColor, imageUpdateOption);\n  __SECTION_COUNTER++;\n  const parsedNum \u003d (() \u003d\u003e {\n    if (Number.isFinite(data.sectionNo)) {\n      return Number(data.sectionNo);\n    }\n    const m \u003d String(data.title || \u0027\u0027).match(/^\\s*(\\d+)[\\.．]/);\n    return m ? Number(m[1]) : __SECTION_COUNTER;\n  })();\n  const num \u003d String(parsedNum).padStart(2, \u00270\u0027);\n  const ghostRect \u003d layout.getRect(\u0027sectionSlide.ghostNum\u0027);\n  let ghostImageInserted \u003d false;\n  if (imageUpdateOption \u003d\u003d\u003d \u0027update\u0027) {\n    if (data.ghostImageBase64 \u0026\u0026 ghostRect) {\n      try {\n        const imageData \u003d insertImageFromUrlOrFileId(data.ghostImageBase64);\n        if (imageData) {\n          const ghostImage \u003d slide.insertImage(imageData);\n          const imgWidth \u003d ghostImage.getWidth();\n          const imgHeight \u003d ghostImage.getHeight();\n          const scale \u003d Math.min(ghostRect.width / imgWidth, ghostRect.height / imgHeight);\n          const w \u003d imgWidth * scale;\n          const h \u003d imgHeight * scale;\n          ghostImage.setWidth(w).setHeight(h)\n            .setLeft(ghostRect.left + (ghostRect.width - w) / 2)\n            .setTop(ghostRect.top + (ghostRect.height - h) / 2);\n          ghostImageInserted \u003d true;\n        }\n      } catch (e) {\n      }\n    }\n  }\n  if (!ghostImageInserted \u0026\u0026 ghostRect \u0026\u0026 imageUpdateOption \u003d\u003d\u003d \u0027update\u0027) {\n    const ghost \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, ghostRect.left, ghostRect.top, ghostRect.width, ghostRect.height);\n    ghost.getText().setText(num);\n    const ghostTextStyle \u003d ghost.getText().getTextStyle();\n    ghostTextStyle.setFontFamily(CONFIG.FONTS.family)\n      .setFontSize(CONFIG.FONTS.sizes.ghostNum)\n      .setBold(true);\n    try {\n      ghostTextStyle.setForegroundColorWithAlpha(CONFIG.COLORS.ghost_gray, 0.15);\n    } catch (e) {\n      ghostTextStyle.setForegroundColor(CONFIG.COLORS.ghost_gray);\n    }\n    try {\n      ghost.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n    } catch (e) {}\n  }\n  const titleRect \u003d layout.getRect(\u0027sectionSlide.title\u0027);\n  const titleShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, titleRect.left, titleRect.top, titleRect.width, titleRect.height);\n  titleShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n  setStyledText(titleShape, data.title, {\n    size: CONFIG.FONTS.sizes.sectionTitle,\n    bold: true,\n    align: SlidesApp.ParagraphAlignment.CENTER,\n    fontType: \u0027large\u0027\n  });\n  try {\n    const titleText \u003d data.title ||\n    \u0027\u0027;\n    if (titleText.indexOf(\u0027\\n\u0027) \u003d\u003d\u003d -1) {\n      const preCalculatedWidthPt \u003d (data \u0026\u0026 typeof data._title_widthPt \u003d\u003d\u003d \u0027number\u0027) ?\n      data._title_widthPt : null;\n      const textAreaWidthPt \u003d titleRect.width;\n      if (textAreaWidthPt \u003e 0 \u0026\u0026 (preCalculatedWidthPt \u003d\u003d\u003d null || preCalculatedWidthPt \u003c (textAreaWidthPt * 1.4))) {\n        if (preCalculatedWidthPt !\u003d\u003d null) {\n        } else {\n        }\n        const adjustmentLog \u003d adjustShapeText_External(titleShape, preCalculatedWidthPt);\n      } else if (preCalculatedWidthPt !\u003d\u003d null) {\n      }\n    } else {\n    }\n  } catch (e) {\n  }\n  addCucFooter(slide, layout, pageNum, settings);\n}\nfunction createClosingSlide(slide, data, layout, pageNum, settings, imageUpdateOption \u003d \u0027update\u0027) {\n  setBackgroundImageFromUrl(slide, layout, CONFIG.BACKGROUND_IMAGES.closing, CONFIG.COLORS.background_white, imageUpdateOption);\n  if (imageUpdateOption \u003d\u003d\u003d \u0027update\u0027) {\n    try {\n      if (CONFIG.LOGOS.closing) {\n        const imageData \u003d insertImageFromUrlOrFileId(CONFIG.LOGOS.closing);\n        if (imageData) {\n          const image \u003d slide.insertImage(imageData);\n          const imgW_pt \u003d layout.pxToPt(450) * layout.scaleX;\n          const aspect \u003d image.getHeight() / image.getWidth();\n          image.setWidth(imgW_pt).setHeight(imgW_pt * aspect);\n          image.setLeft((layout.pageW_pt - imgW_pt) / 2).setTop((layout.pageH_pt - (imgW_pt * aspect)) / 2);\n        }\n      }\n    } catch (e) {\n    }\n  }\n  if (__CREDIT_IMAGE_BLOB) {\n    drawCreditImage(slide, layout, __CREDIT_IMAGE_BLOB, CREDIT_IMAGE_LINK);\n  }\n}\nfunction createContentSlide(slide, data, layout, pageNum, settings, imageUpdateOption \u003d \u0027update\u0027) {\n  setMainSlideBackground(slide, layout);\n  const titleWidthPt \u003d (data \u0026\u0026 typeof data._title_widthPt \u003d\u003d\u003d \u0027number\u0027) ? data._title_widthPt : null;\n  drawStandardTitleHeader(slide, layout, \u0027contentSlide\u0027, data.title, settings, titleWidthPt, imageUpdateOption);\n  const subheadWidthPt \u003d (data \u0026\u0026 typeof data._subhead_widthPt \u003d\u003d\u003d \u0027number\u0027) ?\n  data._subhead_widthPt : null;\n  const dy \u003d drawSubheadIfAny(slide, layout, \u0027contentSlide\u0027, data.subhead, subheadWidthPt); \n  const isAgenda \u003d isAgendaTitle(data.title || \u0027\u0027);\n  let points \u003d Array.isArray(data.points) ? data.points.slice(0) : [];\n  if (isAgenda \u0026\u0026 points.length \u003d\u003d\u003d 0) {\n    points \u003d buildAgendaFromSlideData();\n    if (points.length \u003d\u003d\u003d 0) {\n      points \u003d [\u0027本日の目的\u0027, \u0027進め方\u0027, \u0027次のアクション\u0027];\n    }\n  }\n  const hasImages \u003d Array.isArray(data.images) \u0026\u0026 data.images.length \u003e 0;\n  const isTwo \u003d !!(data.twoColumn || data.columns);\n  if ((isTwo \u0026\u0026 (data.columns || points)) || (!isTwo \u0026\u0026 points \u0026\u0026 points.length \u003e 0)) {\n    if (isTwo) {\n      let L \u003d [], R \u003d [];\n      if (Array.isArray(data.columns) \u0026\u0026 data.columns.length \u003d\u003d\u003d 2) {\n        L \u003d data.columns[0] || [];\n        R \u003d data.columns[1] || [];\n      } else {\n        const mid \u003d Math.ceil(points.length / 2);\n        L \u003d points.slice(0, mid);\n        R \u003d points.slice(mid);\n      }\n      const baseLeftRect \u003d layout.getRect(\u0027contentSlide.twoColLeft\u0027);\n      const baseRightRect \u003d layout.getRect(\u0027contentSlide.twoColRight\u0027);\n      const adjustedLeftRect \u003d adjustAreaForSubhead(baseLeftRect, data.subhead, layout);\n      const adjustedRightRect \u003d adjustAreaForSubhead(baseRightRect, data.subhead, layout);\n      const leftRect \u003d offsetRect(adjustedLeftRect, 0, dy);\n      const rightRect \u003d offsetRect(adjustedRightRect, 0, dy);\n      createContentCushion(slide, leftRect, settings, layout);\n      createContentCushion(slide, rightRect, settings, layout);\n      const padding \u003d layout.pxToPt(20);\n      const leftTextRect \u003d { left: leftRect.left + padding, top: leftRect.top + padding, width: leftRect.width - (padding * 2), height: leftRect.height - (padding * 2) };\n      const rightTextRect \u003d { left: rightRect.left + padding, top: rightRect.top + padding, width: rightRect.width - (padding * 2), height: rightRect.height - (padding * 2) };\n      const leftShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, leftTextRect.left, leftTextRect.top, leftTextRect.width, leftTextRect.height);\n      const rightShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, rightTextRect.left, rightTextRect.top, rightTextRect.width, rightTextRect.height);\n      setBulletsWithInlineStyles(leftShape, L);\n      setBulletsWithInlineStyles(rightShape, R);\n      setBoldTextSize(leftShape, 16);\n      setBoldTextSize(rightShape, 16);\n      try {\n        const leftAdjustmentLog \u003d adjustShapeText_External(leftShape, null);\n      } catch(e) {\n      }\n      try {\n        const rightAdjustmentLog \u003d adjustShapeText_External(rightShape, null);\n      } catch(e) {\n      }\n    } else {\n      const baseBodyRect \u003d layout.getRect(\u0027contentSlide.body\u0027);\n      const adjustedBodyRect \u003d adjustAreaForSubhead(baseBodyRect, data.subhead, layout);\n      const bodyRect \u003d offsetRect(adjustedBodyRect, 0, dy);\n      createContentCushion(slide, bodyRect, settings, layout);\n      if (isAgenda) {\n        drawNumberedItems(slide, layout, bodyRect, points, settings);\n      } else {\n        const padding \u003d layout.pxToPt(20);\n        const textRect \u003d { left: bodyRect.left + padding, top: bodyRect.top + padding, width: bodyRect.width - (padding * 2), height: bodyRect.height - (padding * 2) };\n        const bodyShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, textRect.left, textRect.top, textRect.width, textRect.height);\n        setBulletsWithInlineStyles(bodyShape, points);\n        setBoldTextSize(bodyShape, 16);\n        try {\n          bodyShape.setContentAlignment(SlidesApp.ContentAlignment.TOP);\n        } catch(e) {\n        }\n        try {\n          const bodyAdjustmentLog \u003d adjustShapeText_External(bodyShape, null);\n          if (bodyAdjustmentLog.finalSize !\u003d\u003d null \u0026\u0026 bodyAdjustmentLog.finalSize \u003c CONFIG.FONTS.sizes.body) {\n             bodyShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n          }\n        } catch(e) { \n        }\n      }\n    }\n  }\n  if (hasImages \u0026\u0026 !points.length \u0026\u0026 !isTwo) {\n    const baseArea \u003d layout.getRect(\u0027contentSlide.body\u0027);\n    const adjustedArea \u003d adjustAreaForSubhead(baseArea, data.subhead, layout);\n    const area \u003d offsetRect(adjustedArea, 0, dy);\n    createContentCushion(slide, area, settings, layout);\n    renderImagesInArea(slide, layout, area, normalizeImages(data.images), imageUpdateOption);\n  }\n  drawBottomBarAndFooter(slide, layout, pageNum, settings);\n}\nfunction createCompareSlide(slide, data, layout, pageNum, settings, imageUpdateOption \u003d \u0027update\u0027) {\n  setMainSlideBackground(slide, layout);\n  const titleWidthPt \u003d (data \u0026\u0026 typeof data._title_widthPt \u003d\u003d\u003d \u0027number\u0027) ? data._title_widthPt : null;\n  drawStandardTitleHeader(slide, layout, \u0027cardsSlide\u0027, data.title, settings, titleWidthPt, imageUpdateOption);\n  const subheadWidthPt \u003d (data \u0026\u0026 typeof data._subhead_widthPt \u003d\u003d\u003d \u0027number\u0027) ?\n  data._subhead_widthPt : null;\n  const dy \u003d drawSubheadIfAny(slide, layout, \u0027cardsSlide\u0027, data.subhead, subheadWidthPt);\n  const baseArea \u003d layout.getRect(\u0027cardsSlide.gridArea\u0027);\n  const adjustedArea \u003d adjustAreaForSubhead(baseArea, data.subhead, layout);\n  const area \u003d offsetRect(adjustedArea, 0, dy);\n  const cols \u003d 2;\n  const gap \u003d layout.pxToPt(16);\n  const cardW \u003d (area.width - gap * (cols - 1)) / cols;\n  const cardH \u003d area.height;\n  const leftBoxLeft \u003d area.left;\n  const leftBoxTop \u003d area.top;\n  const leftBoxWidth \u003d cardW;\n  const leftBoxHeight \u003d cardH;\n  const rightBoxLeft \u003d area.left + cardW + gap;\n  const rightBoxTop \u003d area.top;\n  const rightBoxWidth \u003d cardW;\n  const rightBoxHeight \u003d cardH;\n  drawCompareBox(slide, layout, leftBoxLeft, leftBoxTop, leftBoxWidth, leftBoxHeight, data.leftTitle || \u0027選択肢A\u0027, data.leftItems || [], settings, true);\n  drawCompareBox(slide, layout, rightBoxLeft, rightBoxTop, rightBoxWidth, rightBoxHeight, data.rightTitle || \u0027選択肢B\u0027, data.rightItems || [], settings, false);\n  drawBottomBarAndFooter(slide, layout, pageNum, settings);\n}\nfunction createProcessSlide(slide, data, layout, pageNum, settings, imageUpdateOption \u003d \u0027update\u0027) {\n  setMainSlideBackground(slide, layout, imageUpdateOption);\n  drawStandardTitleHeader(slide, layout, \u0027processSlide\u0027, data.title, settings, imageUpdateOption);\n  const subheadWidthPt \u003d (data \u0026\u0026 typeof data._subhead_widthPt \u003d\u003d\u003d \u0027number\u0027) ?\n  data._subhead_widthPt : null;\n  const dy \u003d drawSubheadIfAny(slide, layout, \u0027processSlide\u0027, data.subhead, subheadWidthPt);\n  const baseArea \u003d layout.getRect(\u0027processSlide.area\u0027);\n  const adjustedArea \u003d adjustAreaForSubhead(baseArea, data.subhead, layout);\n  const area \u003d offsetRect(adjustedArea, 0, dy);\n  const steps \u003d Array.isArray(data.steps) ? data.steps.slice(0, 4) : [];\n  if (steps.length \u003d\u003d\u003d 0) {\n    drawBottomBarAndFooter(slide, layout, pageNum, settings);\n    return;\n  }\n  const processBodyBgColor \u003d generateTintedGray(settings.primaryColor, 30, 94);\n  const n \u003d steps.length;\n  let boxHPx, arrowHPx, fontSize;\n  if (n \u003c\u003d 2) {\n    boxHPx \u003d 100;\n    arrowHPx \u003d 25;\n    fontSize \u003d 16;\n  } else if (n \u003d\u003d\u003d 3) {\n    boxHPx \u003d 80;\n    arrowHPx \u003d 20;\n    fontSize \u003d 16;\n  } else {\n    boxHPx \u003d 65;\n    arrowHPx \u003d 15;\n    fontSize \u003d 14;\n  }\n  const processColors \u003d generateProcessColors(settings.primaryColor, n);\n  const startY \u003d area.top + layout.pxToPt(10);\n  let currentY \u003d startY;\n  const boxHPt \u003d layout.pxToPt(boxHPx),\n    arrowHPt \u003d layout.pxToPt(arrowHPx);\n  const headerWPt \u003d layout.pxToPt(120);\n  const bodyLeft \u003d area.left + headerWPt;\n  const bodyWPt \u003d area.width - headerWPt;\n  for (let i \u003d 0; i \u003c n; i++) {\n    const cleanText \u003d String(steps[i] || \u0027\u0027).replace(/^\\s*\\d+(\\.\\s*|\\s+)/, \u0027\u0027);\n    const header \u003d slide.insertShape(SlidesApp.ShapeType.RECTANGLE, area.left, currentY, headerWPt, boxHPt);\n    header.getFill().setSolidFill(processColors[i]);\n    header.getBorder().setTransparent();\n    setStyledText(header, `STEP ${i + 1}`, {\n      size: fontSize,\n      bold: true,\n      color: CONFIG.COLORS.background_gray,\n      align: SlidesApp.ParagraphAlignment.CENTER\n    });\n    try {\n      header.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n    } catch (e) {}\n    const body \u003d slide.insertShape(SlidesApp.ShapeType.RECTANGLE, bodyLeft, currentY, bodyWPt, boxHPt);\n    body.getFill().setSolidFill(CONFIG.COLORS.background_gray);\n    body.getBorder().setTransparent();\n    const textShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, bodyLeft + layout.pxToPt(20), currentY, bodyWPt - layout.pxToPt(40), boxHPt);\n    setStyledText(textShape, cleanText, {\n      size: fontSize\n    });\n    try {\n      textShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n    } catch (e) {}\n    currentY +\u003d boxHPt;\n    if (i \u003c n - 1) {\n      const arrowLeft \u003d area.left + headerWPt / 2 - layout.pxToPt(8);\n      const arrow \u003d slide.insertShape(SlidesApp.ShapeType.DOWN_ARROW, arrowLeft, currentY, layout.pxToPt(16), arrowHPt);\n      arrow.getFill().setSolidFill(CONFIG.COLORS.process_arrow);\n      arrow.getBorder().setTransparent();\n      currentY +\u003d arrowHPt;\n    }\n  }\n  drawBottomBarAndFooter(slide, layout, pageNum, settings);\n}\nfunction createProcessListSlide(slide, data, layout, pageNum, settings, imageUpdateOption \u003d \u0027update\u0027) {\n  setMainSlideBackground(slide, layout);\n  const titleWidthPt \u003d (data \u0026\u0026 typeof data._title_widthPt \u003d\u003d\u003d \u0027number\u0027) ? data._title_widthPt : null;\n  drawStandardTitleHeader(slide, layout, \u0027processSlide\u0027, data.title, settings, titleWidthPt, imageUpdateOption);\n  const subheadWidthPt \u003d (data \u0026\u0026 typeof data._subhead_widthPt \u003d\u003d\u003d \u0027number\u0027) ?\n  data._subhead_widthPt : null;\n  const dy \u003d drawSubheadIfAny(slide, layout, \u0027processSlide\u0027, data.subhead, subheadWidthPt); \n  const area \u003d offsetRect(layout.getRect(\u0027processSlide.area\u0027), 0, dy);\n  const steps \u003d Array.isArray(data.steps) ? data.steps : [];\n  if (steps.length \u003d\u003d\u003d 0) {\n    drawBottomBarAndFooter(slide, layout, pageNum, settings);\n    return;\n  }\n  const n \u003d Math.max(1, steps.length);\n  const topPadding \u003d layout.pxToPt(30);\n  const bottomPadding \u003d layout.pxToPt(10);\n  const drawableHeight \u003d area.height - topPadding - bottomPadding; \n  const maxGapY_pt \u003d layout.pxToPt(70);\n  let idealGapY \u003d Infinity;\n  if (n \u003e 1) {\n    idealGapY \u003d drawableHeight / (n - 1);\n  }\n  const finalGapY \u003d Math.min(idealGapY, maxGapY_pt);\n  const cx \u003d area.left + layout.pxToPt(44); \n  const top0 \u003d area.top + topPadding;\n  const line \u003d slide.insertShape(SlidesApp.ShapeType.RECTANGLE, cx - layout.pxToPt(1), top0 + layout.pxToPt(6), layout.pxToPt(2), finalGapY * (n - 1));\n  line.getFill().setSolidFill(CONFIG.COLORS.faint_gray);\n  line.getBorder().setTransparent();\n  for (let i \u003d 0; i \u003c n; i++) {\n    const cy \u003d top0 + finalGapY * i;\n    const sz \u003d layout.pxToPt(28);\n    const numBox \u003d slide.insertShape(SlidesApp.ShapeType.RECTANGLE, cx - sz/2, cy - sz/2, sz, sz);\n    numBox.getFill().setSolidFill(settings.primaryColor);\n    numBox.getBorder().setTransparent();\n    const num \u003d numBox.getText(); num.setText(String(i + 1));\n    applyTextStyle(num, { size: 12, bold: true, color: CONFIG.COLORS.background_gray, align: SlidesApp.ParagraphAlignment.CENTER });\n    let cleanText \u003d String(steps[i] || \u0027\u0027);\n    cleanText \u003d cleanText.replace(/^\\s*\\d+(\\.\\s*|\\s+)/, \u0027\u0027);\n    const txt \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, cx + layout.pxToPt(28), cy - layout.pxToPt(16), area.width - layout.pxToPt(70), layout.pxToPt(32));\n    setStyledText(txt, cleanText, { size: CONFIG.FONTS.sizes.processStep, fontType: \u0027large\u0027 });\n    try { txt.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE); } catch(e){}\n  }\n  drawBottomBarAndFooter(slide, layout, pageNum, settings);\n}\nfunction createTimelineSlide(slide, data, layout, pageNum, settings, imageUpdateOption \u003d \u0027update\u0027) {\n  setMainSlideBackground(slide, layout);\n  const titleWidthPt \u003d (data \u0026\u0026 typeof data._title_widthPt \u003d\u003d\u003d \u0027number\u0027) ? data._title_widthPt : null;\n  drawStandardTitleHeader(slide, layout, \u0027timelineSlide\u0027, data.title, settings, titleWidthPt, imageUpdateOption);\n  const subheadWidthPt \u003d (data \u0026\u0026 typeof data._subhead_widthPt \u003d\u003d\u003d \u0027number\u0027) ?\n  data._subhead_widthPt : null;\n  const dy \u003d drawSubheadIfAny(slide, layout, \u0027timelineSlide\u0027, data.subhead, subheadWidthPt); \n  const baseArea \u003d layout.getRect(\u0027timelineSlide.area\u0027);\n  const adjustedArea \u003d adjustAreaForSubhead(baseArea, data.subhead, layout);\n  const area \u003d offsetRect(adjustedArea, 0, dy);\n  const milestones \u003d Array.isArray(data.milestones) ? data.milestones : [];\n  if (milestones.length \u003d\u003d\u003d 0) {\n    drawBottomBarAndFooter(slide, layout, pageNum, settings);\n    return;\n  }\n  const inner \u003d layout.pxToPt(80),\n    baseY \u003d area.top + area.height * 0.50;\n  const leftX \u003d area.left + inner,\n    rightX \u003d area.left + area.width - inner;\n  const line \u003d slide.insertLine(SlidesApp.LineCategory.STRAIGHT, leftX, baseY, rightX, baseY);\n  line.getLineFill().setSolidFill(CONFIG.COLORS.faint_gray);\n  line.setWeight(2);\n  const dotR \u003d layout.pxToPt(10);\n  const gap \u003d (milestones.length \u003e 1) ? (rightX - leftX) / (milestones.length - 1) : 0;\n  const cardW_pt \u003d layout.pxToPt(180);\n  const vOffset \u003d layout.pxToPt(40);\n  const headerHeight \u003d layout.pxToPt(28);\n  const bodyHeight \u003d layout.pxToPt(80);\n  const cardPadding \u003d layout.pxToPt(8);\n  milestones.forEach((m, i) \u003d\u003e {\n    const x \u003d leftX + gap * i;\n    const isAbove \u003d i % 2 \u003d\u003d\u003d 0;\n    const dateText \u003d String(m.date || \u0027\u0027);\n    const labelText \u003d String(m.label || \u0027\u0027);\n    const cardH_pt \u003d headerHeight + bodyHeight;\n    const cardLeft \u003d x - (cardW_pt / 2);\n    const cardTop \u003d isAbove ? (baseY - vOffset - cardH_pt) : (baseY + vOffset);\n    const timelineColors \u003d generateTimelineCardColors(settings.primaryColor, milestones.length);\n    const headerShape \u003d slide.insertShape(SlidesApp.ShapeType.RECTANGLE, cardLeft, cardTop, cardW_pt, headerHeight);\n    headerShape.getFill().setSolidFill(timelineColors[i]);\n    headerShape.getBorder().getLineFill().setSolidFill(timelineColors[i]);\n    const bodyShape \u003d slide.insertShape(SlidesApp.ShapeType.RECTANGLE, cardLeft, cardTop + headerHeight, cardW_pt, bodyHeight);\n    bodyShape.getFill().setSolidFill(CONFIG.COLORS.background_gray);\n    bodyShape.getBorder().getLineFill().setSolidFill(CONFIG.COLORS.card_border);\n    const connectorY_start \u003d isAbove ? (cardTop + cardH_pt) : baseY;\n    const connectorY_end \u003d isAbove ? baseY : cardTop;\n    const connector \u003d slide.insertLine(SlidesApp.LineCategory.STRAIGHT, x, connectorY_start, x, connectorY_end);\n    connector.getLineFill().setSolidFill(CONFIG.COLORS.neutral_gray);\n    connector.setWeight(1);\n    const dot \u003d slide.insertShape(SlidesApp.ShapeType.ELLIPSE, x - dotR / 2, baseY - dotR / 2, dotR, dotR);\n    dot.getFill().setSolidFill(timelineColors[i]);\n    dot.getBorder().setTransparent();\n    const headerTextShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, \n      cardLeft, cardTop, \n      cardW_pt, headerHeight);\n    setStyledText(headerTextShape, dateText, {\n      size: CONFIG.FONTS.sizes.body,\n      bold: true,\n      color: CONFIG.COLORS.background_gray,\n      align: SlidesApp.ParagraphAlignment.CENTER\n    });\n    setParenthesizedTextSize(headerTextShape, 8);\n    try {\n      headerTextShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n    } catch (e) {}\n    let bodyFontSize \u003d CONFIG.FONTS.sizes.body;\n    const textLength \u003d labelText.length;\n    if (textLength \u003e 40) bodyFontSize \u003d 10;\n    else if (textLength \u003e 30) bodyFontSize \u003d 11;\n    else if (textLength \u003e 20) bodyFontSize \u003d 12;\n    const bodyTextShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, \n      cardLeft, cardTop + headerHeight, \n      cardW_pt, bodyHeight);\n    setStyledText(bodyTextShape, labelText, {\n      size: bodyFontSize,\n      align: SlidesApp.ParagraphAlignment.CENTER\n    });\n    try {\n      bodyTextShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n    } catch (e) {}\n  });\n  drawBottomBarAndFooter(slide, layout, pageNum, settings);\n}\nfunction createDiagramSlide(slide, data, layout, pageNum, settings, imageUpdateOption \u003d \u0027update\u0027) {\n  setMainSlideBackground(slide, layout);\n  const titleWidthPt \u003d (data \u0026\u0026 typeof data._title_widthPt \u003d\u003d\u003d \u0027number\u0027) ? data._title_widthPt : null;\n  drawStandardTitleHeader(slide, layout, \u0027diagramSlide\u0027, data.title, settings, titleWidthPt, imageUpdateOption);\n  const subheadWidthPt \u003d (data \u0026\u0026 typeof data._subhead_widthPt \u003d\u003d\u003d \u0027number\u0027) ?\n  data._subhead_widthPt : null;\n  const dy \u003d drawSubheadIfAny(slide, layout, \u0027diagramSlide\u0027, data.subhead, subheadWidthPt); \n  const lanes \u003d Array.isArray(data.lanes) ? data.lanes : [];\n  const baseArea \u003d layout.getRect(\u0027diagramSlide.lanesArea\u0027);\n  const adjustedArea \u003d adjustAreaForSubhead(baseArea, data.subhead, layout);\n  const area \u003d offsetRect(adjustedArea, 0, dy);\n  const px \u003d (p) \u003d\u003e layout.pxToPt(p);\n  const {\n    laneGap_px,\n    lanePad_px,\n    laneTitle_h_px,\n    cardGap_px,\n    cardMin_h_px,\n    cardMax_h_px,\n    arrow_h_px,\n    arrowGap_px\n  } \u003d CONFIG.DIAGRAM;\n  const n \u003d Math.max(1, lanes.length);\n  const laneW \u003d (area.width - px(laneGap_px) * (n - 1)) / n;\n  const cardBoxes \u003d [];\n  for (let j \u003d 0; j \u003c n; j++) {\n    const lane \u003d lanes[j] || {\n      title: \u0027\u0027,\n      items: []\n    };\n    const left \u003d area.left + j * (laneW + px(laneGap_px));\n    const lt \u003d slide.insertShape(SlidesApp.ShapeType.RECTANGLE, left, area.top, laneW, px(laneTitle_h_px));\n    lt.getFill().setSolidFill(settings.primaryColor);\n    lt.getBorder().getLineFill().setSolidFill(settings.primaryColor);\n    setStyledText(lt, lane.title || \u0027\u0027, {\n      size: CONFIG.FONTS.sizes.laneTitle,\n      bold: true,\n      color: CONFIG.COLORS.background_gray,\n      align: SlidesApp.ParagraphAlignment.CENTER\n    });\n    try {\n      lt.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n    } catch (e) {}\n    const laneBodyTop \u003d area.top + px(laneTitle_h_px),\n      laneBodyHeight \u003d area.height - px(laneTitle_h_px);\n    const laneBg \u003d slide.insertShape(SlidesApp.ShapeType.RECTANGLE, left, laneBodyTop, laneW, laneBodyHeight);\n    laneBg.getFill().setSolidFill(CONFIG.COLORS.background_gray);\n    laneBg.getBorder().getLineFill().setSolidFill(CONFIG.COLORS.lane_border);\n    const items \u003d Array.isArray(lane.items) ? lane.items : [];\n    const availH \u003d laneBodyHeight - px(lanePad_px) * 2,\n      rows \u003d Math.max(1, items.length);\n    const idealH \u003d (availH - px(cardGap_px) * (rows - 1)) / rows;\n    const cardH \u003d Math.max(px(cardMin_h_px), Math.min(px(cardMax_h_px), idealH));\n    const firstTop \u003d laneBodyTop + px(lanePad_px) + Math.max(0, (availH - (cardH * rows + px(cardGap_px) * (rows - 1))) / 2);\n    cardBoxes[j] \u003d [];\n    for (let i \u003d 0; i \u003c rows; i++) {\n      const cardTop \u003d firstTop + i * (cardH + px(cardGap_px));\n      const card \u003d slide.insertShape(SlidesApp.ShapeType.ROUND_RECTANGLE, left + px(lanePad_px), cardTop, laneW - px(lanePad_px) * 2, cardH);\n      card.getFill().setSolidFill(CONFIG.COLORS.background_gray);\n      card.getBorder().getLineFill().setSolidFill(CONFIG.COLORS.card_border);\n      setStyledText(card, items[i] || \u0027\u0027, {\n        size: CONFIG.FONTS.sizes.body\n      });\n      try {\n        card.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n      } catch (e) {}\n      cardBoxes[j][i] \u003d {\n        left: left + px(lanePad_px),\n        top: cardTop,\n        width: laneW - px(lanePad_px) * 2,\n        height: cardH\n      };\n    }\n  }\n  const maxRows \u003d Math.max(0, ...cardBoxes.map(a \u003d\u003e a ? a.length : 0));\n  for (let j \u003d 0; j \u003c n - 1; j++) {\n    for (let i \u003d 0; i \u003c maxRows; i++) {\n      if (cardBoxes[j] \u0026\u0026 cardBoxes[j][i] \u0026\u0026 cardBoxes[j + 1] \u0026\u0026 cardBoxes[j + 1][i]) {\n        drawArrowBetweenRects(slide, cardBoxes[j][i], cardBoxes[j + 1][i], px(arrow_h_px), px(arrowGap_px), settings);\n      }\n    }\n  }\n  drawBottomBarAndFooter(slide, layout, pageNum, settings);\n}\nfunction createCycleSlide(slide, data, layout, pageNum, settings, imageUpdateOption \u003d \u0027update\u0027) {\n  setMainSlideBackground(slide, layout);\n  const titleWidthPt \u003d (data \u0026\u0026 typeof data._title_widthPt \u003d\u003d\u003d \u0027number\u0027) ? data._title_widthPt : null;\n  drawStandardTitleHeader(slide, layout, \u0027contentSlide\u0027, data.title, settings, titleWidthPt, imageUpdateOption);\n  const subheadWidthPt \u003d (data \u0026\u0026 typeof data._subhead_widthPt \u003d\u003d\u003d \u0027number\u0027) ?\n  data._subhead_widthPt : null;\n  const dy \u003d drawSubheadIfAny(slide, layout, \u0027contentSlide\u0027, data.subhead, subheadWidthPt); \n  const area \u003d offsetRect(layout.getRect(\u0027contentSlide.body\u0027), 0, dy);\n  const items \u003d Array.isArray(data.items) \u0026\u0026 data.items.length \u003d\u003d\u003d 4 ? data.items : [];\n  if (items.length \u003d\u003d\u003d 0) {\n    drawBottomBarAndFooter(slide, layout, pageNum, settings);\n    return;\n  }\n  const textLengths \u003d items.map(item \u003d\u003e {\n    const labelLength \u003d (item.label || \u0027\u0027).length;\n    const subLabelLength \u003d (item.subLabel || \u0027\u0027).length;\n    return labelLength + subLabelLength;\n  });\n  const maxLength \u003d Math.max(...textLengths);\n  const avgLength \u003d textLengths.reduce((sum, len) \u003d\u003e sum + len, 0) / textLengths.length;\n  const centerX \u003d area.left + area.width / 2;\n  const centerY \u003d area.top + area.height / 2;\n  const radiusX \u003d area.width / 3.2;\n  const radiusY \u003d area.height / 2.6;\n  const maxCardW \u003d Math.min(layout.pxToPt(220), radiusX * 0.8);\n  const maxCardH \u003d Math.min(layout.pxToPt(100), radiusY * 0.6);\n  let cardW, cardH, fontSize;\n  if (maxLength \u003e 25 || avgLength \u003e 18) {\n    cardW \u003d Math.min(layout.pxToPt(230), maxCardW);\n    cardH \u003d Math.min(layout.pxToPt(105), maxCardH);\n    fontSize \u003d 13;\n  } else if (maxLength \u003e 15 || avgLength \u003e 10) {\n    cardW \u003d Math.min(layout.pxToPt(215), maxCardW);\n    cardH \u003d Math.min(layout.pxToPt(95), maxCardH);\n    fontSize \u003d 14;\n  } else {\n    cardW \u003d layout.pxToPt(200);\n    cardH \u003d layout.pxToPt(90);\n    fontSize \u003d 16;\n  }\n  if (data.centerText) {\n    const centerTextBox \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, centerX - layout.pxToPt(100), centerY - layout.pxToPt(50), layout.pxToPt(200), layout.pxToPt(100));\n    setStyledText(centerTextBox, data.centerText, { size: 20, bold: true, align: SlidesApp.ParagraphAlignment.CENTER, color: CONFIG.COLORS.text_primary });\n    try { centerTextBox.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE); } catch (e) {}\n  }\n  const positions \u003d [\n    { x: centerX + radiusX, y: centerY },\n    { x: centerX, y: centerY + radiusY },\n    { x: centerX - radiusX, y: centerY },\n    { x: centerX, y: centerY - radiusY }\n  ];\n  positions.forEach((pos, i) \u003d\u003e {\n    const cardX \u003d pos.x - cardW / 2;\n    const cardY \u003d pos.y - cardH / 2;\n    const card \u003d slide.insertShape(SlidesApp.ShapeType.ROUND_RECTANGLE, cardX, cardY, cardW, cardH);\n    card.getFill().setSolidFill(settings.primaryColor);\n    card.getBorder().setTransparent();\n    const item \u003d items[i] || {};\n    const subLabelText \u003d item.subLabel || `${i + 1}番目`;\n    const labelText \u003d item.label || \u0027\u0027;\n    setStyledText(card, `${subLabelText}\\n${labelText}`, { size: fontSize, bold: true, color: CONFIG.COLORS.background_gray, align: SlidesApp.ParagraphAlignment.CENTER });\n    try {\n      card.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n      const textRange \u003d card.getText();\n      const subLabelEnd \u003d subLabelText.length;\n      if (textRange.asString().length \u003e subLabelEnd) {\n        textRange.getRange(0, subLabelEnd).getTextStyle().setFontSize(Math.max(10, fontSize - 2));\n      }\n    } catch (e) {}\n  });\n  const arrowRadiusX \u003d radiusX * 0.75;\n  const arrowRadiusY \u003d radiusY * 0.80;\n  const arrowSize \u003d layout.pxToPt(80);\n  const arrowPositions \u003d [\n    { left: centerX + arrowRadiusX, top: centerY - arrowRadiusY, rotation: 90 },\n    { left: centerX + arrowRadiusX, top: centerY + arrowRadiusY, rotation: 180 },\n    { left: centerX - arrowRadiusX, top: centerY + arrowRadiusY, rotation: 270 },\n    { left: centerX - arrowRadiusX, top: centerY - arrowRadiusY, rotation: 0 }\n  ];\n  arrowPositions.forEach(pos \u003d\u003e {\n    const arrow \u003d slide.insertShape(SlidesApp.ShapeType.BENT_ARROW, pos.left - arrowSize / 2, pos.top - arrowSize / 2, arrowSize, arrowSize);\n    arrow.getFill().setSolidFill(CONFIG.COLORS.ghost_gray);\n    arrow.getBorder().setTransparent();\n    arrow.setRotation(pos.rotation);\n  });\n  drawBottomBarAndFooter(slide, layout, pageNum, settings);\n}\nfunction createCardsSlide(slide, data, layout, pageNum, settings, imageUpdateOption \u003d \u0027update\u0027) {\n  setMainSlideBackground(slide, layout, imageUpdateOption);\n  drawStandardTitleHeader(slide, layout, \u0027cardsSlide\u0027, data.title, settings, imageUpdateOption);\n  const subheadWidthPt \u003d (data \u0026\u0026 typeof data._subhead_widthPt \u003d\u003d\u003d \u0027number\u0027) ?\n data._subhead_widthPt : null;\n  const dy \u003d drawSubheadIfAny(slide, layout, \u0027cardsSlide\u0027, data.subhead, subheadWidthPt); \n  const baseArea \u003d layout.getRect(\u0027cardsSlide.gridArea\u0027);\n  const adjustedArea \u003d adjustAreaForSubhead(baseArea, data.subhead, layout);\n  const area \u003d offsetRect(adjustedArea, 0, dy);\n  const items \u003d Array.isArray(data.items) ? data.items : [];\n  const cols \u003d Math.min(3, Math.max(2, Number(data.columns) || (items.length \u003c\u003d 4 ? 2 : 3)));\n  const gap \u003d layout.pxToPt(16),\n    rows \u003d Math.ceil(items.length / cols);\n  const cardW \u003d (area.width - gap * (cols - 1)) / cols,\n    cardH \u003d Math.max(layout.pxToPt(92), (area.height - gap * (rows - 1)) / rows);\n  for (let idx \u003d 0; idx \u003c items.length; idx++) {\n    const r \u003d Math.floor(idx / cols),\n      c \u003d idx % cols;\n    const card \u003d slide.insertShape(SlidesApp.ShapeType.ROUND_RECTANGLE, area.left + c * (cardW + gap), area.top + r * (cardH + gap), cardW, cardH);\n    card.getFill().setSolidFill(CONFIG.COLORS.background_gray);\n    card.getBorder().getLineFill().setSolidFill(CONFIG.COLORS.card_border);\n    const obj \u003d items[idx];\n    if (typeof obj \u003d\u003d\u003d \u0027string\u0027) {\n      setStyledText(card, obj, {\n        size: CONFIG.FONTS.sizes.body\n      });\n    } else {\n      const title \u003d String(obj.title || \u0027\u0027),\n        desc \u003d String(obj.desc || \u0027\u0027);\n      if (title \u0026\u0026 desc) {\n        const combined \u003d `${title}\\n\\n${desc}`;\n        setStyledText(card, combined, {\n          size: CONFIG.FONTS.sizes.body\n        });\n        try {\n          card.getText().getRange(0, title.length).getTextStyle().setBold(true);\n        } catch (e) {}\n      } else if (title) {\n        setStyledText(card, title, {\n          size: CONFIG.FONTS.sizes.body,\n          bold: true\n        });\n      } else {\n        setStyledText(card, desc, {\n          size: CONFIG.FONTS.sizes.body\n        });\n      }\n    }\n    try {\n      card.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n    } catch (e) {}\n  }\n  drawBottomBarAndFooter(slide, layout, pageNum, settings);\n}\nfunction createHeaderCardsSlide(slide, data, layout, pageNum, settings, imageUpdateOption \u003d \u0027update\u0027) {\n  setMainSlideBackground(slide, layout);\n  const titleWidthPt \u003d (data \u0026\u0026 typeof data._title_widthPt \u003d\u003d\u003d \u0027number\u0027) ? data._title_widthPt : null;\n  drawStandardTitleHeader(slide, layout, \u0027cardsSlide\u0027, data.title, settings, titleWidthPt, imageUpdateOption);\n  const subheadWidthPt \u003d (data \u0026\u0026 typeof data._subhead_widthPt \u003d\u003d\u003d \u0027number\u0027) ?\n  data._subhead_widthPt : null;\n  const dy \u003d drawSubheadIfAny(slide, layout, \u0027cardsSlide\u0027, data.subhead, subheadWidthPt); \n  const baseArea \u003d layout.getRect(\u0027cardsSlide.gridArea\u0027);\n  const adjustedArea \u003d adjustAreaForSubhead(baseArea, data.subhead, layout);\n  const area \u003d offsetRect(adjustedArea, 0, dy);\n  const items \u003d Array.isArray(data.items) ? data.items : [];\n  const cols \u003d Math.min(3, Math.max(2, Number(data.columns) || (items.length \u003c\u003d 4 ? 2 : 3)));\n  const gap \u003d layout.pxToPt(16),\n    rows \u003d Math.ceil(items.length / cols);\n  const cardW \u003d (area.width - gap * (cols - 1)) / cols,\n    cardH \u003d Math.max(layout.pxToPt(92), (area.height - gap * (rows - 1)) / rows);\n  for (let idx \u003d 0; idx \u003c items.length; idx++) {\n    const r \u003d Math.floor(idx / cols),\n      c \u003d idx % cols;\n    const left \u003d area.left + c * (cardW + gap),\n      top \u003d area.top + r * (cardH + gap);\n    const titleText \u003d String(items[idx].title || \u0027\u0027),\n      descText \u003d String(items[idx].desc || \u0027\u0027);\n    const headerHeight \u003d layout.pxToPt(40);\n    const bodyShape \u003d slide.insertShape(SlidesApp.ShapeType.RECTANGLE, left, top + headerHeight, cardW, cardH - headerHeight);\n    bodyShape.getFill().setSolidFill(CONFIG.COLORS.background_gray);\n    bodyShape.getBorder().getLineFill().setSolidFill(CONFIG.COLORS.card_border);\n    const headerShape \u003d slide.insertShape(SlidesApp.ShapeType.RECTANGLE, left, top, cardW, headerHeight);\n    headerShape.getFill().setSolidFill(settings.primaryColor);\n    headerShape.getBorder().getLineFill().setSolidFill(settings.primaryColor);\n    const headerTextShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, left, top, cardW, headerHeight);\n    setStyledText(headerTextShape, titleText, {\n      size: CONFIG.FONTS.sizes.body,\n      bold: true,\n      color: CONFIG.COLORS.background_gray,\n      align: SlidesApp.ParagraphAlignment.CENTER\n    });\n    try {\n      headerTextShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n    } catch (e) {}\n    const bodyTextShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, left + layout.pxToPt(12), top + headerHeight, cardW - layout.pxToPt(24), cardH - headerHeight);\n    setStyledText(bodyTextShape, descText, {\n      size: CONFIG.FONTS.sizes.body,\n      align: SlidesApp.ParagraphAlignment.CENTER\n    });\n    try {\n      setBoldTextSize(bodyTextShape, 16);\n    } catch (e) {\n    }\n    try {\n      bodyTextShape.getText().getParagraphStyle().setLineSpacing(115);\n    } catch (e) {\n    }\n    try {\n      bodyTextShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n    } catch (e) {}\n    try {\n      const adjustmentLog \u003d adjustShapeText_External(bodyTextShape, null);\n    } catch(e) {\n    }\n  }\n  drawBottomBarAndFooter(slide, layout, pageNum, settings);\n}\nfunction createTableSlide(slide, data, layout, pageNum, settings, imageUpdateOption \u003d \u0027update\u0027) {\n  setMainSlideBackground(slide, layout);\n  const titleWidthPt \u003d (data \u0026\u0026 typeof data._title_widthPt \u003d\u003d\u003d \u0027number\u0027) ? data._title_widthPt : null;\n  drawStandardTitleHeader(slide, layout, \u0027tableSlide\u0027, data.title, settings, titleWidthPt, imageUpdateOption);\n  const subheadWidthPt \u003d (data \u0026\u0026 typeof data._subhead_widthPt \u003d\u003d\u003d \u0027number\u0027) ?\n  data._subhead_widthPt : null;\n  const dy \u003d drawSubheadIfAny(slide, layout, \u0027tableSlide\u0027, data.subhead, subheadWidthPt);\n  const baseArea \u003d layout.getRect(\u0027tableSlide.area\u0027);\n  const adjustedArea \u003d adjustAreaForSubhead(baseArea, data.subhead, layout);\n  const area \u003d offsetRect(adjustedArea, 0, dy);\n  const headers \u003d Array.isArray(data.headers) ? data.headers : [];\n  const rows \u003d Array.isArray(data.rows) ?\n  data.rows : [];\n  try {\n    if (headers.length \u003e 0) {\n      const numRowsTotal \u003d rows.length + 1;\n      const table \u003d slide.insertTable(numRowsTotal, headers.length, area.left, area.top, area.width, area.height);\n      const estimatedRowHeight \u003d area.height / numRowsTotal;\n      for (let c \u003d 0; c \u003c headers.length; c++) {\n        const cell \u003d table.getCell(0, c);\n        const cellWidth \u003d table.getColumn(c).getWidth();\n        cell.getFill().setSolidFill(CONFIG.COLORS.table_header_bg);\n        setStyledText(cell, String(headers[c] || \u0027\u0027), {\n          bold: true,\n          color: CONFIG.COLORS.text_small_font,\n          align: SlidesApp.ParagraphAlignment.CENTER\n        });\n        try {\n          cell.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n        } catch (e) {}\n        try {\n          adjustShapeText_External(cell, null, cellWidth, estimatedRowHeight);\n        } catch (adjustError) {\n        }\n      }\n      for (let r \u003d 0; r \u003c rows.length; r++) {\n        for (let c \u003d 0; c \u003c headers.length; c++) {\n          const cell \u003d table.getCell(r + 1, c);\n          const cellWidth \u003d table.getColumn(c).getWidth();\n          cell.getFill().setSolidFill(CONFIG.COLORS.background_gray);\n          setStyledText(cell, String((rows[r] || [])[c] || \u0027\u0027), {\n            align: SlidesApp.ParagraphAlignment.CENTER\n          });\n          try {\n            cell.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n          } catch (e) {}\n          try {\n            adjustShapeText_External(cell, null, cellWidth, estimatedRowHeight);\n          } catch (adjustError) {\n          }\n        }\n      }\n    }\n  } catch (e) {\n  }\n  drawBottomBarAndFooter(slide, layout, pageNum, settings);\n}\nfunction createProgressSlide(slide, data, layout, pageNum, settings, imageUpdateOption \u003d \u0027update\u0027) {\n  setMainSlideBackground(slide, layout);\n  const titleWidthPt \u003d (data \u0026\u0026 typeof data._title_widthPt \u003d\u003d\u003d \u0027number\u0027) ? data._title_widthPt : null;\n  drawStandardTitleHeader(slide, layout, \u0027progressSlide\u0027, data.title, settings, titleWidthPt, imageUpdateOption);\n  const subheadWidthPt \u003d (data \u0026\u0026 typeof data._subhead_widthPt \u003d\u003d\u003d \u0027number\u0027) ?\n  data._subhead_widthPt : null;\n  const dy \u003d drawSubheadIfAny(slide, layout, \u0027progressSlide\u0027, data.subhead, subheadWidthPt); \n  const baseArea \u003d layout.getRect(\u0027progressSlide.area\u0027);\n  const adjustedArea \u003d adjustAreaForSubhead(baseArea, data.subhead, layout);\n  const area \u003d offsetRect(adjustedArea, 0, dy);\n  const items \u003d Array.isArray(data.items) ? data.items.slice(0, 4) : [];\n  const n \u003d Math.max(1, items.length);\n  const cardGap \u003d layout.pxToPt(12);\n  const cardHeight \u003d Math.max(layout.pxToPt(50), (area.height - cardGap * (n - 1)) / n);\n  const cardPadding \u003d layout.pxToPt(15);\n  const barHeight \u003d layout.pxToPt(12);\n  const percentHeight \u003d layout.pxToPt(30);\n  const percentWidth \u003d layout.pxToPt(120);\n  for (let i \u003d 0; i \u003c n; i++) {\n    const cardTop \u003d area.top + i * (cardHeight + cardGap);\n    const p \u003d Math.max(0, Math.min(100, Number(items[i].percent || 0)));\n    const card \u003d slide.insertShape(SlidesApp.ShapeType.ROUND_RECTANGLE, \n      area.left, cardTop, area.width, cardHeight);\n    card.getFill().setSolidFill(CONFIG.COLORS.background_gray);\n    card.getBorder().getLineFill().setSolidFill(CONFIG.COLORS.card_border);\n    const labelHeight \u003d layout.pxToPt(20);\n    const labelWidth \u003d area.width - percentWidth - cardPadding * 3;\n    const label \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, \n      area.left + cardPadding, cardTop + cardPadding, \n      labelWidth, labelHeight);\n    setStyledText(label, String(items[i].label || \u0027\u0027), {\n      size: CONFIG.FONTS.sizes.body,\n      bold: true,\n      align: SlidesApp.ParagraphAlignment.LEFT\n    });\n    try {\n    label.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n  } catch (e) {}\n    const pct \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, \n      area.left + area.width - percentWidth - cardPadding, \n      cardTop + cardPadding - layout.pxToPt(2), \n      percentWidth, percentHeight);\n    setStyledText(pct, `${p}%`, {\n      size: 20,\n      bold: true,\n      color: settings.primaryColor,\n      align: SlidesApp.ParagraphAlignment.RIGHT\n    });\n    try {\n    pct.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n  } catch (e) {}\n    const barTop \u003d cardTop + cardHeight - cardPadding - barHeight;\n    const barWidth \u003d area.width - cardPadding * 2;\n    const barBG \u003d slide.insertShape(SlidesApp.ShapeType.ROUND_RECTANGLE, \n      area.left + cardPadding, barTop, barWidth, barHeight);\n    barBG.getFill().setSolidFill(CONFIG.COLORS.faint_gray);\n    barBG.getBorder().setTransparent();\n    if (p \u003e 0) {\n      const filledBarWidth \u003d Math.max(layout.pxToPt(6), barWidth * (p / 100));\n      const barFG \u003d slide.insertShape(SlidesApp.ShapeType.ROUND_RECTANGLE, \n        area.left + cardPadding, barTop, filledBarWidth, barHeight);\n      barFG.getFill().setSolidFill(settings.primaryColor);\n      barFG.getBorder().setTransparent();\n    }\n  }\n  drawBottomBarAndFooter(slide, layout, pageNum, settings);\n}\nfunction createQuoteSlide(slide, data, layout, pageNum, settings, imageUpdateOption \u003d \u0027update\u0027) {\n  setMainSlideBackground(slide, layout);\n  const titleWidthPt \u003d (data \u0026\u0026 typeof data._title_widthPt \u003d\u003d\u003d \u0027number\u0027) ? data._title_widthPt : null;\n  drawStandardTitleHeader(slide, layout, \u0027quoteSlide\u0027, data.title || \u0027引用\u0027, settings, titleWidthPt, imageUpdateOption);\n  const subheadWidthPt \u003d (data \u0026\u0026 typeof data._subhead_widthPt \u003d\u003d\u003d \u0027number\u0027) ?\n  data._subhead_widthPt : null;\n  const dy \u003d drawSubheadIfAny(slide, layout, \u0027quoteSlide\u0027, data.subhead, subheadWidthPt); \n  const baseTop \u003d 120;\n  const subheadHeight \u003d data.subhead ? layout.pxToPt(40) : 0;\n  const margin \u003d layout.pxToPt(10);\n  const area \u003d offsetRect(layout.getRect({\n    left: 40,\n    top: baseTop + subheadHeight + margin,\n    width: 880,\n    height: 320 - subheadHeight - margin\n  }), 0, dy);\n  const bgCard \u003d slide.insertShape(SlidesApp.ShapeType.ROUND_RECTANGLE, area.left, area.top, area.width, area.height);\n  bgCard.getFill().setSolidFill(CONFIG.COLORS.background_white);\n  const border \u003d bgCard.getBorder();\n  border.getLineFill().setSolidFill(CONFIG.COLORS.card_border);\n  border.setWeight(2);\n  const padding \u003d layout.pxToPt(40);\n  const textLeft \u003d area.left + padding,\n    textTop \u003d area.top + padding;\n  const textWidth \u003d area.width - (padding * 2),\n    textHeight \u003d area.height - (padding * 2);\n  const quoteTextHeight \u003d textHeight - layout.pxToPt(30);\n  const textShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, textLeft, textTop, textWidth, quoteTextHeight);\n  setStyledText(textShape, data.text || \u0027\u0027, {\n    size: 24,\n    align: SlidesApp.ParagraphAlignment.CENTER,\n    //color: CONFIG.COLORS.text_primary\n    fontType: \u0027large\u0027\n  });\n  try {\n    textShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n  } catch (e) {}\n  const authorTop \u003d textTop + quoteTextHeight;\n  const authorShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, textLeft, authorTop, textWidth, layout.pxToPt(30));\n  setStyledText(authorShape, `— ${data.author || \u0027\u0027}`, {\n    size: 16,\n    color: CONFIG.COLORS.neutral_gray,\n    align: SlidesApp.ParagraphAlignment.END\n  });\n  try {\n    authorShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n  } catch (e) {}\n  drawBottomBarAndFooter(slide, layout, pageNum, settings);\n}\nfunction createKpiSlide(slide, data, layout, pageNum, settings, imageUpdateOption) {\n  setMainSlideBackground(slide, layout);\n  const titleWidthPt \u003d (data \u0026\u0026 typeof data._title_widthPt \u003d\u003d\u003d \u0027number\u0027) ? data._title_widthPt : null;\n  drawStandardTitleHeader(slide, layout, \u0027kpiSlide\u0027, data.title || \u0027主要指標\u0027, settings, titleWidthPt, imageUpdateOption);\n  const subheadWidthPt \u003d (data \u0026\u0026 typeof data._subhead_widthPt \u003d\u003d\u003d \u0027number\u0027) ? data._subhead_widthPt : null;\n  const dy \u003d drawSubheadIfAny(slide, layout, \u0027kpiSlide\u0027, data.subhead, subheadWidthPt);\n  const items \u003d (Array.isArray(data.items) ? data.items.slice(0, 8) : []);\n  const n \u003d items.length;\n  if (n \u003d\u003d\u003d 0) {\n    drawBottomBarAndFooter(slide, layout, pageNum, settings);\n    return;\n  }\n  const gap \u003d layout.pxToPt(16);\n  const pad \u003d layout.pxToPt(15);\n  const originalCardH_pt \u003d layout.pxToPt(240);\n  if (n \u003c\u003d 4) {\n    const baseArea \u003d layout.getRect(\u0027kpiSlide.gridArea\u0027);\nconst adjustedArea \u003d adjustAreaForSubhead(baseArea, data.subhead, layout);\n    let finalDy \u003d dy;\n    if (dy \u003d\u003d\u003d 0) {\n        finalDy \u003d layout.pxToPt(36); \n    }\n    const area \u003d offsetRect(adjustedArea, 0, finalDy);\n    const cols \u003d n;\n    const cardW \u003d (area.width - gap * (cols - 1)) / cols;\n    const cardH \u003d originalCardH_pt;\n    for (let idx \u003d 0; idx \u003c n; idx++) {\n      const left \u003d area.left + idx * (cardW + gap);\n      const top \u003d area.top;\n      drawKpiCard(slide, layout, items[idx], left, top, cardW, cardH, pad, 1.0);\n    }\n  } else {\n    const baseArea \u003d layout.getRect(\u0027kpiSlide.gridArea\u0027);\n    const adjustedArea \u003d adjustAreaForSubhead(baseArea, data.subhead, layout);\n    const area \u003d offsetRect(adjustedArea, 0, 0); \n    const rows \u003d 2;\n    const cols \u003d (n \u003c\u003d 6) ? 3 : 4; \n    const cardW \u003d (area.width - gap * (cols - 1)) / cols;\n    const cardH \u003d (area.height - gap * (rows - 1)) / rows;\n    const scaleY \u003d cardH / originalCardH_pt; \n    for (let idx \u003d 0; idx \u003c n; idx++) {\n      const c \u003d idx % cols;\n      const r \u003d Math.floor(idx / cols);\n      const left \u003d area.left + c * (cardW + gap);\n      const top \u003d area.top + r * (cardH + gap);\n      drawKpiCard(slide, layout, items[idx], left, top, cardW, cardH, pad, scaleY);\n    }\n  }\n  drawBottomBarAndFooter(slide, layout, pageNum, settings);\n}\nfunction drawKpiCard(slide, layout, item, left, top, cardW, cardH, pad, scaleY) {\n  const card \u003d slide.insertShape(SlidesApp.ShapeType.RECTANGLE, left, top, cardW, cardH);\n  card.getFill().setSolidFill(CONFIG.COLORS.background_gray);\n  card.getBorder().getLineFill().setSolidFill(CONFIG.COLORS.card_border);\n  const extraWidthPt \u003d layout.pxToPt(30);\n  const labelLeft \u003d (left + pad) - (extraWidthPt / 2);\n  const labelWidth \u003d (cardW - pad * 2) + extraWidthPt;\n  const labelTop \u003d top + layout.pxToPt(25) * scaleY;\n  const labelHeight \u003d layout.pxToPt(35) * scaleY;\n  const labelShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, labelLeft, labelTop, labelWidth, labelHeight);\n  setStyledText(labelShape, item.label || \u0027KPI\u0027, {\n    size: 14,\n    color: CONFIG.COLORS.neutral_gray,\n    align: SlidesApp.ParagraphAlignment.CENTER\n  });\n  try {\n    labelShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n  } catch (e) {\n  }\n  try {\n    const adjustmentResult \u003d adjustShapeText_External(labelShape, null);\n  } catch(e) {\n  }\n  const valueLeft \u003d left + pad;\n  const valueWidth \u003d cardW - pad * 2;\n  const valueTop \u003d top + layout.pxToPt(80) * scaleY;\n  const valueHeight \u003d layout.pxToPt(80) * scaleY;\n  const valueShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, valueLeft, valueTop, valueWidth, valueHeight);\n  const valueText \u003d item.value || \u00270\u0027;\n  const textRange \u003d valueShape.getText().setText(valueText);\n  applyTextStyle(textRange, { size: 32, bold: true, align: SlidesApp.ParagraphAlignment.CENTER });\n  const largeChars \u003d \u00270123456789+-.,:\u0027;\n  const smallerSize \u003d 16;\n  let containsNumericOrSymbol \u003d false;\n  for (let i \u003d 0; i \u003c valueText.length; i++) {\n    if (largeChars.includes(valueText[i])) {\n      containsNumericOrSymbol \u003d true;\n      break;\n    }\n  }\n  if (containsNumericOrSymbol) {\n    try {\n      for (let i \u003d 0; i \u003c valueText.length; i++) {\n        const char \u003d valueText[i];\n        if (!largeChars.includes(char)) {\n          const charRange \u003d textRange.getRange(i, i + 1);\n          charRange.getTextStyle().setFontSize(smallerSize);\n        }\n      }\n    } catch (e) {  }\n  }\n  try { valueShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE); } catch (e) {}\n  try {\n    const adjustmentResult \u003d adjustShapeText_External(valueShape, null);\n    const textRange \u003d valueShape.getText();\n    const valueText \u003d textRange.asString();\n    const containsSpecificChars \u003d /[0-9+-]/.test(valueText);\n    if (containsSpecificChars) {\n      const currentStyle \u003d textRange.getTextStyle();\n      if (currentStyle \u0026\u0026 currentStyle.getFontSize() !\u003d\u003d 32) {\n        currentStyle.setFontSize(32);\n        try {\n          for (let i \u003d 0; i \u003c valueText.length; i++) {\n            const char \u003d valueText[i];\n            if (!largeChars.includes(char)) {\n              const charRange \u003d textRange.getRange(i, i + 1);\n              charRange.getTextStyle().setFontSize(smallerSize);\n            }\n          }\n        } catch (e) {  }\n      }\n    } else {\n      const firstRun \u003d textRange.getRuns()[0];\n      if (firstRun) {\n        const currentSize \u003d firstRun.getTextStyle().getFontSize();\n        if (typeof currentSize \u003d\u003d\u003d \u0027number\u0027 \u0026\u0026 currentSize \u003c 16) {\n          textRange.getTextStyle().setFontSize(16);\n        }\n      }\n    }\n  } catch(e) {\n  }\n  const changeLeft \u003d left + pad;\n  const changeWidth \u003d cardW - pad * 2;\n  const changeTop \u003d top + layout.pxToPt(180) * scaleY;\n  const changeHeight \u003d layout.pxToPt(40) * scaleY;\n  const changeShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, changeLeft, changeTop, changeWidth, changeHeight);\n  let changeColor \u003d CONFIG.COLORS.text_primary;\n  if (item.status \u003d\u003d\u003d \u0027bad\u0027) changeColor \u003d \u0027#d93025\u0027;\n  if (item.status \u003d\u003d\u003d \u0027good\u0027) changeColor \u003d \u0027#1e8e3e\u0027;\n  if (item.status \u003d\u003d\u003d \u0027neutral\u0027) changeColor \u003d CONFIG.COLORS.neutral_gray;\n  setStyledText(changeShape, item.change || \u0027\u0027, {\n    size: 14,\n    color: changeColor,\n    bold: true,\n    align: SlidesApp.ParagraphAlignment.END\n  });\n  try {\n    adjustShapeText_External(changeShape, null);\n  } catch(e) {\n  }\n}\nfunction createBulletCardsSlide(slide, data, layout, pageNum, settings, imageUpdateOption \u003d \u0027update\u0027) {\n  setMainSlideBackground(slide, layout);\n  const titleWidthPt \u003d (data \u0026\u0026 typeof data._title_widthPt \u003d\u003d\u003d \u0027number\u0027) ? data._title_widthPt : null;\n  drawStandardTitleHeader(slide, layout, \u0027contentSlide\u0027, data.title, settings, titleWidthPt, imageUpdateOption);\n  const subheadWidthPt \u003d (data \u0026\u0026 typeof data._subhead_widthPt \u003d\u003d\u003d \u0027number\u0027) ?\n  data._subhead_widthPt : null;\n  const dy \u003d drawSubheadIfAny(slide, layout, \u0027contentSlide\u0027, data.subhead, subheadWidthPt); \n  const area \u003d offsetRect(layout.getRect(\u0027contentSlide.body\u0027), 0, dy);\n  const items \u003d Array.isArray(data.items) ? data.items.slice(0, 3) : [];\n  if (items.length \u003d\u003d\u003d 0) {\n    drawBottomBarAndFooter(slide, layout, pageNum, settings);\n    return;\n  }\n  const gap \u003d layout.pxToPt(16);\n  const cardHeight \u003d (area.height - gap * (items.length - 1)) / items.length;\n  for (let i \u003d 0; i \u003c items.length; i++) {\n    const card \u003d slide.insertShape(SlidesApp.ShapeType.RECTANGLE, area.left, area.top + i * (cardHeight + gap), area.width, cardHeight);\n    card.getFill().setSolidFill(CONFIG.COLORS.background_gray);\n    card.getBorder().getLineFill().setSolidFill(CONFIG.COLORS.card_border);\n    const padding \u003d layout.pxToPt(20);\n    const title \u003d String(items[i].title || \u0027\u0027);\n    const desc \u003d String(items[i].desc || \u0027\u0027);\n    if (title \u0026\u0026 desc) {\n      const titleHeight \u003d layout.pxToPt(16 + 4);\n      const titleShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX,\n        area.left + padding - layout.pxToPt(10),\n        area.top + i * (cardHeight + gap) + layout.pxToPt(12),\n        area.width - padding * 2,\n        titleHeight\n      );\n      setStyledText(titleShape, title, {\n        size: 16,\n        bold: true\n      });\n      try {\n        titleShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n      } catch (e) {}\n      const descTop \u003d area.top + i * (cardHeight + gap) + layout.pxToPt(12) + titleHeight + layout.pxToPt(8);\n      const descHeight \u003d cardHeight - layout.pxToPt(12) - titleHeight - layout.pxToPt(8) - layout.pxToPt(12);\n      let baseDescFontSize \u003d CONFIG.FONTS.sizes.body;\n      if (desc.length \u003e 100) {\n        baseDescFontSize \u003d 12;\n      } else if (desc.length \u003e 80) {\n        baseDescFontSize \u003d 13;\n      }\n      const descShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX,\n        area.left + padding,\n        descTop,\n        area.width - padding * 2,\n        descHeight\n      );\n      setStyledText(descShape, desc, {\n        size: baseDescFontSize\n      });\n      setBoldTextSize(descShape, 16);\n      try {\n        descShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n      } catch (e) {}\n    } else {\n      const singleText \u003d title || desc;\n      const isTitleOnly \u003d !!title;\n      const singleFontSize \u003d isTitleOnly ? 16 : CONFIG.FONTS.sizes.body;\n      const singleHeight \u003d layout.pxToPt(singleFontSize + 8);\n      const shape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX,\n        area.left + padding - layout.pxToPt(10),\n        area.top + i * (cardHeight + gap) + (cardHeight - singleHeight) / 2,\n        area.width - padding * 2,\n        singleHeight\n      );\n      setStyledText(shape, singleText, {\n        size: singleFontSize,\n        bold: isTitleOnly\n      });\n      if (!isTitleOnly) {\n        setBoldTextSize(shape, 16);\n      }\n      try {\n        shape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n      } catch (e) {}\n    }\n  }\n  drawBottomBarAndFooter(slide, layout, pageNum, settings);\n}\nfunction createAgendaSlide(slide, data, layout, pageNum, settings, imageUpdateOption \u003d \u0027update\u0027) {\n  setMainSlideBackground(slide, layout, imageUpdateOption);\n  drawStandardTitleHeader(slide, layout, \u0027processSlide\u0027, data.title, settings, imageUpdateOption);\n  const subheadWidthPt \u003d (data \u0026\u0026 typeof data._subhead_widthPt \u003d\u003d\u003d \u0027number\u0027) ?\n  data._subhead_widthPt : null;\n  const dy \u003d drawSubheadIfAny(slide, layout, \u0027processSlide\u0027, data.subhead, subheadWidthPt); \n  let effectiveDy \u003d dy;\n  if (dy \u003e 0) {\n    effectiveDy \u003d dy - layout.pxToPt(20); \n  }\n  const area \u003d offsetRect(layout.getRect(\u0027processSlide.area\u0027), 0, effectiveDy);\n  let items \u003d Array.isArray(data.items) ? data.items : [];\n  if (items.length \u003d\u003d\u003d 0) {\n    items \u003d buildAgendaFromSlideData();\n    if (items.length \u003d\u003d\u003d 0) {\n      items \u003d [\u0027本日の目的\u0027, \u0027進め方\u0027, \u0027次のアクション\u0027];\n    }\n  }\n  const n \u003d Math.max(1, items.length);\n  const topPadding \u003d layout.pxToPt(30);\n  const bottomPadding \u003d layout.pxToPt(10);\n  const drawableHeight \u003d area.height - topPadding - bottomPadding;\n  const maxGapY_pt \u003d layout.pxToPt(60);\n  let idealGapY \u003d Infinity;\n  if (n \u003e 1) {\n    idealGapY \u003d drawableHeight / (n - 1);\n  }\n  const finalGapY \u003d Math.min(idealGapY, maxGapY_pt);\n  const top0 \u003d area.top + topPadding;\n  const cx \u003d area.left + layout.pxToPt(44);\n  for (let i \u003d 0; i \u003c n; i++) {\n    const cy \u003d top0 + finalGapY * i;\n    const sz \u003d layout.pxToPt(28);\n    const numBox \u003d slide.insertShape(SlidesApp.ShapeType.RECTANGLE, cx - sz/2, cy - sz/2, sz, sz);\n    numBox.getFill().setSolidFill(settings.primaryColor);\n    numBox.getBorder().setTransparent();\n    const num \u003d numBox.getText(); \n    num.setText(String(i + 1));\n    applyTextStyle(num, { \n      size: 12, \n      bold: true, \n      color: CONFIG.COLORS.background_gray, \n      align: SlidesApp.ParagraphAlignment.CENTER \n    });\n    let cleanText \u003d String(items[i] || \u0027\u0027);\n    cleanText \u003d cleanText.replace(/^\\s*\\d+(\\.\\s*|\\s+)/, \u0027\u0027);\n    const txt \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, cx + layout.pxToPt(28), cy - layout.pxToPt(16), area.width - layout.pxToPt(70), layout.pxToPt(32));\n    setStyledText(txt, cleanText, {\n      size: CONFIG.FONTS.sizes.processStep,\n      bold: true,                        \n      fontType: \u0027large\u0027\n    });\n    try { \n      txt.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE); \n    } catch(e){}\n  }\n  drawBottomBarAndFooter(slide, layout, pageNum, settings);\n}\nfunction createFaqSlide(slide, data, layout, pageNum, settings, imageUpdateOption \u003d \u0027update\u0027) {\n  setMainSlideBackground(slide, layout);\n  const titleWidthPt \u003d (data \u0026\u0026 typeof data._title_widthPt \u003d\u003d\u003d \u0027number\u0027) ? data._title_widthPt : null;\n  drawStandardTitleHeader(slide, layout, \u0027contentSlide\u0027, data.title || \u0027よくあるご質問\u0027, settings, titleWidthPt, imageUpdateOption);\n  const subheadWidthPt \u003d (data \u0026\u0026 typeof data._subhead_widthPt \u003d\u003d\u003d \u0027number\u0027) ?\n  data._subhead_widthPt : null;\n  const dy \u003d drawSubheadIfAny(slide, layout, \u0027contentSlide\u0027, data.subhead, subheadWidthPt); \n  const area \u003d offsetRect(layout.getRect(\u0027contentSlide.body\u0027), 0, dy);\n  const items \u003d Array.isArray(data.items) ? data.items.slice(0, 4) : [];\n  if (items.length \u003d\u003d\u003d 0) {\n    drawBottomBarAndFooter(slide, layout, pageNum, settings);\n    return;\n  }\n  let currentY \u003d area.top;\n  const cardGap \u003d layout.pxToPt(12);\n  const totalGaps \u003d cardGap * (items.length - 1);\n  const availableHeight \u003d area.height - totalGaps;\n  const cardHeight \u003d availableHeight / items.length;\n  items.forEach((item, index) \u003d\u003e {\n    const card \u003d slide.insertShape(SlidesApp.ShapeType.ROUND_RECTANGLE, \n      area.left, currentY, area.width, cardHeight);\n    card.getFill().setSolidFill(CONFIG.COLORS.background_gray);\n    card.getBorder().getLineFill().setSolidFill(CONFIG.COLORS.card_border);\n    card.getBorder().setWeight(1);\n    let cardPadding, qAreaRatio, qAGap;\n    if (items.length \u003c\u003d 2) {\n      cardPadding \u003d layout.pxToPt(16);\n      qAreaRatio \u003d 0.30;\n      qAGap \u003d layout.pxToPt(6);\n    } else if (items.length \u003d\u003d\u003d 3) {\n      cardPadding \u003d layout.pxToPt(12);\n      qAreaRatio \u003d 0.35;\n      qAGap \u003d layout.pxToPt(4);\n    } else {\n      cardPadding \u003d layout.pxToPt(8);\n      qAreaRatio \u003d 0.40;\n      qAGap \u003d layout.pxToPt(2);\n    }\n    const baseFontSize \u003d items.length \u003e\u003d 4 ? 12 : 14;\n    const availableHeight \u003d cardHeight - cardPadding * 2;\n    const qAreaHeight \u003d Math.floor(availableHeight * qAreaRatio);\n    const aAreaHeight \u003d availableHeight - qAreaHeight - qAGap;\n    const qTop \u003d currentY + cardPadding;\n    const qText \u003d item.q || \u0027\u0027;\n    const qParsed \u003d parseInlineStyles(qText);\n    const qFullText \u003d `Q. ${qParsed.output}`;\n    const qTextShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, \n      area.left + cardPadding, qTop, \n      area.width - cardPadding * 2, qAreaHeight - layout.pxToPt(2));\n    qTextShape.getFill().setTransparent();\n    qTextShape.getBorder().setTransparent();\n    const qTextRange \u003d qTextShape.getText().setText(qFullText);\n    applyTextStyle(qTextRange, {\n      size: baseFontSize,\n      color: CONFIG.COLORS.text_small_font,\n      align: SlidesApp.ParagraphAlignment.LEFT\n    });\n    try {\n      const qPrefixRange \u003d qTextRange.getRange(0, 2);\n      qPrefixRange.getTextStyle()\n        .setBold(true)\n        .setForegroundColor(settings.primaryColor);\n      if (qFullText.length \u003e 3) {\n        const qContentRange \u003d qTextRange.getRange(3, qFullText.length);\n        qContentRange.getTextStyle().setBold(true);\n      }\n      qParsed.ranges.forEach(r \u003d\u003e {\n        const adjustedRange \u003d qTextRange.getRange(r.start + 3, r.end + 3);\n        if (r.bold) adjustedRange.getTextStyle().setBold(true);\n        if (r.color) adjustedRange.getTextStyle().setForegroundColor(r.color);\n      });\n    } catch (e) {}\n    try {\n      qTextShape.setContentAlignment(SlidesApp.ContentAlignment.TOP);\n    } catch (e) {}\n    const aTop \u003d qTop + qAreaHeight + qAGap;\n    const aText \u003d item.a || \u0027\u0027;\n    const aParsed \u003d parseInlineStyles(aText);\n    const aFullText \u003d `A. ${aParsed.output}`;\n    const aIndent \u003d layout.pxToPt(16);\n    const aTextShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, \n      area.left + cardPadding + aIndent, aTop, \n      area.width - cardPadding * 2 - aIndent, aAreaHeight - layout.pxToPt(2));\n    aTextShape.getFill().setTransparent();\n    aTextShape.getBorder().setTransparent();\n    const aTextRange \u003d aTextShape.getText().setText(aFullText);\n    applyTextStyle(aTextRange, {\n      size: baseFontSize,\n      color: CONFIG.COLORS.text_small_font,\n      align: SlidesApp.ParagraphAlignment.LEFT\n    });\n    try {\n      const aPrefixRange \u003d aTextRange.getRange(0, 2);\n      aPrefixRange.getTextStyle()\n        .setBold(true)\n        .setForegroundColor(generateTintedGray(settings.primaryColor, 15, 70));\n      aParsed.ranges.forEach(r \u003d\u003e {\n        const adjustedRange \u003d aTextRange.getRange(r.start + 3, r.end + 3);\n        if (r.bold) adjustedRange.getTextStyle().setBold(true);\n        if (r.color) adjustedRange.getTextStyle().setForegroundColor(r.color);\n      });\n    } catch (e) {}\n    try {\n      aTextShape.setContentAlignment(SlidesApp.ContentAlignment.TOP);\n    } catch (e) {}\n    currentY +\u003d cardHeight + cardGap;\n  });\n  drawBottomBarAndFooter(slide, layout, pageNum, settings);\n}\nfunction drawFaqItems(slide, items, layout, listArea, settings) {\n  if (!items || !items.length) return;\n  const px \u003d v \u003d\u003e layout.pxToPt(v);\n  const GAP_ITEM \u003d px(16);\n  const PADDING \u003d px(20);\n  const totalCardHeight \u003d listArea.height - (GAP_ITEM * (items.length - 1));\n  const cardHeight \u003d totalCardHeight / items.length;\n  let currentY \u003d listArea.top;\n  items.forEach((qa) \u003d\u003e {\n    const card \u003d slide.insertShape(\n      SlidesApp.ShapeType.RECTANGLE,\n      listArea.left, currentY,\n      listArea.width, cardHeight\n    );\n    card.getFill().setSolidFill(CONFIG.COLORS.background_gray);\n    card.getBorder().getLineFill().setSolidFill(CONFIG.COLORS.card_border);\n    const q \u003d qa.q || \u0027\u0027;\n    const a \u003d qa.a || \u0027\u0027;\n    const qIconWidth \u003d px(30);\n    const qTextLeft \u003d listArea.left + PADDING + qIconWidth;\n    const qTextWidth \u003d listArea.width - PADDING * 2 - qIconWidth;\n    const qIcon \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX,\n      listArea.left + PADDING, currentY + PADDING, qIconWidth, px(24));\n    setStyledText(qIcon, \u0027Q.\u0027, { size: 18, bold: true, color: settings.primaryColor });\n    const qBox \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX,\n      qTextLeft, currentY + PADDING, qTextWidth, px(40));\n    setStyledText(qBox, q, { size: 14, bold: true, color: CONFIG.COLORS.text_primary });\n    const aTop \u003d currentY + PADDING + px(35);\n    const aHeight \u003d cardHeight - (PADDING * 2) - px(35);\n    let answerFontSize \u003d 14;\n    if (a.length \u003e 100) {\n      answerFontSize \u003d 11;\n    } else if (a.length \u003e 60) {\n      answerFontSize \u003d 12.5;\n    }\n    const aIcon \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX,\n      listArea.left + PADDING, aTop, qIconWidth, aHeight);\n    const tintedGrayColor \u003d generateTintedGray(settings.primaryColor, 15, 70);\n    setStyledText(aIcon, \u0027A.\u0027, { size: 18, bold: true, color: tintedGrayColor });\n    const aBox \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX,\n      qTextLeft, aTop, qTextWidth, aHeight);\n    setStyledText(aBox, a, { size: answerFontSize, color: CONFIG.COLORS.text_primary });\n    try {\n      [qIcon, qBox, aIcon, aBox].forEach(s \u003d\u003e {\n        s.setContentAlignment(SlidesApp.ContentAlignment.TOP);\n        s.setAutofit(SlidesApp.AutofitType.SHRINK_ON_OVERFLOW);\n      });\n    } catch(e){}\n    currentY +\u003d cardHeight + GAP_ITEM;\n  });\n}\nfunction safeAlignTop(box){\n  try { box.setContentAlignment(SlidesApp.ContentAlignment.TOP);\n  } catch(e){}\n}\nfunction insertTrendIcon(slide, position, trend, settings) {\n  const iconSize \u003d 20;\n  const icon \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, \n    position.left, position.top - iconSize/2, iconSize, iconSize);\n  let iconText \u003d \u0027\u0027;\n  let iconColor \u003d CONFIG.COLORS.text_primary;\n  switch (trend) {\n    case \u0027up\u0027:\n      iconText \u003d \u0027↑\u0027;\n      iconColor \u003d CONFIG.COLORS.success_green;\n      break;\n    case \u0027down\u0027:\n      iconText \u003d \u0027↓\u0027;\n      iconColor \u003d CONFIG.COLORS.error_red;\n      break;\n    case \u0027neutral\u0027:\n      iconText \u003d \u0027→\u0027;\n      iconColor \u003d CONFIG.COLORS.neutral_gray;\n      break;\n    default:\n      iconText \u003d \u0027→\u0027;\n      iconColor \u003d CONFIG.COLORS.neutral_gray;\n  }\n  setStyledText(icon, iconText, {\n    size: 16,\n    bold: true,\n    color: iconColor,\n    align: SlidesApp.ParagraphAlignment.CENTER\n  });\n  try {\n    icon.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n  } catch (e) {}\n  return icon;\n}\nfunction parseNumericValue(str) {\n  if (typeof str !\u003d\u003d \u0027string\u0027) return 0;\n  const match \u003d str.match(/(\\d+(\\.\\d+)?)/);\n  return match ? parseFloat(match[1]) : 0;\n}\nfunction createStatsCompareSlide(slide, data, layout, pageNum, settings, imageUpdateOption \u003d \u0027update\u0027) {\n  setMainSlideBackground(slide, layout);\n  const titleWidthPt \u003d (data \u0026\u0026 typeof data._title_widthPt \u003d\u003d\u003d \u0027number\u0027) ? data._title_widthPt : null;\n  drawStandardTitleHeader(slide, layout, \u0027compareSlide\u0027, data.title, settings, titleWidthPt, imageUpdateOption);\n  const subheadWidthPt \u003d (data \u0026\u0026 typeof data._subhead_widthPt \u003d\u003d\u003d \u0027number\u0027) ?\n  data._subhead_widthPt : null;\n  const dy \u003d drawSubheadIfAny(slide, layout, \u0027compareSlide\u0027, data.subhead, subheadWidthPt); \n  const area \u003d offsetRect(layout.getRect({\n    left: 25,\n    top: 130,\n    width: 910,\n    height: 330\n  }), 0, dy);\n  const stats \u003d Array.isArray(data.stats) ? data.stats : [];\n  if (stats.length \u003d\u003d\u003d 0) {\n    drawBottomBarAndFooter(slide, layout, pageNum, settings);\n    return;\n  }\n  const headerHeight \u003d layout.pxToPt(40);\n  const cushionTop \u003d area.top + headerHeight;\n  const cushionHeight \u003d area.height - headerHeight;\n  if (cushionHeight \u003e 0) {\n      const cushion \u003d slide.insertShape(\n          SlidesApp.ShapeType.RECTANGLE,\n          area.left,\n          cushionTop,\n          area.width,\n          cushionHeight\n      );\n      cushion.getFill().setSolidFill(CONFIG.COLORS.background_gray);\n      cushion.getBorder().setTransparent();\n  }\n  const totalContentWidth \u003d area.width;\n  const centerColWidth \u003d totalContentWidth * 0.25;\n  const sideColWidth \u003d (totalContentWidth - centerColWidth) / 2;\n  const leftValueColX \u003d area.left;\n  const centerLabelColX \u003d leftValueColX + sideColWidth;\n  const rightValueColX \u003d centerLabelColX + centerColWidth;\n  const labelColor \u003d generateTintedGray(settings.primaryColor, 35, 70);\n  const compareColors \u003d generateCompareColors(settings.primaryColor);\n  const leftHeader \u003d slide.insertShape(SlidesApp.ShapeType.RECTANGLE, leftValueColX, area.top, sideColWidth, headerHeight);\n  leftHeader.getFill().setSolidFill(compareColors.left);\n  leftHeader.getBorder().setTransparent();\n  setStyledText(leftHeader, data.leftTitle || \u0027\u0027, {\n    size: 14,\n    bold: true,\n    color: CONFIG.COLORS.background_gray,\n    align: SlidesApp.ParagraphAlignment.CENTER\n  });\n  try { leftHeader.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE); } catch (e) {}\n  const rightHeader \u003d slide.insertShape(SlidesApp.ShapeType.RECTANGLE, rightValueColX, area.top, sideColWidth, headerHeight);\n  rightHeader.getFill().setSolidFill(compareColors.right);\n  rightHeader.getBorder().setTransparent();\n  setStyledText(rightHeader, data.rightTitle || \u0027\u0027, {\n    size: 14,\n    bold: true,\n    color: CONFIG.COLORS.background_gray,\n    align: SlidesApp.ParagraphAlignment.CENTER\n  });\n  try { rightHeader.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE); } catch (e) {}\n  const contentAreaHeight \u003d area.height - headerHeight;\n  const rowHeight \u003d contentAreaHeight / stats.length;\n  let currentY \u003d area.top + headerHeight;\n  stats.forEach((stat, index) \u003d\u003e {\n    const centerY \u003d currentY + rowHeight / 2;\n    const valueHeight \u003d layout.pxToPt(40);\n    const labelShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, centerLabelColX, centerY - valueHeight / 2, centerColWidth, valueHeight);\n    setStyledText(labelShape, stat.label || \u0027\u0027, {\n      size: 14,\n      align: SlidesApp.ParagraphAlignment.CENTER,\n      bold: true,\n      //fontType: \u0027large\u0027\n    });\n    try { labelShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE); } catch (e) {}\n    const leftValueShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, leftValueColX, centerY - valueHeight / 2, sideColWidth, valueHeight);\n    setStyledText(leftValueShape, stat.leftValue || \u0027\u0027, {\n      size: 22,\n      bold: true,\n      align: SlidesApp.ParagraphAlignment.CENTER,\n      color: compareColors.left\n    });\n    try { leftValueShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE); } catch (e) {}\n    const rightValueShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, rightValueColX, centerY - valueHeight / 2, sideColWidth, valueHeight);\n    setStyledText(rightValueShape, stat.rightValue || \u0027\u0027, {\n      size: 22,\n      bold: true,\n      align: SlidesApp.ParagraphAlignment.CENTER,\n      color: compareColors.right\n    });\n    try { rightValueShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE); } catch (e) {}\n    if (index \u003c stats.length - 1) {\n      const lineY \u003d currentY + rowHeight;\n      const line \u003d slide.insertLine(SlidesApp.LineCategory.STRAIGHT, area.left + layout.pxToPt(15), lineY, area.left + area.width - layout.pxToPt(15), lineY);\n      line.getLineFill().setSolidFill(CONFIG.COLORS.faint_gray);\n      line.setWeight(1);\n    }\n    currentY +\u003d rowHeight;\n  });\n  drawBottomBarAndFooter(slide, layout, pageNum, settings);\n}\nfunction createBarCompareSlide(slide, data, layout, pageNum, settings, imageUpdateOption \u003d \u0027update\u0027) {\n  setMainSlideBackground(slide, layout);\n  const titleWidthPt \u003d (data \u0026\u0026 typeof data._title_widthPt \u003d\u003d\u003d \u0027number\u0027) ? data._title_widthPt : null;\n  drawStandardTitleHeader(slide, layout, \u0027compareSlide\u0027, data.title, settings, titleWidthPt, imageUpdateOption);\n  const subheadWidthPt \u003d (data \u0026\u0026 typeof data._subhead_widthPt \u003d\u003d\u003d \u0027number\u0027) ?\n  data._subhead_widthPt : null;\n  const dy \u003d drawSubheadIfAny(slide, layout, \u0027compareSlide\u0027, data.subhead, subheadWidthPt); \n  const area \u003d offsetRect(layout.getRect({\n    left: 40,\n    top: 130,\n    width: 880,\n    height: 340\n  }), 0, dy);\n  const stats \u003d Array.isArray(data.stats) ? data.stats : [];\n  if (stats.length \u003d\u003d\u003d 0) {\n    drawBottomBarAndFooter(slide, layout, pageNum, settings);\n    return;\n  }\n  const showTrends \u003d !!data.showTrends;\n  const blockMargin \u003d layout.pxToPt(20);\n  const totalContentHeight \u003d area.height - (blockMargin * (stats.length - 1));\n  const blockHeight \u003d totalContentHeight / stats.length;\n  let currentY \u003d area.top;\n  stats.forEach(stat \u003d\u003e {\n    const blockTop \u003d currentY;\n    const titleHeight \u003d layout.pxToPt(35);\n    const barAreaHeight \u003d blockHeight - titleHeight;\n    const barRowHeight \u003d barAreaHeight / 2;\n    const shouldShowTrend \u003d showTrends \u0026\u0026 stat.trend;\n    const statTitleShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, area.left, blockTop, area.width, titleHeight);\n    setStyledText(statTitleShape, stat.label || \u0027\u0027, {\n      size: 16,\n      bold: true,\n    });\n    try { statTitleShape.setContentAlignment(SlidesApp.ContentAlignment.BOTTOM); } catch(e){}\n    const asIsY \u003d blockTop + titleHeight;\n    const toBeY \u003d asIsY + barRowHeight;\n    const labelWidth \u003d layout.pxToPt(90);\n    const valueWidth \u003d layout.pxToPt(140);\n    const barWidth \u003d Math.max(layout.pxToPt(50), area.width - labelWidth - valueWidth - layout.pxToPt(10));\n    const barLeft \u003d area.left + labelWidth;\n    const barHeight \u003d layout.pxToPt(18);\n    const val1 \u003d parseNumericValue(stat.leftValue);\n    const val2 \u003d parseNumericValue(stat.rightValue);\n    const maxValue \u003d Math.max(val1, val2, 1);\n    const asIsLabel \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, area.left, asIsY, labelWidth, barRowHeight);\n    setStyledText(asIsLabel, \u0027現状\u0027, { size: 13, color: CONFIG.COLORS.neutral_gray });\n    const asIsValue \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, barLeft + barWidth, asIsY, valueWidth, barRowHeight);\n    setStyledText(asIsValue, stat.leftValue || \u0027\u0027, { size: 18, bold: true, align: SlidesApp.ParagraphAlignment.END });\n    const asIsTrack \u003d slide.insertShape(SlidesApp.ShapeType.ROUND_RECTANGLE, barLeft, asIsY + barRowHeight/2 - barHeight/2, barWidth, barHeight);\n    asIsTrack.getFill().setSolidFill(CONFIG.COLORS.faint_gray);\n    asIsTrack.getBorder().setTransparent();\n    const asIsFillWidth \u003d Math.max(layout.pxToPt(2), barWidth * (val1 / maxValue));\n    const asIsFill \u003d slide.insertShape(SlidesApp.ShapeType.ROUND_RECTANGLE, barLeft, asIsY + barRowHeight/2 - barHeight/2, asIsFillWidth, barHeight);\n    asIsFill.getFill().setSolidFill(CONFIG.COLORS.neutral_gray);\n    asIsFill.getBorder().setTransparent();\n    const toBeLabel \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, area.left, toBeY, labelWidth, barRowHeight);\n    setStyledText(toBeLabel, \u0027導入後\u0027, { size: 13, color: settings.primaryColor, bold: true });\n    const toBeValue \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, barLeft + barWidth, toBeY, valueWidth, barRowHeight);\n    setStyledText(toBeValue, stat.rightValue || \u0027\u0027, { size: 18, bold: true, color: settings.primaryColor, align: SlidesApp.ParagraphAlignment.END });\n    const toBeTrack \u003d slide.insertShape(SlidesApp.ShapeType.ROUND_RECTANGLE, barLeft, toBeY + barRowHeight/2 - barHeight/2, barWidth, barHeight);\n    toBeTrack.getFill().setSolidFill(generateTintedGray(settings.primaryColor, 20, 96));\n    toBeTrack.getBorder().setTransparent();\n    const toBeFillWidth \u003d Math.max(layout.pxToPt(2), barWidth * (val2 / maxValue));\n    const shape \u003d slide.insertShape(SlidesApp.ShapeType.ROUND_RECTANGLE, barLeft, toBeY + barRowHeight/2 - barHeight/2, toBeFillWidth, barHeight);\n    shape.getFill().setSolidFill(settings.primaryColor);\n    shape.getBorder().setTransparent();\n    try {\n        [asIsLabel, asIsValue, toBeLabel, toBeValue].forEach(shape \u003d\u003e shape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE));\n    } catch(e){}\n    if (shouldShowTrend) {\n      const trendIcon \u003d insertTrendIcon(slide, { left: barLeft + barWidth + layout.pxToPt(10), top: toBeY + barRowHeight/2 }, stat.trend, settings);\n    }\n    currentY +\u003d blockHeight + blockMargin;\n  });\n  drawBottomBarAndFooter(slide, layout, pageNum, settings);\n}\nfunction smartFormatTriangleText(text) {\n  if (!text || text.length \u003c\u003d 30) {\n    return { text: text, isSimple: true, headerLength: 0 };\n  }\n  const separators \u003d [\n    { pattern: \u0027：\u0027, priority: 1 },\n    { pattern: \u0027:\u0027, priority: 2 },\n    { pattern: \u0027。\u0027, priority: 3 },\n    { pattern: \u0027について\u0027, priority: 4, keepSeparator: true },\n    { pattern: \u0027における\u0027, priority: 5, keepSeparator: true }\n  ];\n  for (let sep of separators) {\n    const index \u003d text.indexOf(sep.pattern);\n    if (index \u003e 5 \u0026\u0026 index \u003c text.length * 0.6) {\n      const headerEnd \u003d sep.keepSeparator ? index + sep.pattern.length : index;\n      const header \u003d text.substring(0, headerEnd).trim();\n      const body \u003d text.substring(index + sep.pattern.length).trim();\n      if (header.length \u003e\u003d 3 \u0026\u0026 body.length \u003e\u003d 3) {\n        return {\n          text: `${header}\\n${body}`,\n          isSimple: false,\n          headerLength: header.length\n        };\n      }\n    }\n  }\n  if (text.length \u003e 50) {\n    const midPoint \u003d Math.floor(text.length * 0.4);\n    const header \u003d text.substring(0, midPoint).trim();\n    const body \u003d text.substring(midPoint).trim();\n    return {\n      text: `${header}\\n${body}`,\n      isSimple: false,\n      headerLength: header.length\n    };\n  }\n  return { text: text, isSimple: true, headerLength: 0 };\n}\nfunction createTriangleSlide(slide, data, layout, pageNum, settings, imageUpdateOption \u003d \u0027update\u0027) {\n  setMainSlideBackground(slide, layout);\n  const titleWidthPt \u003d (data \u0026\u0026 typeof data._title_widthPt \u003d\u003d\u003d \u0027number\u0027) ? data._title_widthPt : null;\n  drawStandardTitleHeader(slide, layout, \u0027triangleSlide\u0027, data.title, settings, titleWidthPt, imageUpdateOption);\n  const subheadWidthPt \u003d (data \u0026\u0026 typeof data._subhead_widthPt \u003d\u003d\u003d \u0027number\u0027) ?\n  data._subhead_widthPt : null;\n  const dy \u003d drawSubheadIfAny(slide, layout, \u0027triangleSlide\u0027, data.subhead, subheadWidthPt); \n  const baseArea \u003d layout.getRect(\u0027triangleSlide.area\u0027);\n  const adjustedArea \u003d adjustAreaForSubhead(baseArea, data.subhead, layout);\n  const area \u003d offsetRect(adjustedArea, 0, dy);\n  const verticalShiftUpPt \u003d layout.pxToPt(26.67);\n  area.top -\u003d verticalShiftUpPt;\n  const items \u003d Array.isArray(data.items) ? data.items.slice(0, 3) : [];\n  if (items.length \u003d\u003d\u003d 0) {\n    drawBottomBarAndFooter(slide, layout, pageNum, settings);\n    return;\n  }\n  const IMAGE_ADJUSTMENTS_LARGE \u003d {\n    topLeft:  { sizePt: layout.pxToPt(76), offsetXPt: layout.pxToPt(-105), offsetYPt: layout.pxToPt(-25) },\n    topRight: { sizePt: layout.pxToPt(78), offsetXPt: layout.pxToPt(100),  offsetYPt: layout.pxToPt(-30) },\n    bottom:   { sizePt: layout.pxToPt(95), offsetXPt: layout.pxToPt(0),    offsetYPt: layout.pxToPt(0)  }\n  };\n  const IMAGE_ADJUSTMENTS_MEDIUM \u003d {\n    topLeft:  { sizePt: layout.pxToPt(78), offsetXPt: layout.pxToPt(-95), offsetYPt: layout.pxToPt(-35) },\n    topRight: { sizePt: layout.pxToPt(80), offsetXPt: layout.pxToPt(90),  offsetYPt: layout.pxToPt(-40) },\n    bottom:   { sizePt: layout.pxToPt(100), offsetXPt: layout.pxToPt(0),   offsetYPt: layout.pxToPt(10)  }\n  };\n  const IMAGE_ADJUSTMENTS_SMALL \u003d {\n    topLeft:  { sizePt: layout.pxToPt(80), offsetXPt: layout.pxToPt(-85), offsetYPt: layout.pxToPt(-25) },\n    topRight: { sizePt: layout.pxToPt(82), offsetXPt: layout.pxToPt(80),  offsetYPt: layout.pxToPt(-30) },\n    bottom:   { sizePt: layout.pxToPt(105), offsetXPt: layout.pxToPt(0),   offsetYPt: layout.pxToPt(0)   }\n  };\n  const textLengths \u003d items.map(item \u003d\u003e (typeof item \u003d\u003d\u003d \u0027string\u0027 ? item : (item.title || \u0027\u0027) + (item.desc || \u0027\u0027)).length);\n  const maxLength \u003d Math.max(0, ...textLengths);\n  const avgLength \u003d textLengths.length \u003e 0 ? textLengths.reduce((sum, len) \u003d\u003e sum + len, 0) / textLengths.length : 0;\n  let cardW, cardH, fontSize;\n  let selectedAdjustments;\n  let isLargeCardSize \u003d false;\n  if (maxLength \u003e 60 || avgLength \u003e 40) {\n    cardW \u003d layout.pxToPt(340); cardH \u003d layout.pxToPt(160); fontSize \u003d 13;\n    selectedAdjustments \u003d IMAGE_ADJUSTMENTS_LARGE;\n    isLargeCardSize \u003d true;\n  }\n  else if (maxLength \u003e 35 || avgLength \u003e 25) {\n    cardW \u003d layout.pxToPt(290); cardH \u003d layout.pxToPt(135); fontSize \u003d 14;\n    selectedAdjustments \u003d IMAGE_ADJUSTMENTS_MEDIUM;\n  }\n  else {\n    cardW \u003d layout.pxToPt(250); cardH \u003d layout.pxToPt(115); fontSize \u003d 15;\n    selectedAdjustments \u003d IMAGE_ADJUSTMENTS_SMALL;\n  }\n  const maxCardW \u003d (area.width - layout.pxToPt(160)) / 1.5;\n  const maxCardH \u003d (area.height - layout.pxToPt(80)) / 2;\n  cardW \u003d Math.min(cardW, maxCardW); cardH \u003d Math.min(cardH, maxCardH);\n  let bottomCardMarginPt;\n  if (isLargeCardSize) {\n    bottomCardMarginPt \u003d layout.pxToPt(50);\n  } else {\n    bottomCardMarginPt \u003d layout.pxToPt(80);\n  }\n  const positions \u003d [\n    { x: area.left + area.width / 2,                          y: area.top + layout.pxToPt(40) + cardH / 2 },\n    { x: area.left + area.width - bottomCardMarginPt - cardW / 2, y: area.top + area.height - cardH / 2 },\n    { x: area.left + bottomCardMarginPt + cardW / 2,             y: area.top + area.height - cardH / 2 }\n  ];\n  positions.forEach((pos, i) \u003d\u003e {\n    if (!items[i]) return;\n    const cardX \u003d pos.x - cardW / 2;\n    const cardY \u003d pos.y - cardH / 2;\n    const card \u003d slide.insertShape(SlidesApp.ShapeType.ROUND_RECTANGLE, cardX, cardY, cardW, cardH);\n    card.getFill().setSolidFill(CONFIG.COLORS.background_gray);\n    card.getBorder().getLineFill().setSolidFill(CONFIG.COLORS.card_border);\n    const item \u003d items[i] || {};\n    const itemTitle \u003d typeof item \u003d\u003d\u003d \u0027string\u0027 ? \u0027\u0027 : (item.title || \u0027\u0027);\n    const itemDesc \u003d typeof item \u003d\u003d\u003d \u0027string\u0027 ? item : (item.desc || \u0027\u0027);\n    if (typeof item \u003d\u003d\u003d \u0027string\u0027 || !itemTitle) {\n        const itemText \u003d typeof item \u003d\u003d\u003d \u0027string\u0027 ? item : itemDesc;\n        const processedText \u003d smartFormatTriangleText(itemText);\n        if (processedText.isSimple) {\n            let appliedFontSize \u003d fontSize;\n            if ((processedText.text || \u0027\u0027).length \u003e 35) { appliedFontSize \u003d Math.max(fontSize - 1, 12); }\n            setStyledText(card, processedText.text, { size: appliedFontSize, bold: true, color: CONFIG.COLORS.text_small_font, align: SlidesApp.ParagraphAlignment.CENTER });\n        } else {\n            const lines \u003d processedText.text.split(\u0027\\n\u0027);\n            const header \u003d lines[0] || \u0027\u0027;\n            const body \u003d lines.slice(1).join(\u0027\\n\u0027) || \u0027\u0027;\n            const enhancedText \u003d `${header}\\n${body}`;\n            const headerFontSize \u003d Math.max(fontSize - 1, 13);\n            const bodyFontSize \u003d Math.max(fontSize - 3, 11);\n            setStyledText(card, enhancedText, { size: bodyFontSize, bold: false, color: CONFIG.COLORS.text_small_font, align: SlidesApp.ParagraphAlignment.CENTER });\n            try {\n                const textRange \u003d card.getText();\n                const headerEndIndex \u003d header.length;\n                if (headerEndIndex \u003e 0) {\n                    const headerRange \u003d textRange.getRange(0, headerEndIndex);\n                    headerRange.getTextStyle().setBold(true).setFontSize(headerFontSize).setForegroundColor(settings.primaryColor);\n                }\n            } catch (e) { Logger.log(`Error styling triangle header (auto-split): ${e.message}`); }\n        }\n    } else {\n        const enhancedText \u003d itemDesc ? `${itemTitle}\\n${itemDesc}` : itemTitle;\n        const headerFontSize \u003d Math.max(fontSize - 1, 13);\n        const bodyFontSize \u003d Math.max(fontSize - 3, 11);\n        setStyledText(card, enhancedText, { size: bodyFontSize, bold: false, color: CONFIG.COLORS.text_small_font, align: SlidesApp.ParagraphAlignment.CENTER });\n        try {\n            const textRange \u003d card.getText();\n            const headerEndIndex \u003d itemTitle.length;\n            if (headerEndIndex \u003e 0) {\n                const headerRange \u003d textRange.getRange(0, headerEndIndex);\n                headerRange.getTextStyle().setBold(true).setFontSize(headerFontSize).setForegroundColor(settings.primaryColor);\n            }\n        } catch (e) { Logger.log(`Error styling triangle header (structured): ${e.message}`); }\n    }\n    try { setBoldTextSize(card, 16); } catch(e) { Logger.log(`Error applying setBoldTextSize in triangle slide: ${e.message}`); }\n    try { card.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE); } catch (e) {}\n  });\n  const triangleArrows \u003d settings.triangleArrows;\n  const hasValidImageData \u003d triangleArrows \u0026\u0026\n                             triangleArrows.topLeftArrowBase64 \u0026\u0026\n                             triangleArrows.topRightArrowBase64 \u0026\u0026\n                             triangleArrows.bottomArrowBase64;\n  if (hasValidImageData \u0026\u0026 items.length \u003d\u003d\u003d 3) {\n    function insertTriangleArrowImage(arrowName, base64Data, left, top, size) {\n    if (imageUpdateOption !\u003d\u003d \u0027update\u0027) return;  \n      if (!base64Data) {\n        return;\n      }\n      try {\n        const imageData \u003d insertImageFromUrlOrFileId(base64Data);\n        if (imageData) {\n          const img \u003d slide.insertImage(imageData);\n          const originalWidth \u003d img.getWidth();\n          const originalHeight \u003d img.getHeight();\n          let targetWidth \u003d size;\n          let targetHeight \u003d size;\n          if (originalWidth \u003e originalHeight) {\n              targetHeight \u003d size * (originalHeight / originalWidth);\n          } else if (originalHeight \u003e originalWidth) {\n              targetWidth \u003d size * (originalWidth / originalHeight);\n          }\n          img.setLeft(left + (size - targetWidth) / 2)\n             .setTop(top + (size - targetHeight) / 2)\n             .setWidth(targetWidth)\n             .setHeight(targetHeight);\n        }\n      } catch (e) {\n      }\n    }\n    const arrow1_baseX \u003d (positions[2].x + positions[0].x) / 2;\n    const arrow1_baseY \u003d (positions[2].y + positions[0].y) / 2;\n    const adj1 \u003d selectedAdjustments.topLeft;\n    insertTriangleArrowImage(\n      \u0027topLeft\u0027,\n      triangleArrows.topLeftArrowBase64,\n      arrow1_baseX - (adj1.sizePt / 2) + adj1.offsetXPt,\n      arrow1_baseY - (adj1.sizePt / 2) + adj1.offsetYPt,\n      adj1.sizePt\n    );\n    const arrow2_baseX \u003d (positions[0].x + positions[1].x) / 2;\n    const arrow2_baseY \u003d (positions[0].y + positions[1].y) / 2;\n    const adj2 \u003d selectedAdjustments.topRight;\n    insertTriangleArrowImage(\n      \u0027topRight\u0027,\n      triangleArrows.topRightArrowBase64,\n      arrow2_baseX - (adj2.sizePt / 2) + adj2.offsetXPt,\n      arrow2_baseY - (adj2.sizePt / 2) + adj2.offsetYPt,\n      adj2.sizePt\n    );\n    const arrow3_baseX \u003d (positions[1].x + positions[2].x) / 2;\n    const arrow3_baseY \u003d (positions[1].y + positions[2].y) / 2;\n    const adj3 \u003d selectedAdjustments.bottom;\n    insertTriangleArrowImage(\n      \u0027bottom\u0027,\n      triangleArrows.bottomArrowBase64,\n      arrow3_baseX - (adj3.sizePt / 2) + adj3.offsetXPt,\n      arrow3_baseY - (adj3.sizePt / 2) + adj3.offsetYPt,\n      adj3.sizePt\n    );\n  } else if (items.length \u003d\u003d\u003d 3 \u0026\u0026 imageUpdateOption \u003d\u003d\u003d \u0027update\u0027) {\n    if (items.length \u003d\u003d\u003d 3) {\n      const arrowPadding \u003d cardW \u003e layout.pxToPt(300) ? layout.pxToPt(25) : layout.pxToPt(20);\n      const cardEdges \u003d [];\n      cardEdges[0] \u003d { rightCenter: { x: positions[0].x + cardW / 2, y: positions[0].y }, leftCenter: { x: positions[0].x - cardW / 2, y: positions[0].y }, bottomCenter: { x: positions[0].x, y: positions[0].y + cardH / 2 } };\n      cardEdges[1] \u003d { leftCenter: { x: positions[1].x - cardW / 2, y: positions[1].y }, topCenter: { x: positions[1].x, y: positions[1].y - cardH / 2 } };\n      cardEdges[2] \u003d { rightCenter: { x: positions[2].x + cardW / 2, y: positions[2].y }, topCenter: { x: positions[2].x, y: positions[2].y - cardH / 2 } };\n      const arrowLines \u003d [];\n      arrowLines[0] \u003d { startX: cardEdges[0].rightCenter.x + arrowPadding, startY: cardEdges[0].rightCenter.y, endX: cardEdges[1].topCenter.x + arrowPadding / 2 , endY: cardEdges[1].topCenter.y - arrowPadding};\n      arrowLines[1] \u003d { startX: cardEdges[1].leftCenter.x - arrowPadding, startY: cardEdges[1].leftCenter.y + arrowPadding / 2, endX: cardEdges[2].rightCenter.x + arrowPadding, endY: cardEdges[2].rightCenter.y + arrowPadding / 2};\n      arrowLines[2] \u003d { startX: cardEdges[2].topCenter.x - arrowPadding / 2, startY: cardEdges[2].topCenter.y - arrowPadding, endX: cardEdges[0].leftCenter.x - arrowPadding, endY: cardEdges[0].leftCenter.y};\n      arrowLines.forEach(lineDef \u003d\u003e {\n        try {\n          const line \u003d slide.insertLine(\n            SlidesApp.LineCategory.STRAIGHT,\n            lineDef.startX, lineDef.startY,\n            lineDef.endX, lineDef.endY\n          );\n          line.getLineFill().setSolidFill(CONFIG.COLORS.ghost_gray);\n          line.setWeight(4);\n          line.setEndArrow(SlidesApp.ArrowStyle.FILL_ARROW);\n        } catch (e) {\n        }\n      });\n    }\n  }\n  drawBottomBarAndFooter(slide, layout, pageNum, settings);\n}\nfunction createPyramidSlide(slide, data, layout, pageNum, settings, imageUpdateOption \u003d \u0027update\u0027) {\n  setMainSlideBackground(slide, layout);\n  const titleWidthPt \u003d (data \u0026\u0026 typeof data._title_widthPt \u003d\u003d\u003d \u0027number\u0027) ? data._title_widthPt : null;\n  drawStandardTitleHeader(slide, layout, \u0027pyramidSlide\u0027, data.title, settings, titleWidthPt, imageUpdateOption);\n  const subheadWidthPt \u003d (data \u0026\u0026 typeof data._subhead_widthPt \u003d\u003d\u003d \u0027number\u0027) ?\n  data._subhead_widthPt : null;\n  const dy \u003d drawSubheadIfAny(slide, layout, \u0027pyramidSlide\u0027, data.subhead, subheadWidthPt); \n  const baseArea \u003d layout.getRect(\u0027pyramidSlide.pyramidArea\u0027);\n  const adjustedArea \u003d adjustAreaForSubhead(baseArea, data.subhead, layout);\n  const area \u003d offsetRect(adjustedArea, 0, dy);\n  const levels \u003d Array.isArray(data.levels) ? data.levels.slice(0, 4) : [];\n  if (levels.length \u003d\u003d\u003d 0) {\n    drawBottomBarAndFooter(slide, layout, pageNum, settings);\n    return;\n  }\n  const levelHeight \u003d layout.pxToPt(70);\n  const levelGap \u003d layout.pxToPt(2);\n  const totalHeight \u003d (levelHeight * levels.length) + (levelGap * (levels.length - 1));\n  const startY \u003d area.top + (area.height - totalHeight) / 2;\n  const pyramidWidth \u003d layout.pxToPt(480);\n  const textColumnWidth \u003d layout.pxToPt(400);\n  const gap \u003d layout.pxToPt(30);\n  const pyramidLeft \u003d area.left;\n  const textColumnLeft \u003d pyramidLeft + pyramidWidth + gap;\n  const pyramidColors \u003d generatePyramidColors(settings.primaryColor, levels.length);\n  const baseWidth \u003d pyramidWidth;\n  const widthIncrement \u003d baseWidth / levels.length;\n  const centerX \u003d pyramidLeft + pyramidWidth / 2;\n  levels.forEach((level, index) \u003d\u003e {\n    const levelWidth \u003d baseWidth - (widthIncrement * (levels.length - 1 - index));\n    const levelX \u003d centerX - levelWidth / 2;\n    const levelY \u003d startY + index * (levelHeight + levelGap);\n    const levelBox \u003d slide.insertShape(SlidesApp.ShapeType.ROUND_RECTANGLE, levelX, levelY, levelWidth, levelHeight);\n    levelBox.getFill().setSolidFill(pyramidColors[index]);\n    levelBox.getBorder().setTransparent();\n    const titleShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, levelX, levelY, levelWidth, levelHeight);\n    titleShape.getFill().setTransparent();\n    titleShape.getBorder().setTransparent();\n    const levelTitle \u003d level.title || `レベル${index + 1}`;\n    setStyledText(titleShape, levelTitle, {\n      size: CONFIG.FONTS.sizes.body,\n      bold: true,\n      color: CONFIG.COLORS.background_gray,\n      align: SlidesApp.ParagraphAlignment.CENTER\n    });\n    try {\n      titleShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n    } catch (e) {}\n    const connectionStartX \u003d levelX + levelWidth;\n    const connectionEndX \u003d textColumnLeft;\n    const connectionY \u003d levelY + levelHeight / 2;\n    if (connectionEndX \u003e connectionStartX) {\n      const connectionLine \u003d slide.insertLine(\n        SlidesApp.LineCategory.STRAIGHT,\n        connectionStartX,\n        connectionY,\n        connectionEndX,\n        connectionY\n      );\n      connectionLine.getLineFill().setSolidFill(\u0027#D0D7DE\u0027);\n      connectionLine.setWeight(1.5);\n    }\n    const textShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, textColumnLeft, levelY, textColumnWidth, levelHeight);\n    textShape.getFill().setTransparent();\n    textShape.getBorder().setTransparent();\n    const levelDesc \u003d level.description || \u0027\u0027;\n    let formattedText;\n    if (levelDesc.includes(\u0027•\u0027) || levelDesc.includes(\u0027・\u0027)) {\n      formattedText \u003d levelDesc;\n    } else if (levelDesc.includes(\u0027\\n\u0027)) {\n      const lines \u003d levelDesc.split(\u0027\\n\u0027).filter(line \u003d\u003e line.trim()).slice(0, 2);\n      formattedText \u003d lines.map(line \u003d\u003e `• ${line.trim()}`).join(\u0027\\n\u0027);\n    } else {\n      formattedText \u003d levelDesc;\n    }\n    setStyledText(textShape, formattedText, {\n      size: CONFIG.FONTS.sizes.body - 1,\n      align: SlidesApp.ParagraphAlignment.LEFT,\n      color: CONFIG.COLORS.text_primary,\n      bold: true\n    });\n    try {\n      textShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n    } catch (e) {}\n  });\n  drawBottomBarAndFooter(slide, layout, pageNum, settings);\n}\nfunction createFlowChartSlide(slide, data, layout, pageNum, settings, imageUpdateOption \u003d \u0027update\u0027) {\n  setMainSlideBackground(slide, layout);\n  const titleWidthPt \u003d (data \u0026\u0026 typeof data._title_widthPt \u003d\u003d\u003d \u0027number\u0027) ? data._title_widthPt : null;\n  drawStandardTitleHeader(slide, layout, \u0027flowChartSlide\u0027, data.title, settings, titleWidthPt, imageUpdateOption);\n  const subheadWidthPt \u003d (data \u0026\u0026 typeof data._subhead_widthPt \u003d\u003d\u003d \u0027number\u0027) ?\n  data._subhead_widthPt : null;\n  const dy \u003d drawSubheadIfAny(slide, layout, \u0027flowChartSlide\u0027, data.subhead, subheadWidthPt); \n  const flows \u003d Array.isArray(data.flows) ? data.flows : [{ steps: data.steps || [] }];\n  let isDouble \u003d flows.length \u003e 1;\n  let upperFlow, lowerFlow, maxStepsPerRow;\n  if (!isDouble \u0026\u0026 flows[0] \u0026\u0026 flows[0].steps \u0026\u0026 flows[0].steps.length \u003e\u003d 5) {\n    isDouble \u003d true;\n    const allSteps \u003d flows[0].steps;\n    const midPoint \u003d Math.ceil(allSteps.length / 2);\n    upperFlow \u003d { steps: allSteps.slice(0, midPoint) };\n    lowerFlow \u003d { steps: allSteps.slice(midPoint) };\n    maxStepsPerRow \u003d midPoint;\n  } else {\n    upperFlow \u003d flows[0];\n    lowerFlow \u003d flows.length \u003e 1 ? flows[1] : null;\n    maxStepsPerRow \u003d Math.max(\n      upperFlow?.steps?.length || 0, \n      lowerFlow?.steps?.length || 0\n    );\n  }\n  if (isDouble) {\n    const upperArea \u003d offsetRect(layout.getRect(\u0027flowChartSlide.upperRow\u0027), 0, dy);\n    const lowerArea \u003d offsetRect(layout.getRect(\u0027flowChartSlide.lowerRow\u0027), 0, dy);\n    drawFlowRow(slide, upperFlow, upperArea, settings, layout, maxStepsPerRow);\n    if (lowerFlow \u0026\u0026 lowerFlow.steps \u0026\u0026 lowerFlow.steps.length \u003e 0) {\n      drawFlowRow(slide, lowerFlow, lowerArea, settings, layout, maxStepsPerRow);\n    }\n  } else {\n    const baseSingleArea \u003d layout.getRect(\u0027flowChartSlide.singleRow\u0027);\n    let singleArea \u003d offsetRect(baseSingleArea, 0, dy);\n    const verticalShiftDownPt \u003d layout.pxToPt(26.67);\n    singleArea.top +\u003d verticalShiftDownPt;\n    drawFlowRow(slide, flows[0], singleArea, settings, layout);\n  }\n  drawBottomBarAndFooter(slide, layout, pageNum, settings);\n}\nfunction drawFlowRow(slide, flow, area, settings, layout, maxStepsPerRow \u003d null) {\n  if (!flow || !flow.steps || !Array.isArray(flow.steps)) {\n    return;\n  }\n  const steps \u003d flow.steps.filter(step \u003d\u003e step \u0026\u0026 String(step).trim());\n  if (steps.length \u003d\u003d\u003d 0) return;\n  const actualSteps \u003d maxStepsPerRow || steps.length;\n  const baseArrowSpace \u003d layout.pxToPt(25);\n  const arrowSpace \u003d Math.max(baseArrowSpace, area.width * 0.04);\n  const totalArrowSpace \u003d (actualSteps - 1) * arrowSpace;\n  const cardW \u003d (area.width - totalArrowSpace) / actualSteps;\n  const cardH \u003d area.height;\n  const arrowHeight \u003d Math.min(cardH * 0.3, layout.pxToPt(40));\n  const arrowWidth \u003d arrowSpace;\n  steps.forEach((step, index) \u003d\u003e {\n    const cardX \u003d area.left + index * (cardW + arrowSpace);\n    const card \u003d slide.insertShape(SlidesApp.ShapeType.ROUND_RECTANGLE, cardX, area.top, cardW, cardH);\n    card.getFill().setSolidFill(CONFIG.COLORS.background_gray);\n    card.getBorder().getLineFill().setSolidFill(CONFIG.COLORS.card_border);\n    const stepText \u003d String(step || \u0027\u0027).trim() || \u0027ステップ\u0027;\n    setStyledText(card, stepText, {\n      size: CONFIG.FONTS.sizes.body,\n      align: SlidesApp.ParagraphAlignment.CENTER\n    });\n    try {\n      card.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n    } catch (e) {}\n    if (index \u003c steps.length - 1) {\n      const arrowStartX \u003d cardX + cardW;\n      const arrowCenterY \u003d area.top + cardH / 2;\n      const arrowTop \u003d arrowCenterY - (arrowHeight / 2);\n      const arrow \u003d slide.insertShape(SlidesApp.ShapeType.RIGHT_ARROW, arrowStartX, arrowTop, arrowWidth, arrowHeight);\n      arrow.getFill().setSolidFill(settings.primaryColor);\n      arrow.getBorder().setTransparent();\n    }\n  });\n}\nfunction createStepUpSlide(slide, data, layout, pageNum, settings, imageUpdateOption \u003d \u0027update\u0027) {\n  setMainSlideBackground(slide, layout);\n  const titleWidthPt \u003d (data \u0026\u0026 typeof data._title_widthPt \u003d\u003d\u003d \u0027number\u0027) ? data._title_widthPt : null;\n  drawStandardTitleHeader(slide, layout, \u0027stepUpSlide\u0027, data.title, settings, titleWidthPt, imageUpdateOption);\n  const subheadWidthPt \u003d (data \u0026\u0026 typeof data._subhead_widthPt \u003d\u003d\u003d \u0027number\u0027) ?\n  data._subhead_widthPt : null;\n  const dy \u003d drawSubheadIfAny(slide, layout, \u0027stepUpSlide\u0027, data.subhead, subheadWidthPt); \n  const area \u003d offsetRect(layout.getRect(\u0027stepUpSlide.stepArea\u0027), 0, dy);\n  const items \u003d Array.isArray(data.items) ? data.items : [];\n  if (items.length \u003d\u003d\u003d 0) {\n    drawBottomBarAndFooter(slide, layout, pageNum, settings);\n    return;\n  }\n  const numSteps \u003d Math.min(5, items.length);\n  const gap \u003d 0;\n  const headerHeight \u003d layout.pxToPt(40);\n  const maxHeight \u003d area.height * 0.95;\n  let minHeightRatio;\n  if (numSteps \u003c\u003d 2) {\n    minHeightRatio \u003d 0.70;\n  } else if (numSteps \u003d\u003d\u003d 3) {\n    minHeightRatio \u003d 0.60;\n  } else {\n    minHeightRatio \u003d 0.50;\n  }\n  const minHeight \u003d maxHeight * minHeightRatio;\n  const totalWidth \u003d area.width;\n  const cardW \u003d totalWidth / numSteps;\n  const stepUpColors \u003d generateStepUpColors(settings.primaryColor, numSteps);\n  for (let idx \u003d 0; idx \u003c numSteps; idx++) {\n    const item \u003d items[idx] || {};\n    const titleText \u003d String(item.title || `STEP ${idx + 1}`);\n    const descText \u003d String(item.desc || \u0027\u0027);\n    const heightRatio \u003d (idx / Math.max(1, numSteps - 1));\n    const cardH \u003d minHeight + (maxHeight - minHeight) * heightRatio;\n    const left \u003d area.left + idx * cardW;\n    const top \u003d area.top + area.height - cardH;\n    const bodyShape \u003d slide.insertShape(SlidesApp.ShapeType.RECTANGLE, left, top + headerHeight, cardW, cardH - headerHeight);\n    bodyShape.getFill().setSolidFill(CONFIG.COLORS.background_gray);\n    bodyShape.getBorder().getLineFill().setSolidFill(CONFIG.COLORS.card_border);\n    const headerShape \u003d slide.insertShape(SlidesApp.ShapeType.RECTANGLE, left, top, cardW, headerHeight);\n    headerShape.getFill().setSolidFill(stepUpColors[idx]);\n    headerShape.getBorder().getLineFill().setSolidFill(stepUpColors[idx]);\n    const headerTextShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, left, top, cardW, headerHeight);\n    setStyledText(headerTextShape, titleText, {\n      size: CONFIG.FONTS.sizes.body,\n      bold: true,\n      color: CONFIG.COLORS.background_gray,\n      align: SlidesApp.ParagraphAlignment.CENTER\n    });\n    try {\n      setParenthesizedTextSize(headerTextShape, 10);\n    } catch(e) {\n    }\n    try {\n      headerTextShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n      headerTextShape.setAutofit(SlidesApp.AutofitType.SHRINK_ON_OVERFLOW);\n    } catch (e) {}\n    const bodyTextShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, \n      left + layout.pxToPt(8), top + headerHeight, \n      cardW - layout.pxToPt(16), cardH - headerHeight);\n    setStyledText(bodyTextShape, descText, {\n      size: CONFIG.FONTS.sizes.body,\n      align: SlidesApp.ParagraphAlignment.CENTER\n    });\n    try {\n      bodyTextShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n      bodyTextShape.setAutofit(SlidesApp.AutofitType.SHRINK_ON_OVERFLOW);\n    } catch (e) {}\n  }\n  drawBottomBarAndFooter(slide, layout, pageNum, settings);\n}\nfunction createImageTextSlide(slide, data, layout, pageNum, settings, imageUpdateOption \u003d \u0027update\u0027) {\n  setMainSlideBackground(slide, layout, imageUpdateOption);\n  const titleWidthPt \u003d (data \u0026\u0026 typeof data._title_widthPt \u003d\u003d\u003d \u0027number\u0027) ? data._title_widthPt : null;\n  drawStandardTitleHeader(slide, layout, \u0027imageTextSlide\u0027, data.title, settings, titleWidthPt, imageUpdateOption);\n  const subheadWidthPt \u003d (data \u0026\u0026 typeof data._subhead_widthPt \u003d\u003d\u003d \u0027number\u0027) ?\n  data._subhead_widthPt : null;\n  const dy \u003d drawSubheadIfAny(slide, layout, \u0027imageTextSlide\u0027, data.subhead, subheadWidthPt);\n  let imageUrl \u003d \u0027\u0027;\n  let imageInfo \u003d null;\n  const imageData \u003d data.image;\n  if (typeof imageData \u003d\u003d\u003d \u0027string\u0027) {\n    imageUrl \u003d imageData;\n  } else if (imageData \u0026\u0026 typeof imageData \u003d\u003d\u003d \u0027object\u0027) {\n    imageUrl \u003d imageData.data || \u0027\u0027;\n    imageInfo \u003d imageData.info || null;\n  }\n  const imageCaption \u003d data.imageCaption || \u0027\u0027;\n  const points \u003d Array.isArray(data.points) ? data.points : [];\n  const imagePosition \u003d data.imagePosition \u003d\u003d\u003d \u0027right\u0027 ? \u0027right\u0027 : \u0027left\u0027;\n  if (imagePosition \u003d\u003d\u003d \u0027left\u0027) {\n    const textArea \u003d offsetRect(layout.getRect(\u0027imageTextSlide.rightText\u0027), 0, dy);\n    if (imageUrl) {\n      let newMaxWidthPt;\n      let newMaxHeightPt;\n      if (imageInfo \u003d\u003d\u003d \u0027chart\u0027) {\n        newMaxWidthPt \u003d layout.pxToPt(400);\n        newMaxHeightPt \u003d layout.pxToPt(400);\n      } else {\n        newMaxWidthPt \u003d layout.pxToPt(400);\n        newMaxHeightPt \u003d layout.pxToPt(300);\n      }\n      renderImageMirrored(\n        slide, \n        layout, \n        textArea,\n        imageUrl, \n        newMaxWidthPt, \n        newMaxHeightPt, \n        imageUpdateOption\n      );\n    }\n    if (points.length \u003e 0) { \n      createContentCushion(slide, textArea, settings, layout);\n      const padding \u003d layout.pxToPt(20);\n      const textRect \u003d { \n        left: textArea.left + padding,\n        top: textArea.top + padding,\n        width: textArea.width - (padding * 2),\n        height: textArea.height - (padding * 2)\n      };\n      const textShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, textRect.left, textRect.top, textRect.width, textRect.height);  \n      setBulletsWithInlineStyles(textShape, points);\n      try {\n        setBoldTextSize(textShape, 16);\n      } catch(e) {\n      }\n      try {\n        adjustShapeText_External(textShape);\n      } catch(e) {\n      }\n      try {\n        setParenthesizedTextSize(textShape, 10);\n      } catch(e) {\n      }\n      try {\n        textShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n      } catch(e) {\n      }\n    }\n  } else {\n    const textArea \u003d offsetRect(layout.getRect(\u0027imageTextSlide.leftText\u0027), 0, dy);\n    const imageArea \u003d offsetRect(layout.getRect(\u0027imageTextSlide.rightImage\u0027), 0, dy);\n    if (points.length \u003e 0) { \n      createContentCushion(slide, textArea, settings, layout);\n      const padding \u003d layout.pxToPt(20);\n      const textRect \u003d { \n        left: textArea.left + padding,\n        top: textArea.top + padding,\n        width: textArea.width - (padding * 2),\n        height: textArea.height - (padding * 2)\n      };\n      const textShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, textRect.left, textRect.top, textRect.width, textRect.height); \n      setBulletsWithInlineStyles(textShape, points); \n      try {\n      setBoldTextSize(textShape, 16);\n      } catch(e) {\n      }\n      try {\n        adjustShapeText_External(textShape);\n      } catch(e) {\n      }\n      try {\n      setParenthesizedTextSize(textShape, 10);\n      } catch(e) {\n      }\n      try {\n      textShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n      } catch(e) {\n      }\n    }\n    if (imageUrl) { \n      let newMaxWidthPt;\n      let newMaxHeightPt;\n      if (imageInfo \u003d\u003d\u003d \u0027chart\u0027) {\n        newMaxWidthPt \u003d layout.pxToPt(400);\n        newMaxHeightPt \u003d layout.pxToPt(400);\n      } else {\n        newMaxWidthPt \u003d layout.pxToPt(400);\n        newMaxHeightPt \u003d layout.pxToPt(300);\n      }\n      renderImageMirrored(\n        slide, \n        layout, \n        textArea,\n        imageUrl, \n        newMaxWidthPt, \n        newMaxHeightPt, \n        imageUpdateOption\n      );\n    }\n  }\n  drawBottomBarAndFooter(slide, layout, pageNum, settings);\n}\nfunction createFullImageSlide(slide, data, layout, pageNum, settings, imageUpdateOption \u003d \u0027update\u0027) {\n  let imageUrl \u003d \u0027\u0027;\n  if (typeof data.image \u003d\u003d\u003d \u0027string\u0027) {\n    imageUrl \u003d data.image;\n  } else if (data.image \u0026\u0026 data.image.data) {\n    imageUrl \u003d data.image.data;\n  }\n  if (imageUpdateOption \u003d\u003d\u003d \u0027update\u0027 \u0026\u0026 imageUrl) {\n    try {\n      const imageBlob \u003d insertImageFromUrlOrFileId(imageUrl);\n      if (imageBlob) {\n        const img \u003d slide.insertImage(imageBlob);\n        const pageWidthPt \u003d layout.pageW_pt;\n        const pageHeightPt \u003d layout.pageH_pt; \n        img.setLeft(0)\n           .setTop(0)\n           .setWidth(pageWidthPt)\n           .setHeight(pageHeightPt);\n      }\n    } catch (e) {\n    }\n  }\n}\nfunction insertSlideAt(presentationId, index, singleSlideDataString, settings) {\n  if (!presentationId || index \u003d\u003d null || !singleSlideDataString) {\n    return { status: \u0027error\u0027, message: \u0027パラメータが不足しています。\u0027 };\n  }\n  try {\n    const presentation \u003d SlidesApp.openById(presentationId);\n    const slide \u003d presentation.insertSlide(index, SlidesApp.PredefinedLayout.BLANK);\n    updateDynamicColors(settings);\n    CONFIG.COLORS.primary_color \u003d settings.primaryColor || CONFIG.COLORS.primary_color;\n    CONFIG.COLORS.text_primary \u003d settings.largeFontColor || \u0027#333333\u0027;\n    CONFIG.COLORS.text_small_font \u003d settings.smallFontColor || \u0027#1F2937\u0027;\n    if (settings.backgroundColor \u0026\u0026 settings.backgroundColor.toUpperCase() !\u003d\u003d \u0027#FFFFFF\u0027) {\n      CONFIG.COLORS.background_white \u003d settings.backgroundColor;\n    } else {\n      CONFIG.COLORS.background_white \u003d \u0027#FFFFFF\u0027;\n    }\n    CONFIG.FOOTER_TEXT \u003d settings.footerText;\n    CONFIG.FONTS.family \u003d settings.fontFamily || CONFIG.FONTS.family;\n    CONFIG.LOGOS.header \u003d settings.headerLogoUrl;\n    CONFIG.LOGOS.closing \u003d settings.closingLogoUrl;\n    CONFIG.BACKGROUND_IMAGES.title \u003d settings.titleBgUrl;\n    CONFIG.BACKGROUND_IMAGES.closing \u003d settings.closingBgUrl;\n    CONFIG.BACKGROUND_IMAGES.section \u003d settings.sectionBgUrl;\n    CONFIG.BACKGROUND_IMAGES.main \u003d settings.mainBgUrl;\n    __CREDIT_IMAGE_BLOB \u003d null;\n    if (settings.creditImageBase64) {\n        try {\n            const parts \u003d settings.creditImageBase64.split(\u0027,\u0027);\n            const mimeType \u003d parts[0].match(/:(.*?);/)[1];\n            const decodedData \u003d Utilities.base64Decode(parts[1]);\n            __CREDIT_IMAGE_BLOB \u003d Utilities.newBlob(decodedData, mimeType, \u0027credit.png\u0027);\n        } catch(e) {}\n    }\n    const layout \u003d createLayoutManager(presentation.getPageWidth(), presentation.getPageHeight());\n    const data \u003d JSON.parse(singleSlideDataString);\n    const generator \u003d slideGenerators[data.type];\n    if (generator) {\n      generator(slide, data, layout, index + 1, settings, \u0027update\u0027);\n    }\n    if (data.notes) {\n        const cleanedNotes \u003d cleanSpeakerNotes(data.notes);\n        slide.getNotesPage().getSpeakerNotesShape().getText().setText(cleanedNotes);\n    }\n    addToUserHistory(presentationId);\n    return { status: \u0027success\u0027, message: \u0027スライドを追加しました。\u0027 };\n  } catch (e) {\n    return { status: \u0027error\u0027, message: e.message };\n  }\n}\nfunction renderSingleImageInArea(slide, layout, area, imageUrl, caption \u003d \u0027\u0027, position \u003d \u0027left\u0027, imageInfo \u003d null, imageUpdateOption \u003d \u0027update\u0027) {\n  if (!imageUrl) return;\n  if (imageUpdateOption !\u003d\u003d \u0027update\u0027) {\n    return null;\n  }\n  try {\n    const imageData \u003d insertImageFromUrlOrFileId(imageUrl);\n    if (!imageData) return null;\n    const img \u003d slide.insertImage(imageData);\n    if (imageInfo \u003d\u003d\u003d \u0027chart\u0027) {\n      const imgAspect \u003d img.getWidth() / img.getHeight();\n      const baseTop \u003d area.top;\n      const baseCenterX \u003d area.left + area.width / 2;\n      const newBottom \u003d layout.pageH_pt - layout.pxToPt(5);\n      const newH \u003d newBottom - baseTop;\n      const newW \u003d newH * imgAspect;\n      const newLeft \u003d baseCenterX - (newW / 2);\n      img.setWidth(newW).setHeight(newH)\n         .setLeft(newLeft)\n         .setTop(baseTop);\n    } else if (imageInfo \u003d\u003d\u003d \u0027svg_code\u0027) {\n      const scaleFactor \u003d 0.85; \n      const scale \u003d Math.min(area.width / img.getWidth(), area.height / img.getHeight()) * scaleFactor;\n      const w \u003d img.getWidth() * scale;\n      const h \u003d img.getHeight() * scale;\n      img.setWidth(w).setHeight(h)\n         .setLeft(area.left + (area.width - w) / 2)\n         .setTop(area.top + (area.height - h) / 2);\n    } else {\n      const scale \u003d Math.min(area.width / img.getWidth(), area.height / img.getHeight());\n      const w \u003d img.getWidth() * scale;\n      const h \u003d img.getHeight() * scale;\n      img.setWidth(w).setHeight(h)\n         .setLeft(area.left + (area.width - w) / 2)\n         .setTop(area.top + (area.height - h) / 2);\n    }\n    if (caption \u0026\u0026 caption.trim()) { \n      const imgHeight \u003d img.getHeight();\n      const imgTop \u003d img.getTop();\n      const imageBottom \u003d imgTop + imgHeight;\n      const captionMargin \u003d layout.pxToPt(8);\n      const captionHeight \u003d layout.pxToPt(30);\n      let captionRect;\n      if (imageInfo \u003d\u003d\u003d \u0027chart\u0027) {\n        let captionTop \u003d imageBottom + captionMargin;\n        if ((captionTop + captionHeight) \u003e layout.pageH_pt) {\n          captionTop \u003d layout.pageH_pt - captionHeight - layout.pxToPt(2);\n        }\n        captionRect \u003d { left: img.getLeft(), top: captionTop, width: img.getWidth(), height: captionHeight };\n      } else {\n        const rectPath \u003d `imageTextSlide.${position}ImageCaption`;\n        captionRect \u003d layout.getRect(rectPath);\n      }\n      const captionShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, \n        captionRect.left, captionRect.top, captionRect.width, captionRect.height);\n      captionShape.getFill().setTransparent();\n      captionShape.getBorder().setTransparent();\n      setStyledText(captionShape, caption.trim(), {\n        size: CONFIG.FONTS.sizes.small,\n        color: CONFIG.COLORS.neutral_gray,\n        align: SlidesApp.ParagraphAlignment.CENTER\n      });\n      try {\n        captionShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n      } catch (e) {}\n    }\n    return img;\n  } catch (e) {\n    return null;\n  }\n}\nfunction renderImageMirrored(slide, layout, textAreaRect, imageUrl, maxWidthPt, maxHeightPt, imageUpdateOption) {\n  if (imageUpdateOption !\u003d\u003d \u0027update\u0027) {\n    return null;\n  }\n  if (!imageUrl) {\n    return null;\n  }\n  if (!textAreaRect || !maxWidthPt || !maxHeightPt) {\n    return null;\n  }\n  try {\n    const pageCenterX \u003d layout.pageW_pt / 2;\n    const textCenterX \u003d textAreaRect.left + textAreaRect.width / 2;\n    const textCenterY \u003d textAreaRect.top + textAreaRect.height / 2;\n    const mirroredCenterX \u003d pageCenterX + (pageCenterX - textCenterX);\n    const mirroredCenterY \u003d textCenterY;\n    const imageData \u003d insertImageFromUrlOrFileId(imageUrl);\n    if (!imageData) return null;\n    const img \u003d slide.insertImage(imageData);\n    const scale \u003d Math.min(maxWidthPt / img.getWidth(), maxHeightPt / img.getHeight());\n    const w \u003d img.getWidth() * scale;\n    const h \u003d img.getHeight() * scale;\n    const finalLeft \u003d mirroredCenterX - (w / 2);\n    const finalTop \u003d mirroredCenterY - (h / 2);\n    img.setWidth(w).setHeight(h)\n       .setLeft(finalLeft)\n       .setTop(finalTop);\n    return img;\n  } catch (e) {\n    return null;\n  }\n}\nfunction estimateTextWidthPt(text, fontSizePt) {\n  const multipliers \u003d {\n    space: 0.3,\n    ascii: 0.62,\n    uppercase: 0.8,\n    japanese: 1.0,\n    other: 0.85\n  };\n  const totalMultiplier \u003d String(text || \u0027\u0027).split(\u0027\u0027).reduce((acc, char) \u003d\u003e {\n    if (char \u003d\u003d\u003d \u0027 \u0027) {\n      return acc + multipliers.space;\n    }\n    else if (char \u003d\u003d\u003d \u0027I\u0027 || char \u003d\u003d\u003d \u0027i\u0027) {\n      return acc + multipliers.space;\n    }\n    else if (char.match(/[A-HJ-Z]/)) {\n      return acc + multipliers.uppercase;\n    }\n    else if (char.match(/[ -~]/)) {\n      return acc + multipliers.ascii;\n    }\n    else if (char.match(/[\\u3000-\\u303F\\u3040-\\u309F\\u30A0-\\uFF00-\\uFFEF]/)) {\n      return acc + multipliers.japanese;\n    }\n    else if (char.match(/[\\u4E00-\\u9FAF]/)) {\n        return acc + multipliers.japanese;\n    }\n    else {\n      return acc + multipliers.other;\n    }\n  }, 0);\n  const calculatedWidth \u003d totalMultiplier * fontSizePt;\n  return calculatedWidth + 10;\n}\nfunction offsetRect(rect, dx, dy) {\n  return {\n    left: rect.left + (dx || 0),\n    top: rect.top + (dy || 0),\n    width: rect.width,\n    height: rect.height\n  };\n}\nfunction drawStandardTitleHeader(slide, layout, key, title, settings, preCalculatedWidthPt \u003d null, imageUpdateOption \u003d \u0027update\u0027) {\n  if (imageUpdateOption \u003d\u003d\u003d \u0027update\u0027) {\n    const logoRect \u003d safeGetRect(layout, `${key}.headerLogo`);\n    try {\n      if (CONFIG.LOGOS.header \u0026\u0026 logoRect) {\n        if (__CACHED_HEADER_LOGO_GROUP) {\n          try {\n            const copiedGroup \u003d slide.insertGroup(__CACHED_HEADER_LOGO_GROUP);\n            copiedGroup.setLeft(logoRect.left).setTop(logoRect.top);\n          } catch(e) {\n            __CACHED_HEADER_LOGO_GROUP \u003d null;\n          }\n        }\n        if (!__CACHED_HEADER_LOGO_GROUP) {\n          const imageData \u003d insertImageFromUrlOrFileId(CONFIG.LOGOS.header);\n          if (imageData) {\n            const logo \u003d slide.insertImage(imageData);\n            const asp \u003d logo.getHeight() / logo.getWidth();\n            logo.setWidth(logoRect.width).setHeight(logoRect.width * asp);\n            logo.setLeft(logoRect.left).setTop(logoRect.top);\n            const group \u003d slide.group([logo]);\n            __CACHED_HEADER_LOGO_GROUP \u003d group;\n          }\n        }\n      }\n    } catch (e) {\n    }\n  }\n  const titleRect \u003d safeGetRect(layout, `${key}.title`);\n  if (!titleRect) {\n    return;\n  }\n  const initialFontSize \u003d CONFIG.FONTS.sizes.contentTitle;\n  const optimalHeight \u003d layout.pxToPt(initialFontSize + 8);\n  const cmToPt \u003d 28.3465;\n  const verticalShiftPt \u003d 0.3 * cmToPt;\n  const adjustedTop \u003d titleRect.top + verticalShiftPt;\n  const titleShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX,\n    titleRect.left,\n    adjustedTop,\n    titleRect.width,\n    optimalHeight\n  );\n  setStyledText(titleShape, title || \u0027\u0027, {\n    size: initialFontSize,\n    bold: true,\n    fontType: \u0027large\u0027\n  });\n  try {\n    titleShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n  } catch (e) {}\n  let finalFontSize \u003d initialFontSize;\n  let adjustmentLogResult \u003d \u0027\u0027;\n  try {\n    const adjustmentResult \u003d adjustShapeText_External(titleShape, preCalculatedWidthPt);\n    adjustmentLogResult \u003d adjustmentResult.log;\n    if (adjustmentResult.finalSize !\u003d\u003d null) {\n      finalFontSize \u003d adjustmentResult.finalSize;\n    }\n  } catch (e) {\n  }\n  if (settings.showTitleUnderline \u0026\u0026 title) {\n    const uRect \u003d safeGetRect(layout, `${key}.titleUnderline`);\n    if (!uRect) {\n      return;\n    }\n    let underlineWidthPt;\n    if (finalFontSize \u003c initialFontSize \u0026\u0026 finalFontSize \u003e\u003d 10 \u0026\u0026 preCalculatedWidthPt !\u003d\u003d null \u0026\u0026 preCalculatedWidthPt \u003e 0 \u0026\u0026 initialFontSize \u003e 0) {\n        underlineWidthPt \u003d preCalculatedWidthPt * (finalFontSize / initialFontSize);\n    }\n    else if (preCalculatedWidthPt !\u003d\u003d null \u0026\u0026 preCalculatedWidthPt \u003e 0) {\n      underlineWidthPt \u003d preCalculatedWidthPt;\n    }\n    else {\n      underlineWidthPt \u003d estimateTextWidthPt(title, initialFontSize);\n    }\n    const desiredWidthPt \u003d underlineWidthPt + 10;\n    const maxUnderlineWidth \u003d layout.pageW_pt - uRect.left - layout.pxToPt(25);\n    const finalWidth \u003d Math.min(desiredWidthPt, maxUnderlineWidth);\n    createPillShapeUnderline(slide, uRect.left, uRect.top, finalWidth, uRect.height, settings);\n  }\n}\nfunction estimateTextHeightPt(text, widthPt, fontSizePt, lineHeight) {\n  var paragraphs \u003d String(text).split(/\\r?\\n/);\n  var charsPerLine \u003d Math.max(1, Math.floor(widthPt / (fontSizePt * 0.95)));\n  var lines \u003d 0;\n  for (var i \u003d 0; i \u003c paragraphs.length; i++) {\n    var s \u003d paragraphs[i].replace(/\\s+/g, \u0027 \u0027).trim();\n    var len \u003d s.length || 1;\n    lines +\u003d Math.ceil(len / charsPerLine);\n  }\n  var lineH \u003d fontSizePt * (lineHeight || 1.2);\n  return Math.max(lineH, lines * lineH);\n}\nfunction drawSubheadIfAny(slide, layout, key, subhead, preCalculatedWidthPt \u003d null) {\n  if (!subhead) return 0;\n  subhead \u003d String(subhead).replace(/[\\r\\n]+/g, \u0027\u0027);\n  const rect \u003d safeGetRect(layout, `${key}.subhead`);\n  if (!rect) {\n    return 0;\n  }\n  const box \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, rect.left, rect.top, rect.width, rect.height);\n  setStyledText(box, subhead, {\n    size: CONFIG.FONTS.sizes.subhead,\n    //color: CONFIG.COLORS.text_primary\n    fontType: \u0027large\u0027\n  });\n  try {\n    const adjustmentResult \u003d adjustShapeText_External(box, preCalculatedWidthPt);\n  } catch (e) {\n  }\n  return layout.pxToPt(36);\n}\nfunction drawBottomBar(slide, layout, settings) {\n  const barRect \u003d layout.getRect(\u0027bottomBar\u0027);\n  if (settings.enableGradient) {\n    if (__CACHED_GRADIENT_BOTTOM_BAR) {\n      try {\n        const copiedGroup \u003d slide.insertGroup(__CACHED_GRADIENT_BOTTOM_BAR);\n        copiedGroup.setLeft(barRect.left).setTop(barRect.top);\n        return;\n      } catch (e) {\n        __CACHED_GRADIENT_BOTTOM_BAR \u003d null;\n      }\n    }\n    const group \u003d createGradientRectangle(slide, barRect.left, barRect.top, barRect.width, barRect.height, [settings.gradientStart, settings.gradientEnd]);\n    if (group) {\n      __CACHED_GRADIENT_BOTTOM_BAR \u003d group;\n    }\n  } else {\n    applyFill(slide, barRect.left, barRect.top, barRect.width, barRect.height, settings);\n  }\n}\nfunction addCucFooter(slide, layout, pageNum, settings) {\n  if (CONFIG.FOOTER_TEXT \u0026\u0026 CONFIG.FOOTER_TEXT.trim() !\u003d\u003d \u0027\u0027) {\n    const leftRect \u003d layout.getRect(\u0027footer.leftText\u0027);\n    const leftShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, leftRect.left, leftRect.top, leftRect.width, leftRect.height);\n  leftShape.getText().setText(CONFIG.FOOTER_TEXT);\n  applyTextStyle(leftShape.getText(), {\n      size: CONFIG.FONTS.sizes.footer,\n      //color: CONFIG.COLORS.text_primary\n      fontType: \u0027large\u0027\n    });\n    try {\n      leftShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n    } catch(e) {}\n  }\n  if (__CREDIT_IMAGE_BLOB) {\n    drawCreditImage(slide, layout, __CREDIT_IMAGE_BLOB, CREDIT_IMAGE_LINK);\n  }\n  if (pageNum \u003e 0 \u0026\u0026 settings \u0026\u0026 settings.showPageNumber) { \n    const rightRect \u003d layout.getRect(\u0027footer.rightPage\u0027);\n    const rightShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, rightRect.left, rightRect.top, rightRect.width, rightRect.height);\n    rightShape.getText().setText(String(pageNum)); \n    applyTextStyle(rightShape.getText(), {\n      size: CONFIG.FONTS.sizes.footer,\n      color: CONFIG.COLORS.primary_color,\n      align: SlidesApp.ParagraphAlignment.END\n    });\n    try {\n      rightShape.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE);\n    } catch(e) {}\n  }\n}\nfunction drawBottomBarAndFooter(slide, layout, pageNum, settings) {\n  if (settings.showBottomBar) {\n    drawBottomBar(slide, layout, settings);\n  }\n  addCucFooter(slide, layout, pageNum, settings);\n}\nfunction applyTextStyle(textRange, opt) {\n  const style \u003d textRange.getTextStyle();\n  let defaultColor;\n  if (opt.fontType \u003d\u003d\u003d \u0027large\u0027) {\n    defaultColor \u003d CONFIG.COLORS.text_primary;\n  } else {\n    defaultColor \u003d CONFIG.COLORS.text_small_font;\n  }\n  style.setFontFamily(CONFIG.FONTS.family)\n       .setForegroundColor(opt.color || defaultColor)\n       .setFontSize(opt.size || CONFIG.FONTS.sizes.body)\n       .setBold(opt.bold || false);\n  if (opt.align) {\n    try {\n      textRange.getParagraphs().forEach(p \u003d\u003e {\n        p.getRange().getParagraphStyle().setParagraphAlignment(opt.align);\n      });\n    } catch (e) {}\n  }\n}\nfunction setStyledText(shapeOrCell, rawText, baseOpt) {\n  const parsed \u003d parseInlineStyles(rawText || \u0027\u0027);\n  const tr \u003d shapeOrCell.getText().setText(parsed.output);\n  applyTextStyle(tr, baseOpt || {});\n  applyStyleRanges(tr, parsed.ranges);\n}\nfunction setBulletsWithInlineStyles(shape, points) {\n  const joiner \u003d \u0027\\n\\n\u0027;\n  let combined \u003d \u0027\u0027;\n  const ranges \u003d [];\n  (points || []).forEach((pt, idx) \u003d\u003e {\n    const parsed \u003d parseInlineStyles(String(pt || \u0027\u0027));\n    const bullet \u003d parsed.output;\n    if (idx \u003e 0) combined +\u003d joiner;\n    const start \u003d combined.length;\n    combined +\u003d bullet;\n    parsed.ranges.forEach(r \u003d\u003e ranges.push({\n      start: start + r.start,\n      end: start + r.end,\n      bold: r.bold,\n      color: r.color\n    }));\n  });\n  const tr \u003d shape.getText().setText(combined || \u0027—\u0027);\n  applyTextStyle(tr, {\n    size: CONFIG.FONTS.sizes.body\n  });\n  try {\n    tr.getParagraphs().forEach(p \u003d\u003e {\n      p.getRange().getParagraphStyle().setLineSpacing(100).setSpaceBelow(6);\n    });\n  } catch (e) {}\n  applyStyleRanges(tr, ranges);\n}\nfunction checkSpacing(s, out, i, nextCharIndex) {\n  let prefix \u003d \u0027\u0027;\n  let suffix \u003d \u0027\u0027;\n  if (out.length \u003e 0 \u0026\u0026 !/\\s$/.test(out)) {\n    prefix \u003d \u0027 \u0027;\n  }\n  if (nextCharIndex \u003c s.length \u0026\u0026 !/^\\s/.test(s[nextCharIndex])) {\n    suffix \u003d \u0027 \u0027;\n  }\n  return { prefix, suffix };\n}\nfunction parseInlineStyles(s) {\n  const ranges \u003d [];\n  let out \u003d \u0027\u0027;\n  let i \u003d 0;\n  while (i \u003c s.length) {\n    if (s[i] \u003d\u003d\u003d \u0027*\u0027 \u0026\u0026 s[i + 1] \u003d\u003d\u003d \u0027*\u0027 \u0026\u0026 \n        s[i + 2] \u003d\u003d\u003d \u0027[\u0027 \u0026\u0026 s[i + 3] \u003d\u003d\u003d \u0027[\u0027) {\n      const contentStart \u003d i + 4;\n      const close \u003d s.indexOf(\u0027]]**\u0027, contentStart);\n      if (close !\u003d\u003d -1) {\n        let content \u003d s.substring(contentStart, close);\n        const nextCharIndex \u003d close + 4;\n        const { prefix, suffix } \u003d checkSpacing(s, out, i, nextCharIndex);\n        out +\u003d prefix;\n        const start \u003d out.length;\n        content +\u003d suffix;\n        out +\u003d content;\n        const end \u003d out.length - suffix.length;\n        const rangeObj \u003d {\n          start,\n          end,\n          bold: true,\n          color: CONFIG.COLORS.primary_color,\n        };\n        ranges.push(rangeObj);\n        i \u003d nextCharIndex;\n        continue;\n      }\n    }\n    if (s[i] \u003d\u003d\u003d \u0027[\u0027 \u0026\u0026 s[i + 1] \u003d\u003d\u003d \u0027[\u0027) {\n      const close \u003d s.indexOf(\u0027]]\u0027, i + 2);\n      if (close !\u003d\u003d -1) {\n        let content \u003d s.substring(i + 2, close);\n        const nextCharIndex \u003d close + 2;\n        const { prefix, suffix } \u003d checkSpacing(s, out, i, nextCharIndex);\n        out +\u003d prefix;\n        const start \u003d out.length;\n        content +\u003d suffix;\n        out +\u003d content;\n        const end \u003d out.length - suffix.length;\n        const rangeObj \u003d {\n          start,\n          end,\n          bold: true,\n          color: CONFIG.COLORS.primary_color,\n        };\n        ranges.push(rangeObj);\n        i \u003d nextCharIndex;\n        continue;\n      }\n    }\n    if (s[i] \u003d\u003d\u003d \u0027*\u0027 \u0026\u0026 s[i + 1] \u003d\u003d\u003d \u0027*\u0027) {\n      const close \u003d s.indexOf(\u0027**\u0027, i + 2);\n      if (close !\u003d\u003d -1) {\n        let content \u003d s.substring(i + 2, close);\n        if (content.indexOf(\u0027[[\u0027) \u003d\u003d\u003d -1) {\n          const nextCharIndex \u003d close + 2;\n          const { prefix, suffix } \u003d checkSpacing(s, out, i, nextCharIndex);\n          out +\u003d prefix;\n          const start \u003d out.length;\n          content +\u003d suffix;\n          out +\u003d content;\n          const end \u003d out.length - suffix.length;\n          ranges.push({\n            start,\n            end,\n            bold: true,\n          });\n          i \u003d nextCharIndex;\n          continue;\n        } else {\n          i +\u003d 2;\n          continue;\n        }\n      }\n    }\n    out +\u003d s[i];\n    i++;\n  }\n  return {\n    output: out,\n    ranges\n  };\n}\nfunction cleanSpeakerNotes(notesText) {\n  if (!notesText) return \u0027\u0027;\n  let cleaned \u003d notesText;\n  cleaned \u003d cleaned.replace(/\\*\\*([^*]+)\\*\\*/g, \u0027$1\u0027);\n  cleaned \u003d cleaned.replace(/\\[\\[([^\\]]+)\\]\\]/g, \u0027$1\u0027);\n  cleaned \u003d cleaned.replace(/\\*([^*]+)\\*/g, \u0027$1\u0027);\n  cleaned \u003d cleaned.replace(/_([^_]+)_/g, \u0027$1\u0027);\n  cleaned \u003d cleaned.replace(/~~([^~]+)~~/g, \u0027$1\u0027);\n  cleaned \u003d cleaned.replace(/`([^`]+)`/g, \u0027$1\u0027);\n  return cleaned;\n}\nfunction applyStyleRanges(textRange, ranges) {\n  ranges.forEach(r \u003d\u003e {\n    try {\n      const sub \u003d textRange.getRange(r.start, r.end);\n      if (!sub) return;\n      const st \u003d sub.getTextStyle();\n      if (r.bold) st.setBold(true);\n      if (r.color) st.setForegroundColor(r.color);\n      if (r.size) st.setFontSize(r.size);\n    } catch (e) {}\n  });\n}\nfunction isAgendaTitle(title) {\n  return /(agenda|アジェンダ|目次|本日お伝えすること)/i.test(String(title || \u0027\u0027));\n}\nfunction buildAgendaFromSlideData() {\n  return __SLIDE_DATA_FOR_AGENDA.filter(d \u003d\u003e d \u0026\u0026 d.type \u003d\u003d\u003d \u0027section\u0027 \u0026\u0026 d.title).map(d \u003d\u003e d.title.trim());\n}\nfunction drawCompareBox(slide, layout, left, top, width, height, title, items, settings, isLeft \u003d false) {\n  const box \u003d slide.insertShape(SlidesApp.ShapeType.RECTANGLE, left, top, width, height);\n  box.getFill().setSolidFill(CONFIG.COLORS.background_gray);\n  box.getBorder().getLineFill().setSolidFill(CONFIG.COLORS.lane_border);\n  const th \u003d layout.pxToPt(40);\n  const titleBarBg \u003d slide.insertShape(SlidesApp.ShapeType.RECTANGLE, left, top, width, th);\n  const compareColors \u003d generateCompareColors(settings.primaryColor);\n  const headerColor \u003d isLeft ? compareColors.left : compareColors.right;\n  titleBarBg.getFill().setSolidFill(headerColor);\n  titleBarBg.getBorder().getLineFill().setSolidFill(headerColor);\n  const titleTextShape \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, left, top, width, th);\n  titleTextShape.getFill().setTransparent();\n  titleTextShape.getBorder().setTransparent();\n  setStyledText(titleTextShape, title, {\n    size: CONFIG.FONTS.sizes.laneTitle,\n    bold: true,\n    color: CONFIG.COLORS.background_gray,\n    align: SlidesApp.ParagraphAlignment.CENTER\n  });\n  const pad \u003d layout.pxToPt(12);\n  const body \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX,\n    left + pad,\n    top + th + pad,\n    width - pad * 2,\n    height - th - pad * 2\n  );\n  setBulletsWithInlineStyles(body, items);\n  try {\n    const adjustmentLog \u003d adjustShapeText_External(body, null); \n  } catch(e) {\n  }\n}\nfunction drawArrowBetweenRects(slide, a, b, arrowH, arrowGap, settings) {\n  const fromX \u003d a.left + a.width;\n  const fromY \u003d a.top + a.height / 2;\n  const toX \u003d b.left;\n  const toY \u003d b.top + b.height / 2;\n  if (toX - fromX \u003c\u003d 0) return;\n  const line \u003d slide.insertLine(SlidesApp.LineCategory.STRAIGHT, fromX, fromY, toX, toY);\n  line.getLineFill().setSolidFill(settings.primaryColor);\n  line.setWeight(1.5);\n  line.setEndArrow(SlidesApp.ArrowStyle.FILL_ARROW);\n}\nfunction drawNumberedItems(slide, layout, area, items, settings) {\n  createContentCushion(slide, area, settings, layout);\n  const n \u003d Math.max(1, items.length);\n  const topPadding \u003d layout.pxToPt(30);\n  const bottomPadding \u003d layout.pxToPt(10);\n  const drawableHeight \u003d area.height - topPadding - bottomPadding;\n  const gapY \u003d drawableHeight / Math.max(1, n - 1);\n  const cx \u003d area.left + layout.pxToPt(44);\n  const top0 \u003d area.top + topPadding;\n  const line \u003d slide.insertShape(SlidesApp.ShapeType.RECTANGLE, cx - layout.pxToPt(1), top0 + layout.pxToPt(6), layout.pxToPt(2), gapY * (n - 1));\n  line.getFill().setSolidFill(CONFIG.COLORS.faint_gray);\n  line.getBorder().setTransparent();\n  for (let i \u003d 0; i \u003c n; i++) {\n    const cy \u003d top0 + gapY * i;\n    const sz \u003d layout.pxToPt(28);\n    const numBox \u003d slide.insertShape(SlidesApp.ShapeType.RECTANGLE, cx - sz/2, cy - sz/2, sz, sz);\n    numBox.getFill().setSolidFill(settings.primaryColor);\n    numBox.getBorder().setTransparent();\n    const num \u003d numBox.getText(); num.setText(String(i + 1));\n    applyTextStyle(num, { size: 12, bold: true, color: CONFIG.COLORS.background_white, align: SlidesApp.ParagraphAlignment.CENTER });\n    let cleanText \u003d String(items[i] || \u0027\u0027);\n    cleanText \u003d cleanText.replace(/^\\s*\\d+(\\.\\s*|\\s+)/, \u0027\u0027);\n    const txt \u003d slide.insertShape(SlidesApp.ShapeType.TEXT_BOX, cx + layout.pxToPt(28), cy - layout.pxToPt(16), area.width - layout.pxToPt(70), layout.pxToPt(32));\n    setStyledText(txt, cleanText, { size: CONFIG.FONTS.sizes.processStep });\n    try { txt.setContentAlignment(SlidesApp.ContentAlignment.MIDDLE); } catch(e){}\n  }\n}\nfunction setBoldTextSize(shapeOrTextRange, size \u003d 16) {\n  let textRange;\n  try {\n    if (shapeOrTextRange \u0026\u0026 typeof shapeOrTextRange.getText \u003d\u003d\u003d \u0027function\u0027) {\n      textRange \u003d shapeOrTextRange.getText();\n    } else if (shapeOrTextRange \u0026\u0026 typeof shapeOrTextRange.getRuns \u003d\u003d\u003d \u0027function\u0027) {\n      textRange \u003d shapeOrTextRange;\n    } else {\n      return;\n    }\n    if (!textRange || textRange.isEmpty()) {\n      return;\n    }\n    const runs \u003d textRange.getRuns();\n    runs.forEach(run \u003d\u003e {\n      const style \u003d run.getTextStyle();\n      if (style.isBold()) {\n        style.setFontSize(size);\n      }\n    });\n  } catch (e) {\n  }\n}\nfunction setParenthesizedTextSize(shapeOrTextRange, size) {\n  let textRange;\n  try {\n    if (shapeOrTextRange \u0026\u0026 typeof shapeOrTextRange.getText \u003d\u003d\u003d \u0027function\u0027) {\n      textRange \u003d shapeOrTextRange.getText();\n    } else if (shapeOrTextRange \u0026\u0026 typeof shapeOrTextRange.getRuns \u003d\u003d\u003d \u0027function\u0027) {\n      textRange \u003d shapeOrTextRange;\n    } else {\n      return;\n    }\n    if (!textRange || textRange.isEmpty()) {\n      return;\n    }\n    const fullText \u003d textRange.asString();\n    const matches \u003d [];\n    const regex \u003d /(\\(|（)([^()（）]+)(\\)|）)/g;\n    let match;\n    while ((match \u003d regex.exec(fullText)) !\u003d\u003d null) {\n        matches.push(match);\n    }\n    for (let i \u003d matches.length - 1; i \u003e\u003d 0; i--) {\n        match \u003d matches[i];\n        const startIndex \u003d match.index;\n        const endIndex \u003d match.index + match[0].length;\n        const originalText \u003d match[0];\n        let newText \u003d originalText;\n        if (match[1] \u003d\u003d\u003d \u0027（\u0027) {\n            newText \u003d \u0027 (\u0027 + newText.substring(1);\n        }\n        if (match[3] \u003d\u003d\u003d \u0027）\u0027) {\n            newText \u003d newText.substring(0, newText.length - 1) + \u0027) \u0027;\n        }\n        if (startIndex \u003c endIndex) {\n            try {\n                const subRange \u003d textRange.getRange(startIndex, endIndex);\n                subRange.setText(newText);\n                const newEndIndex \u003d startIndex + newText.length;\n                const replacedRange \u003d textRange.getRange(startIndex, newEndIndex);\n                replacedRange.getTextStyle().setFontSize(size);\n            } catch (rangeError) {\n            }\n        }\n    }\n  } catch (e) {\n  }\n}\nfunction drawCreditImage(slide, layout, creditImageBlob, creditLink) {\n  try {\n    const creditPosPx \u003d CONFIG.POS_PX.footer.creditImage;\n    if (!creditPosPx || !creditImageBlob) return;\n    if (__CACHED_CREDIT_IMAGE_GROUP) {\n      try {\n        const copiedGroup \u003d slide.insertGroup(__CACHED_CREDIT_IMAGE_GROUP);\n        const newHeight \u003d layout.pxToPt(creditPosPx.height) * layout.scaleY;\n        const currentGroupWidth \u003d copiedGroup.getWidth();\n        const rightMarginPt \u003d layout.pxToPt(creditPosPx.right) * layout.scaleX;\n        const newLeft \u003d (layout.pageW_pt - rightMarginPt) - currentGroupWidth;\n        const topPt \u003d layout.pxToPt(creditPosPx.top) * layout.scaleY;\n        copiedGroup.setLeft(newLeft).setTop(topPt);\n        return;\n      } catch(e) {\n        __CACHED_CREDIT_IMAGE_GROUP \u003d null;\n      }\n    }\n    const img \u003d slide.insertImage(creditImageBlob);\n    const newHeight \u003d layout.pxToPt(creditPosPx.height) * layout.scaleY;\n    const aspect \u003d img.getWidth() / img.getHeight();\n    const newWidth \u003d newHeight * aspect;\n    const rightMarginPt \u003d layout.pxToPt(creditPosPx.right) * layout.scaleX;\n    const newLeft \u003d (layout.pageW_pt - rightMarginPt) - newWidth;\n    const topPt \u003d layout.pxToPt(creditPosPx.top) * layout.scaleY;\n    img.setLeft(newLeft)\n       .setTop(topPt)\n       .setWidth(newWidth)\n       .setHeight(newHeight)\n       .setLinkUrl(creditLink);\n    const group \u003d slide.group([img]);\n    __CACHED_CREDIT_IMAGE_GROUP \u003d group;\n  } catch (e) {\n  }\n}\nfunction safeGetRect(layout, path) {\n  try {\n    const rect \u003d layout.getRect(path);\n    if (rect \u0026\u0026 \n        (typeof rect.left \u003d\u003d\u003d \u0027number\u0027 || rect.left \u003d\u003d\u003d undefined) \u0026\u0026 \n        typeof rect.top \u003d\u003d\u003d \u0027number\u0027 \u0026\u0026 \n        typeof rect.width \u003d\u003d\u003d \u0027number\u0027 \u0026\u0026 \n        typeof rect.height \u003d\u003d\u003d \u0027number\u0027) {\n      if (rect.left \u003d\u003d\u003d undefined) {\n        return null;\n      }\n      return rect;\n    }\n    if (!path.includes(\u0027headerLogo\u0027)) {\n    }\n    return null;\n  } catch (e) {\n    if (!path.includes(\u0027headerLogo\u0027)) {\n    }\n    return null;\n  }\n}\nfunction findContentRect(layout, key) {\n  const candidates \u003d [\n    \u0027body\u0027,\n    \u0027area\u0027,\n    \u0027gridArea\u0027,\n    \u0027lanesArea\u0027,\n    \u0027pyramidArea\u0027,\n    \u0027stepArea\u0027,\n    \u0027singleRow\u0027,\n    \u0027twoColLeft\u0027,\n    \u0027leftBox\u0027,\n    \u0027leftText\u0027\n  ];\n  for (const name of candidates) {\n    const r \u003d safeGetRect(layout, `${key}.${name}`);\n    if (r \u0026\u0026 r.top !\u003d null) return r;\n  }\n  return null;\n}\nfunction adjustColorBrightness(hex, factor) {\n  const c \u003d hex.replace(\u0027#\u0027, \u0027\u0027);\n  const rgb \u003d parseInt(c, 16);\n  let r \u003d (rgb \u003e\u003e 16) \u0026 0xff,\n    g \u003d (rgb \u003e\u003e 8) \u0026 0xff,\n    b \u003d (rgb \u003e\u003e 0) \u0026 0xff;\n  r \u003d Math.min(255, Math.round(r * factor));\n  g \u003d Math.min(255, Math.round(g * factor));\n  b \u003d Math.min(255, Math.round(b * factor));\n  return \u0027#\u0027 + (0x1000000 + (r \u003c\u003c 16) + (g \u003c\u003c 8) + b).toString(16).slice(1);\n}\nfunction setMainSlideBackground(slide, layout, imageUpdateOption \u003d \u0027update\u0027) {\n  setBackgroundImageFromUrl(slide, layout, CONFIG.BACKGROUND_IMAGES.main, CONFIG.COLORS.background_white, imageUpdateOption);\n}\nfunction setBackgroundImageFromUrl(slide, layout, imageUrl, fallbackColor, imageUpdateOption \u003d \u0027update\u0027) {\n    slide.getBackground().setSolidFill(fallbackColor);\n  if (imageUpdateOption \u003d\u003d\u003d \u0027update\u0027) {\n    if (!imageUrl) return;\n    try {\n      const image \u003d insertImageFromUrlOrFileId(imageUrl);\n      if (!image) return;\n      slide.insertImage(image).setWidth(layout.pageW_pt).setHeight(layout.pageH_pt).setLeft(0).setTop(0).sendToBack();\n    } catch (e) {\n    }\n  }\n}\nfunction insertImageFromUrlOrFileId(urlOrFileId) {\n  if (!urlOrFileId) return null;\n  function extractFileIdFromUrl(url) {\n    const patterns \u003d [\n      /\\/file\\/d\\/([a-zA-Z0-9_-]+)/,\n      /id\u003d([a-zA-Z0-9_-]+).*file/,\n      /file\\/([a-zA-Z0-9_-]+)/\n    ];\n    for (const pattern of patterns) {\n      const match \u003d url.match(pattern);\n      if (match \u0026\u0026 match[1]) return match[1];\n    }\n    return null;\n  }\n  const fileIdPattern \u003d /^[a-zA-Z0-9_-]{25,}$/;\n  const extractedFileId \u003d extractFileIdFromUrl(urlOrFileId);\n  if (extractedFileId \u0026\u0026 fileIdPattern.test(extractedFileId)) {\n    try {\n      const file \u003d DriveApp.getFileById(extractedFileId);\n      return file.getBlob();\n    } catch (e) {\n      return null;\n    }\n  } else if (fileIdPattern.test(urlOrFileId)) {\n    try {\n      const file \u003d DriveApp.getFileById(urlOrFileId);\n      return file.getBlob();\n    } catch (e) {\n      return null;\n    }\n  } else if (urlOrFileId.startsWith(\u0027data:image/\u0027)) {\n    try {\n      const parts \u003d urlOrFileId.split(\u0027,\u0027);\n      if (parts.length !\u003d\u003d 2) throw new Error(\u0027Invalid Base64 format.\u0027);\n      const mimeType \u003d parts[0].match(/:(.*?);/)[1];\n      const base64Data \u003d parts[1];\n      const decodedData \u003d Utilities.base64Decode(base64Data);\n      return Utilities.newBlob(decodedData, mimeType);\n    } catch (e) {\n      return null;\n    }\n  } else {\n    return urlOrFileId;\n  }\n}\nfunction normalizeImages(arr) {\n  return (arr || []).map(v \u003d\u003e typeof v \u003d\u003d\u003d \u0027string\u0027 ? {\n    url: v\n  } : (v \u0026\u0026 v.url ? v : null)).filter(Boolean).slice(0, 6);\n}\nfunction renderImagesInArea(slide, layout, area, images, imageUpdateOption \u003d \u0027update\u0027) {\n  if (!images || !images.length) return;\n  if (imageUpdateOption !\u003d\u003d \u0027update\u0027) {\n    return;\n  }\n  const n \u003d Math.min(6, images.length);\n  let cols \u003d n \u003d\u003d\u003d 1 ? 1 : (n \u003c\u003d 4 ? 2 : 3);\n  const rows \u003d Math.ceil(n / cols);\n  const gap \u003d layout.pxToPt(10);\n  const cellW \u003d (area.width - gap * (cols - 1)) / cols,\n    cellH \u003d (area.height - gap * (rows - 1)) / rows;\n  for (let i \u003d 0; i \u003c n; i++) {\n    const r \u003d Math.floor(i / cols),\n      c \u003d i % cols;\n    try {\n      const img \u003d slide.insertImage(images[i].url);\n      const scale \u003d Math.min(cellW / img.getWidth(), cellH / img.getHeight());\n      const w \u003d img.getWidth() * scale,\n        h \u003d img.getHeight() * scale;\n      img.setWidth(w).setHeight(h).setLeft(area.left + c * (cellW + gap) + (cellW - w) / 2).setTop(area.top + r * (cellH + gap) + (cellH - h) / 2);\n    } catch (e) {}\n  }\n}\nfunction createGradientRectangle(slide, x, y, width, height, colors) {\n  const numStrips \u003d Math.max(20, Math.floor(width / 5));\n  const stripWidth \u003d width / numStrips;\n  const startColor \u003d hexToRgb(colors[0]),\n    endColor \u003d hexToRgb(colors[1]);\n  if (!startColor || !endColor) return null;\n  const shapes \u003d [];\n  for (let i \u003d 0; i \u003c numStrips; i++) {\n    const ratio \u003d i / (numStrips - 1);\n    const r \u003d Math.round(startColor.r + (endColor.r - startColor.r) * ratio);\n    const g \u003d Math.round(startColor.g + (endColor.g - startColor.g) * ratio);\n    const b \u003d Math.round(startColor.b + (endColor.b - startColor.b) * ratio);\n    const strip \u003d slide.insertShape(SlidesApp.ShapeType.RECTANGLE, x + (i * stripWidth), y, stripWidth + 0.5, height);\n    strip.getFill().setSolidFill(r, g, b);\n    strip.getBorder().setTransparent();\n    shapes.push(strip);\n  }\n  if (shapes.length \u003e 1) {\n    return slide.group(shapes);\n  }\n  return shapes[0] || null;\n}\nfunction applyFill(slide, x, y, width, height, settings) {\n  if (settings.enableGradient) {\n    createGradientRectangle(slide, x, y, width, height, [settings.gradientStart, settings.gradientEnd]);\n  } else {\n    const shape \u003d slide.insertShape(SlidesApp.ShapeType.RECTANGLE, x, y, width, height);\n    shape.getFill().setSolidFill(settings.primaryColor);\n    shape.getBorder().setTransparent();\n  }\n}\nfunction createPillShapeUnderline(slide, x, y, width, height, settings) {\n  const diameter \u003d height;\n  const radius \u003d height / 2;\n  const rectWidth \u003d Math.max(0, width - diameter);\n  if (width \u003c diameter) {\n    const centerCircle \u003d slide.insertShape(SlidesApp.ShapeType.ELLIPSE, x, y, diameter, diameter);\n    const color \u003d settings.enableGradient ? settings.gradientStart : settings.primaryColor;\n    centerCircle.getFill().setSolidFill(color);\n    centerCircle.getBorder().setTransparent();\n    return;\n  }\n  const leftCircle \u003d slide.insertShape(SlidesApp.ShapeType.ELLIPSE, x, y, diameter, diameter);\n  const rightCircle \u003d slide.insertShape(SlidesApp.ShapeType.ELLIPSE, x + width - diameter, y, diameter, diameter);\n  if (settings.enableGradient) {\n    leftCircle.getFill().setSolidFill(settings.gradientStart);\n    rightCircle.getFill().setSolidFill(settings.gradientEnd);\n  } else {\n    const color \u003d settings.primaryColor;\n    leftCircle.getFill().setSolidFill(color);\n    rightCircle.getFill().setSolidFill(color);\n  }\n  leftCircle.getBorder().setTransparent();\n  rightCircle.getBorder().setTransparent();\n  let middleShape \u003d null;\n  if (rectWidth \u003e 0) {\n    if (settings.enableGradient) {\n      if (!__CACHED_GRADIENT_UNDERLINE_RECT) {\n        const MAX_MASTER_WIDTH \u003d 300;\n        const masterGroup \u003d createGradientRectangle(slide, 2000, 0, MAX_MASTER_WIDTH, height, [settings.gradientStart, settings.gradientEnd]);\n        if (masterGroup) {\n          __CACHED_GRADIENT_UNDERLINE_RECT \u003d masterGroup;\n        }\n      }\n      if (__CACHED_GRADIENT_UNDERLINE_RECT) {\n        try {\n          middleShape \u003d slide.insertGroup(__CACHED_GRADIENT_UNDERLINE_RECT);\n          middleShape.setWidth(rectWidth);\n          middleShape.setHeight(height);\n          middleShape.setLeft(x + radius);\n          middleShape.setTop(y);\n        } catch (e) {\n          middleShape \u003d createGradientRectangle(slide, x + radius, y, rectWidth, height, [settings.gradientStart, settings.gradientEnd]);\n        }\n      } else {\n        middleShape \u003d createGradientRectangle(slide, x + radius, y, rectWidth, height, [settings.gradientStart, settings.gradientEnd]);\n      }\n    } else {\n      middleShape \u003d slide.insertShape(SlidesApp.ShapeType.RECTANGLE, x + radius, y, rectWidth, height);\n      middleShape.getFill().setSolidFill(settings.primaryColor);\n      middleShape.getBorder().setTransparent();\n    }\n  }\n  const shapesToGroup \u003d [leftCircle, rightCircle];\n  if (middleShape) {\n    shapesToGroup.push(middleShape);\n  }\n  if (shapesToGroup.length \u003e 1) {\n    slide.group(shapesToGroup);\n  }\n}\nfunction clearLegacyUserProperties() {\n  try {\n    const properties \u003d PropertiesService.getUserProperties().getProperties();\n    const legacyKeys \u003d [\n      \u0027primaryColor\u0027,\n      \u0027gradientStart\u0027, \n      \u0027gradientEnd\u0027,\n      \u0027fontFamily\u0027,\n      \u0027showTitleUnderline\u0027,\n      \u0027showBottomBar\u0027,\n      \u0027enableGradient\u0027,\n      \u0027footerText\u0027,\n      \u0027headerLogoUrl\u0027,\n      \u0027closingLogoUrl\u0027,\n      \u0027titleBgUrl\u0027,\n      \u0027sectionBgUrl\u0027,\n      \u0027mainBgUrl\u0027,\n      \u0027closingBgUrl\u0027,\n      \u0027driveFolderUrl\u0027,\n      \u0027driveFolderId\u0027\n    ];\n    const keysToDelete \u003d [];\n    legacyKeys.forEach(key \u003d\u003e {\n      if (properties.hasOwnProperty(key)) {\n        keysToDelete.push(key);\n      }\n    });\n    if (keysToDelete.length \u003e 0) {\n      const userProperties \u003d PropertiesService.getUserProperties();\n      keysToDelete.forEach(key \u003d\u003e {\n        userProperties.deleteProperty(key);\n      });\n      return {\n        status: \u0027success\u0027,\n        message: `${keysToDelete.length}個のレガシープロパティを削除しました。`,\n        deletedKeys: keysToDelete\n      };\n    } else {\n      return {\n        status: \u0027info\u0027,\n        message: \u0027削除対象のレガシープロパティは見つかりませんでした。\u0027\n      };\n    }\n  } catch (e) {\n    return {\n      status: \u0027error\u0027,\n      message: `レガシープロパティの削除中にエラーが発生しました: ${e.message}`\n    };\n  }\n}\nfunction saveGemUrl(url) {\n  try {\n    const trimmedUrl \u003d url ? url.trim() : \u0027\u0027;\n    const gemBaseUrl \u003d \u0027https://gemini.google.com/gem/\u0027;\n    if (!trimmedUrl) {\n      throw new Error(\"URLを入力してください。\");\n    }\n    // [変更] \u0027https://\u0027 で始まらない場合はエラーをスローして保存を拒否\n    if (!trimmedUrl.startsWith(\u0027https://\u0027)) {\n      throw new Error(\"URLは https:// で始まる必要があります。\");\n    }\n    PropertiesService.getScriptProperties().setProperty(\u0027geminiGemUrl\u0027, trimmedUrl);\n    if (!trimmedUrl.startsWith(gemBaseUrl)) {\n      // \u0027https://\u0027 で始まっているが \u0027gemini.google.com/gem/\u0027 ではない場合\n      return { status: \u0027warning\u0027, message: \u0027URLは保存されましたが、Gemini Gem (https://gemini.google.com/gem/...) の形式ではありません。\u0027 };\n    } else if (trimmedUrl.length \u003d\u003d\u003d gemBaseUrl.length) {\n      return { status: \u0027warning\u0027, message: \u0027URLが保存されましたが、特定のGemが指定されていません。\u0027 };\n    } else {\n      return { status: \u0027success\u0027, message: \u0027Gemini Gem URLを保存しました。\u0027 };\n    }\n  } catch (e) {\n    return { status: \u0027error\u0027, message: e.message };\n  }\n}\nfunction adjustShapeText_External(shape, preCalculatedWidthPt \u003d null, widthOverride \u003d null, heightOverride \u003d null) {\n  const PADDING_TOP_BOTTOM \u003d 7.5;\n  const PADDING_LEFT_RIGHT \u003d 10.0;\n  const LINE_HEIGHT_FACTOR \u003d 1.1;\n  const AVG_CHAR_WIDTH_FACTOR \u003d 1.0;\n  function getEffectiveCharCount(text) {\n    let count \u003d 0;\n    if (!text) return 0;\n    for (let i \u003d 0; i \u003c text.length; i++) {\n      const char \u003d text[i];\n      if (char.match(/[^\\x00-\\x7F\\uFF61-\\uFF9F]/)) {\n        count +\u003d 1.0;\n      } else {\n        count +\u003d 0.6;\n      }\n    }\n    return count;\n  }\n  function _isShapeShortBox(shape, baseFontSize, heightOverride \u003d null) {\n    if (!baseFontSize || baseFontSize \u003d\u003d\u003d 0) {\n      return false;\n    }\n    const boxHeight \u003d (heightOverride !\u003d\u003d null) ? heightOverride : shape.getHeight();\n    return (boxHeight \u003c\u003d (baseFontSize * 2));\n  }\n  function getNonEmptyFontSize(shape) {\n    try {\n      const textRange \u003d shape.getText();\n      if (!textRange || textRange.isEmpty()) return null;\n      const paragraphs \u003d textRange.getParagraphs();\n      for (const paragraph of paragraphs) {\n        if (paragraph.getRange().asString().trim().length \u003e 0) {\n          const run \u003d paragraph.getRange().getRuns()[0];\n          if (run \u0026\u0026 run.getTextStyle()) {\n            const fontSize \u003d run.getTextStyle().getFontSize();\n            if (typeof fontSize \u003d\u003d\u003d \u0027number\u0027) {\n                 return Math.floor(fontSize * 2) / 2;\n            }\n          }\n        }\n      }\n      const firstRun \u003d textRange.getRuns()[0];\n      if (firstRun \u0026\u0026 firstRun.getTextStyle()) {\n        const fontSize \u003d firstRun.getTextStyle().getFontSize();\n        if (typeof fontSize \u003d\u003d\u003d \u0027number\u0027) {\n             return Math.floor(fontSize * 2) / 2;\n        }\n      }\n      return null;\n    } catch (e) {\n      return null;\n    }\n  }\n  function isTextOverflowing(shape, nonEmptyFontSizeOverride \u003d null, preCalculatedWidthPt \u003d null, originalBaseFontSize \u003d null, widthOverride \u003d null, heightOverride \u003d null) {\n    let details \u003d \"--- 簡易計算の詳細 ---\\n\\n\";\n    try {\n      const textRange \u003d shape.getText();\n      const originalText \u003d textRange.asString();\n      if (originalText.length \u003d\u003d\u003d 0) {\n        return { isOverflow: false, details: \"テキストが空です。\" };\n      }\n      const paragraphs \u003d textRange.getParagraphs();\n      const paragraphCount \u003d paragraphs.length;\n      let currentBaseFontSize;\n      if (nonEmptyFontSizeOverride !\u003d\u003d null) {\n        currentBaseFontSize \u003d nonEmptyFontSizeOverride;\n        details +\u003d `基準フォントサイズ: ${currentBaseFontSize.toFixed(1)} pt (縮小テスト中)\\n`;\n      } else {\n        currentBaseFontSize \u003d getNonEmptyFontSize(shape);\n        if (currentBaseFontSize \u003d\u003d\u003d null) {\n          const firstRun \u003d textRange.getRuns()[0];\n          if (firstRun \u0026\u0026 firstRun.getTextStyle()) {\n              const fs \u003d firstRun.getTextStyle().getFontSize();\n              if(typeof fs \u003d\u003d\u003d \u0027number\u0027) {\n                  currentBaseFontSize \u003d Math.floor(fs * 2) / 2;\n              } else {\n                 currentBaseFontSize \u003d 1;\n              }\n          } else {\n             currentBaseFontSize \u003d 1;\n          }\n        }\n        details +\u003d `基準フォントサイズ: ${currentBaseFontSize.toFixed(1)} pt (空でない段の代表値)\\n`;\n      }\n      if (!currentBaseFontSize || currentBaseFontSize \u003c\u003d 0) {\n        details +\u003d \"基準フォントサイズが取得できないか無効なため、判定不能です。\";\n        return { isOverflow: false, details: details };\n      }\n      const boxWidth \u003d (widthOverride !\u003d\u003d null) ? widthOverride : shape.getWidth();\n      const boxHeight \u003d (heightOverride !\u003d\u003d null) ? heightOverride : shape.getHeight();\n      details +\u003d `ボックスサイズ (W): ${boxWidth.toFixed(2)} pt\\n`;\n      details +\u003d `ボックスサイズ (H): ${boxHeight.toFixed(2)} pt\\n`;\n      details +\u003d `推定余白 (上下): ${PADDING_TOP_BOTTOM} pt\\n`;\n      details +\u003d `推定余白 (左右): ${PADDING_LEFT_RIGHT} pt\\n\\n`;\n      const textAreaWidth \u003d boxWidth - (PADDING_LEFT_RIGHT * 2);\n      const textAreaHeight \u003d boxHeight - (PADDING_TOP_BOTTOM * 2);\n      details +\u003d `推定テキストエリア内寸 (W): ${textAreaWidth.toFixed(2)} pt\\n`;\n      details +\u003d `推定テキストエリア内寸 (H): ${textAreaHeight.toFixed(2)} pt\\n`;\n      if (textAreaWidth \u003c\u003d 0 || textAreaHeight \u003c\u003d 0) {\n        details +\u003d \"判定: 内寸が0以下のため「はみ出し」\";\n        return { isOverflow: true, details: details };\n      }\n      const initialSizeForModeCheck \u003d originalBaseFontSize !\u003d\u003d null ? originalBaseFontSize : currentBaseFontSize;\n      const isShortBox \u003d _isShapeShortBox(shape, initialSizeForModeCheck, heightOverride);\n      details +\u003d `ボックスタイプ: ${isShortBox ? \"単一行モード\" : \"標準（複数行）モード\"} (判定基準FS: ${initialSizeForModeCheck.toFixed(1)}pt)\\n\\n`;\n      let isOverflow;\n      if (isShortBox) {\n        const fontSizeToUse \u003d currentBaseFontSize;\n        let calculatedTextWidthPt \u003d -1; \n        if (nonEmptyFontSizeOverride !\u003d\u003d null \u0026\u0026 preCalculatedWidthPt !\u003d\u003d null \u0026\u0026 preCalculatedWidthPt \u003e\u003d 0 \u0026\u0026 originalBaseFontSize !\u003d\u003d null \u0026\u0026 originalBaseFontSize \u003e 0) {\n          calculatedTextWidthPt \u003d preCalculatedWidthPt * (fontSizeToUse / originalBaseFontSize); \n          details +\u003d `使用するテキスト幅: ${calculatedTextWidthPt.toFixed(2)} pt (${fontSizeToUse.toFixed(1)}pt で事前計算値をスケーリング)\\n`;\n        }\n        else if (preCalculatedWidthPt !\u003d\u003d null \u0026\u0026 preCalculatedWidthPt \u003e\u003d 0) {\n          calculatedTextWidthPt \u003d preCalculatedWidthPt;\n          details +\u003d `使用するテキスト幅: ${calculatedTextWidthPt.toFixed(2)} pt (事前計算値)\\n`;\n        }\n        else {\n          const estimatedFullCharWidth \u003d fontSizeToUse * AVG_CHAR_WIDTH_FACTOR; \n          const totalEffectiveCount \u003d getEffectiveCharCount(originalText); \n          calculatedTextWidthPt \u003d totalEffectiveCount * estimatedFullCharWidth; \n          details +\u003d `使用するテキスト幅: ${calculatedTextWidthPt.toFixed(2)} pt (${fontSizeToUse.toFixed(1)}pt で文字数ベース推定)\\n`;\n        }\n        isOverflow \u003d calculatedTextWidthPt \u003e textAreaWidth; \n        const hasManualLineBreaks \u003d (paragraphCount \u003e 1); \n        isOverflow \u003d isOverflow || hasManualLineBreaks; \n        details +\u003d `\\n--- 判定 (単一行モード) ---\\n`; \n        details +\u003d `(使用フォントサイズ: ${fontSizeToUse.toFixed(1)} pt)\\n`; \n        details +\u003d `(計算/推定テキスト幅: ${calculatedTextWidthPt.toFixed(2)} pt)\\n`; \n        details +\u003d `(テキストエリア内寸幅: ${textAreaWidth.toFixed(2)} pt)\\n`; \n        details +\u003d `手動改行あり: ${hasManualLineBreaks}\\n`; \n        details +\u003d `幅オーバー: ${calculatedTextWidthPt \u003e textAreaWidth}\\n`; \n        details +\u003d `結果: ${isOverflow ? \"はみ出し\" : \"収まっている\"}`; \n      } else {\n        details +\u003d `\\n--- 判定 (標準モード・段落ごと) ---\\n`; \n        let calculatedTotalHeight \u003d 0; \n        let paraIndex \u003d 0; \n        for (const paragraph of paragraphs) {\n            const paraRange \u003d paragraph.getRange(); \n            const paraText \u003d paraRange.asString(); \n            const isParaEmpty \u003d paraText.trim().length \u003d\u003d\u003d 0; \n            let currentFontSize;\n            if (isParaEmpty) { \n              if (nonEmptyFontSizeOverride !\u003d\u003d null) {\n                currentFontSize \u003d 1; \n              } else {\n                const run \u003d paraRange.getRuns()[0];\n                let fs \u003d run \u0026\u0026 run.getTextStyle() ? run.getTextStyle().getFontSize() : null;\n                currentFontSize \u003d (typeof fs \u003d\u003d\u003d \u0027number\u0027) ? Math.floor(fs * 2) / 2 : 1;\n              }\n            } else { \n              if (nonEmptyFontSizeOverride !\u003d\u003d null) {\n                currentFontSize \u003d nonEmptyFontSizeOverride; \n              } else {\n                const run \u003d paraRange.getRuns()[0];\n                let fs \u003d run \u0026\u0026 run.getTextStyle() ? run.getTextStyle().getFontSize() : null;\n                currentFontSize \u003d (typeof fs \u003d\u003d\u003d \u0027number\u0027) ? Math.floor(fs * 2) / 2 : currentBaseFontSize;\n              }\n            }\n             currentFontSize \u003d Math.max(1, currentFontSize);\n            details +\u003d `  段落${paraIndex + 1}: ${isParaEmpty ? \"(空)\" : \"\"} FS\u003d${currentFontSize.toFixed(1)}pt\\n`; \n            const estimatedLineHeight \u003d ( currentFontSize * LINE_HEIGHT_FACTOR ) + 0.5; \n            const estimatedFullCharWidth \u003d currentFontSize * AVG_CHAR_WIDTH_FACTOR; \n            const maxEffectiveCharsPerLine \u003d (estimatedFullCharWidth \u003e 0) ? Math.floor(textAreaWidth / estimatedFullCharWidth) : 0;\n            let linesInThisParagraph \u003d 0; \n            if (isParaEmpty) {\n                linesInThisParagraph \u003d 1; \n            } else {\n                const effectiveCount \u003d getEffectiveCharCount(paraText); \n                linesInThisParagraph \u003d (maxEffectiveCharsPerLine \u003e 0) ? Math.ceil(effectiveCount / maxEffectiveCharsPerLine) : 1;\n                 linesInThisParagraph \u003d Math.max(1, linesInThisParagraph); \n            }\n            const paragraphStyle \u003d paraRange.getParagraphStyle(); \n            const spaceAbove \u003d (paragraphStyle \u0026\u0026 typeof paragraphStyle.getSpaceAbove \u003d\u003d\u003d \u0027function\u0027 ? paragraphStyle.getSpaceAbove() : 0) || 0;\n            const spaceBelow \u003d (paragraphStyle \u0026\u0026 typeof paragraphStyle.getSpaceBelow \u003d\u003d\u003d \u0027function\u0027 ? paragraphStyle.getSpaceBelow() : 0) || 0;\n            const paragraphSpacing \u003d spaceAbove + spaceBelow; \n            const calculatedLinesHeight \u003d linesInThisParagraph * estimatedLineHeight;\n            calculatedTotalHeight +\u003d calculatedLinesHeight;\n            details +\u003d `    -\u003e ${linesInThisParagraph}行 * ${estimatedLineHeight.toFixed(2)}pt \u003d ${calculatedLinesHeight.toFixed(2)}pt (文字数ベース推定)\\n`; \n            if (paraIndex \u003e 0) { \n              calculatedTotalHeight +\u003d paragraphSpacing;\n              details +\u003d `    -\u003e 段落間隔 ${paragraphSpacing.toFixed(2)}pt 加算\\n`; \n            }\n            paraIndex++; \n        }\n        details +\u003d `\\n算出された必要な総高さ: ${calculatedTotalHeight.toFixed(2)} pt\\n`; \n        isOverflow \u003d calculatedTotalHeight \u003e textAreaHeight;\n        details +\u003d `必要な高さ (${calculatedTotalHeight.toFixed(2)} pt) \u003e エリアの高さ (${textAreaHeight.toFixed(2)} pt)\\n`; \n        details +\u003d `結果: ${isOverflow ? \"はみ出し\" : \"収まっている\"}`; \n      }\n      return { isOverflow: isOverflow, details: details }; \n    } catch (e) {\n      return { isOverflow: false, details: \"エラーが発生しました: \" + e.message };\n    }\n  }\n  function minimizeEmptyParagraphs(shape) {\n    let modified \u003d false; \n    try {\n      const textRange \u003d shape.getText(); \n      if (!textRange || textRange.isEmpty()) return false; \n      const paragraphs \u003d textRange.getParagraphs(); \n      for (const paragraph of paragraphs) { \n        const paraRange \u003d paragraph.getRange(); \n        if (paraRange.asString().trim().length \u003d\u003d\u003d 0) {\n          const style \u003d paraRange.getTextStyle(); \n          if (style \u0026\u0026 style.getFontSize() !\u003d\u003d 1) {\n            style.setFontSize(1); \n            modified \u003d true; \n          }\n        }\n      }\n    } catch (e) {\n    }\n    return modified; \n  }\n  function applyNonEmptyFontSize(shape, size) {\n    try {\n      const textRange \u003d shape.getText(); \n      if (!textRange || textRange.isEmpty()) return; \n      const paragraphs \u003d textRange.getParagraphs(); \n      for (const paragraph of paragraphs) { \n        const paraRange \u003d paragraph.getRange(); \n        if (paraRange.asString().trim().length \u003e 0) {\n           const style \u003d paraRange.getTextStyle(); \n           if (style) { \n               style.setFontSize(size);\n           }\n        }\n      }\n    } catch (e) {\n    }\n  }\n  function findOptimalFontSize(shape, startFontSize, preCalculatedWidthPt \u003d null, originalBaseFontSize \u003d null, widthOverride \u003d null, heightOverride \u003d null) {\n    if (typeof startFontSize !\u003d\u003d \u0027number\u0027 || startFontSize \u003c 10) {\n        return null; \n    }\n    const MIN_FONT_SIZE \u003d (widthOverride !\u003d\u003d null) ? 1 : 10;\n    for (let testSize \u003d startFontSize - 0.5; testSize \u003e\u003d MIN_FONT_SIZE; testSize -\u003d 0.5) {\n      const result \u003d isTextOverflowing(shape, testSize, preCalculatedWidthPt, originalBaseFontSize, widthOverride, heightOverride);\n      if (!result.isOverflow) { \n        return testSize; \n      }\n    }\n    return null; \n  }\n  let logDetails \u003d \"\"; \n  let finalAppliedFontSize \u003d null; \n  try {\n    if (!shape || typeof shape.getText !\u003d\u003d \u0027function\u0027 || shape.getText().isEmpty()) { \n      return { log: \"テキストが空のため、処理をスキップしました。\", finalSize: null }; \n    }\n    logDetails +\u003d \"--- 事前チェック (面積比較) ---\\n\"; \n    const textRange \u003d shape.getText(); \n    const originalText \u003d textRange.asString(); \n    const totalCharCount \u003d originalText.length; \n    const initialBaseFontSize \u003d getNonEmptyFontSize(shape); \n    finalAppliedFontSize \u003d initialBaseFontSize; \n    if (initialBaseFontSize \u003d\u003d\u003d null) { \n      logDetails +\u003d \"エラー: 基準フォントサイズが取得できず、事前チェックをスキップします。\\n\\n\";\n    } else {\n      const boxWidth \u003d (widthOverride !\u003d\u003d null) ? widthOverride : shape.getWidth();\n      const boxHeight \u003d (heightOverride !\u003d\u003d null) ? heightOverride : shape.getHeight();\n      const textAreaWidth \u003d boxWidth - (PADDING_LEFT_RIGHT * 2);\n      const textAreaHeight \u003d boxHeight - (PADDING_TOP_BOTTOM * 2);\n      const textAreaArea \u003d textAreaWidth * textAreaHeight;\n      if (textAreaArea \u003c\u003d 0) { \n        logDetails +\u003d \"警告: テキストエリアの内寸面積が0以下です。詳細チェックに進みます。\\n\\n\";\n      } else {\n        const estimatedCharArea \u003d initialBaseFontSize * initialBaseFontSize;\n        const estimatedTotalCharArea \u003d estimatedCharArea * totalCharCount;\n        const thresholdArea \u003d textAreaArea * 0.4;\n        logDetails +\u003d `基準フォントサイズ: ${initialBaseFontSize.toFixed(1)} pt\\n`; \n        logDetails +\u003d `総文字数: ${totalCharCount} 文字\\n`;\n        logDetails +\u003d `推定1文字の面積 (FS*FS): ${estimatedCharArea.toFixed(2)} pt^2\\n`;\n        logDetails +\u003d `推定テキスト総面積: ${estimatedTotalCharArea.toFixed(2)} pt^2\\n`;\n        logDetails +\u003d `推定テキストエリア内寸面積: ${textAreaArea.toFixed(2)} pt^2\\n`;\n        logDetails +\u003d `判定閾値 (エリアの40%): ${thresholdArea.toFixed(2)} pt^2\\n`;\n        if (estimatedTotalCharArea \u003c\u003d thresholdArea) {\n          logDetails +\u003d \"結果: テキスト総面積がエリアの40%以下のため、詳細チェックをスキップします。✅\\n\";\n          return { log: logDetails, finalSize: initialBaseFontSize }; \n        } else {\n          logDetails +\u003d \"結果: テキスト総面積がエリアの40%を超えているため、詳細チェックに進みます。\\n\\n\";\n        }\n      }\n    }\n    const initialResult \u003d isTextOverflowing(shape, null, preCalculatedWidthPt, initialBaseFontSize, widthOverride, heightOverride);\n    logDetails +\u003d \"--- 詳細診断 (実行前の状態) --- \\n\" + initialResult.details + \"\\n\\n\"; \n    if (!initialResult.isOverflow) {\n      logDetails +\u003d \"--- 実行結果 --- \\nはみ出しは検出されませんでした。調整は不要です。 ✅\"; \n      return { log: logDetails, finalSize: initialBaseFontSize }; \n    }\n    logDetails +\u003d \"--- 調整実行 --- \\nはみ出しを検出しました 🚨\\n\\n\"; \n    const currentActualFontSize \u003d getNonEmptyFontSize(shape); \n     if (currentActualFontSize \u003d\u003d\u003d null) { \n        logDetails +\u003d \"エラー: 現在のフォントサイズが取得できず、調整を実行できません。\";\n        return { log: logDetails, finalSize: null}; \n    }\n    const isShortBox \u003d _isShapeShortBox(shape, initialBaseFontSize || currentActualFontSize, heightOverride);\n    if (isShortBox) {\n      logDetails +\u003d \"（単一行モードとして処理します）\\n\"; \n      const optimalSize \u003d findOptimalFontSize(shape, currentActualFontSize, preCalculatedWidthPt, initialBaseFontSize, widthOverride, heightOverride);\n      if (optimalSize !\u003d\u003d null) { \n        shape.getText().getTextStyle().setFontSize(optimalSize);\n        finalAppliedFontSize \u003d optimalSize; \n        logDetails +\u003d `調整： 全体のフォントサイズを ${optimalSize.toFixed(1)} pt に縮小しました。\\n`; \n        const finalResult \u003d isTextOverflowing(shape, optimalSize, preCalculatedWidthPt, initialBaseFontSize, widthOverride, heightOverride);\n        logDetails +\u003d \"\\n--- 調整後の計算詳細 ---\\n\" + (finalResult.details || \"計算失敗\"); \n      } else {\n        const MIN_FONT_SIZE \u003d (widthOverride !\u003d\u003d null) ? 1 : 10;\n        shape.getText().getTextStyle().setFontSize(MIN_FONT_SIZE); \n        finalAppliedFontSize \u003d MIN_FONT_SIZE; \n        logDetails +\u003d `調整： フォントサイズ ${MIN_FONT_SIZE} pt でもテキストが収まりませんでした。\\n`; \n      }\n    } else {\n      logDetails +\u003d \"（標準モードとして処理します）\\n\"; \n      const modifiedEmpty \u003d minimizeEmptyParagraphs(shape);\n      if (modifiedEmpty) {\n        logDetails +\u003d \"ステップ1: 空の段落のフォントサイズを 1pt に縮小しました。\\n\"; \n      } else {\n        logDetails +\u003d \"ステップ1: 対象となる空の段落はありませんでした。\\n\"; \n      }\n      const resultAfterStep1 \u003d isTextOverflowing(shape, null, preCalculatedWidthPt, initialBaseFontSize, widthOverride, heightOverride);\n      logDetails +\u003d \"ステップ1実行後の再計算結果：\\n\" + (resultAfterStep1.details || \"計算失敗\") + \"\\n\\n\"; \n      if (!resultAfterStep1.isOverflow) {\n        logDetails +\u003d \"--- 実行結果 --- \\n空の段落の縮小のみで、はみ出しが解消しました。✅\"; \n        return { log: logDetails, finalSize: initialBaseFontSize }; \n      }\n      logDetails +\u003d \"ステップ2: 文字を含む段落のフォントサイズを縮小します。\\n\"; \n      const currentNonEmptySizeAfterStep1 \u003d getNonEmptyFontSize(shape); \n       if (currentNonEmptySizeAfterStep1 \u003d\u003d\u003d null) { \n           logDetails +\u003d \"エラー: 現在のフォントサイズが取得できず、ステップ2を実行できません。\";\n           return { log: logDetails, finalSize: null}; \n       }\n      const optimalSize \u003d findOptimalFontSize(shape, currentNonEmptySizeAfterStep1, preCalculatedWidthPt, initialBaseFontSize, widthOverride, heightOverride);\n      if (optimalSize !\u003d\u003d null) { \n        applyNonEmptyFontSize(shape, optimalSize);\n        finalAppliedFontSize \u003d optimalSize; \n        logDetails +\u003d `調整： 文字のある段落を ${optimalSize.toFixed(1)} pt に縮小しました。\\n`; \n        const finalResult \u003d isTextOverflowing(shape, null, preCalculatedWidthPt, initialBaseFontSize, widthOverride, heightOverride);\n        logDetails +\u003d \"\\n--- 調整後の計算詳細 ---\\n\" + (finalResult.details || \"計算失敗\"); \n      } else {\n        const MIN_FONT_SIZE \u003d (widthOverride !\u003d\u003d null) ? 1 : 10;\n        applyNonEmptyFontSize(shape, MIN_FONT_SIZE); \n        finalAppliedFontSize \u003d MIN_FONT_SIZE; \n        logDetails +\u003d `調整： 文字のある段落を ${MIN_FONT_SIZE}pt にしてもテキストが収まりませんでした。\\n`; \n      }\n    }\n    return { log: logDetails, finalSize: finalAppliedFontSize };\n  } catch (e) {\n    if (e.message.includes(\"getWidth is not a function\") || e.message.includes(\"getHeight is not a function\") || e.message.includes(\"shape.getWidth is not a function\")) {\n        return { log: logDetails + \"\\n\\n--- 致命的なエラー --- \\n\" + \"TableCellが渡されましたが、幅または高さのOverride引数がありませんでした。 \" + e.message, finalSize: null };\n    }\n    return { log: logDetails + \"\\n\\n--- 致命的なエラー --- \\n\" + e.message, finalSize: null };\n  }\n}\nconst METADATA_BOX_TITLE \u003d \u0027METADATA_STORAGE_BOX\u0027; \nconst TARGET_LAYOUT_ID \u003d \u0027p10\u0027; \nconst MAX_HISTORY_COUNT \u003d 5;\nfunction saveGenerationState(presentationId, slideData, settings) {\n  try {\n    if (!presentationId) {\n      return;\n    }\n    const presentation \u003d SlidesApp.openById(presentationId);\n    const box \u003d findOrSetupMetadataBox(presentation);\n    if (!box) {\n      return;\n    }\n    let history \u003d [];\n    const currentDesc \u003d box.getDescription();\n    if (currentDesc \u0026\u0026 currentDesc.trim() !\u003d\u003d \"\" \u0026\u0026 !currentDesc.includes(\"simple_shape_fallback\")) {\n      try {\n        const parsed \u003d JSON.parse(currentDesc);\n        if (parsed.history \u0026\u0026 Array.isArray(parsed.history)) {\n          history \u003d parsed.history;\n        }\n      } catch (e) {\n        history \u003d [];\n      }\n    }\n    let safeSlideData \u003d [];\n    let safeSettings \u003d {};\n    try {\n       safeSettings \u003d JSON.parse(JSON.stringify(settings));\n       delete safeSettings.creditImageBase64;\n       delete safeSettings.triangleArrows;\n       safeSlideData \u003d JSON.parse(JSON.stringify(slideData));\n       safeSlideData.forEach(slide \u003d\u003e {\n         if (slide.ghostImageBase64) delete slide.ghostImageBase64;\n         if (slide.image \u0026\u0026 typeof slide.image \u003d\u003d\u003d \u0027string\u0027 \u0026\u0026 slide.image.startsWith(\u0027data:image/\u0027)) {\n            slide.image \u003d \"\";\n         }\n         if (slide.image \u0026\u0026 typeof slide.image \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026 slide.image.data \u0026\u0026 typeof slide.image.data \u003d\u003d\u003d \u0027string\u0027 \u0026\u0026 slide.image.data.startsWith(\u0027data:image/\u0027)) {\n            slide.image.data \u003d \"\";\n         }\n       });\n    } catch (cleanError) {\n       return;\n    }\n    const newEntry \u003d {\n      timestamp: new Date().getTime(),\n      dateStr: Utilities.formatDate(new Date(), Session.getScriptTimeZone(), \u0027yyyy/MM/dd HH:mm:ss\u0027),\n      slideData: safeSlideData,\n      settings: safeSettings\n    };\n    history.push(newEntry);\n    if (history.length \u003e MAX_HISTORY_COUNT) {\n      history \u003d history.slice(history.length - MAX_HISTORY_COUNT);\n    }\n    try {\n      const jsonString \u003d JSON.stringify({ history: history });\n      box.setDescription(jsonString);\n      const checkId \u003d box.getObjectId();\n    } catch (writeError) {\n    }\n  } catch (e) {\n  }\n}\nfunction loadLatestGenerationState(presentationId) {\n  try {\n    if (!presentationId) throw new Error(\"IDが指定されていません\");\n    const presentation \u003d SlidesApp.openById(presentationId);\n    const box \u003d findOrSetupMetadataBox(presentation);\n    const description \u003d box.getDescription();\n    if (!description || description.trim() \u003d\u003d\u003d \"\") {\n      throw new Error(\"履歴データが空です。\");\n    }\n    const parsed \u003d JSON.parse(description);\n    if (!parsed.history || parsed.history.length \u003d\u003d\u003d 0) {\n      throw new Error(\"有効な履歴が見つかりません。\");\n    }\n    const latestState \u003d parsed.history[parsed.history.length - 1];\n    return {\n      status: \u0027success\u0027,\n      data: latestState,\n      url: presentation.getUrl()\n    };\n  } catch (e) {\n    return {\n      status: \u0027error\u0027,\n      message: e.message\n    };\n  }\n}\nfunction findOrSetupMetadataBox(presentation) {\n  const layouts \u003d presentation.getLayouts();\n  let targetLayout \u003d null;\n  for (const layout of layouts) {\n    if (layout.getObjectId() \u003d\u003d\u003d TARGET_LAYOUT_ID) {\n      targetLayout \u003d layout;\n      break;\n    }\n  }\n  if (!targetLayout) {\n    targetLayout \u003d layouts[0];\n  }\n  const shapes \u003d targetLayout.getShapes();\n  for (let i \u003d 0; i \u003c shapes.length; i++) {\n    if (shapes[i].getTitle() \u003d\u003d\u003d METADATA_BOX_TITLE) {\n      return shapes[i];\n    }\n  }\n  for (let i \u003d 0; i \u003c shapes.length; i++) {\n    const shape \u003d shapes[i];\n    if (shape.getShapeType() \u003d\u003d\u003d SlidesApp.ShapeType.TEXT_BOX) {\n      shape.setTitle(METADATA_BOX_TITLE);\n      return shape;\n    }\n  }\n  return createMetadataBox(targetLayout);\n}\nfunction createMetadataBox(layout) {\n  const box \u003d layout.insertShape(SlidesApp.ShapeType.TEXT_BOX, 0, 0, 300, 100);\n  box.setTitle(METADATA_BOX_TITLE);\n  box.getText().setText(\"[⛔ システム用データ]\");\n  box.getBorder().setWeight(1).setSolidFill(\u0027#FF0000\u0027);\n  return box;\n}\nfunction addToUserHistory(presentationId) {\n  if (!presentationId) return;\n  try {\n    const userProps \u003d PropertiesService.getUserProperties();\n    const HISTORY_KEY \u003d \u0027slide_history_v1\u0027;\n    let history \u003d [];\n    const json \u003d userProps.getProperty(HISTORY_KEY);\n    if (json) {\n      try { history \u003d JSON.parse(json); } catch(e) { history \u003d []; }\n    }\n    const file \u003d DriveApp.getFileById(presentationId);\n    const lastUpdated \u003d file.getLastUpdated();\n    let editorEmail \u003d \u0027Unknown\u0027;\n    try {\n      const user \u003d file.getLastModifyingUser();\n      if (user) {\n        editorEmail \u003d user.getEmail();\n      } else {\n        const owner \u003d file.getOwner();\n        if (owner) {\n          editorEmail \u003d owner.getEmail();\n        }\n      }\n    } catch (e) {\n      try { editorEmail \u003d file.getOwner().getEmail(); } catch(e2) {}\n    }\n    const formattedDate \u003d Utilities.formatDate(lastUpdated, Session.getScriptTimeZone(), \u0027yyyy/MM/dd HH:mm\u0027);\n    const meta \u003d {\n      id: presentationId,\n      name: file.getName(),\n      lastModified: formattedDate,\n      timestamp: lastUpdated.getTime(),\n      editor: editorEmail,\n      url: file.getUrl(),\n      icon: file.getMimeType() \u003d\u003d\u003d MimeType.GOOGLE_SLIDES ? \u0027slide\u0027 : \u0027file\u0027\n    };\n    history \u003d history.filter(item \u003d\u003e item.id !\u003d\u003d presentationId);\n    history.unshift(meta);\n    if (history.length \u003e 10) history \u003d history.slice(0, 10);\n    userProps.setProperty(HISTORY_KEY, JSON.stringify(history));\n    return meta;\n  } catch (e) {\n    return null;\n  }\n}\nfunction getUserHistory() {\n  try {\n    const userProps \u003d PropertiesService.getUserProperties();\n    const HISTORY_KEY \u003d \u0027slide_history_v1\u0027;\n    const json \u003d userProps.getProperty(HISTORY_KEY);\n    if (!json) {\n      return [];\n    }\n    let parsed \u003d [];\n    try {\n      parsed \u003d JSON.parse(json);\n    } catch (parseError) {\n      return [];\n    }\n    return parsed;\n  } catch (e) {\n    return [];\n  }\n}\nfunction processImagesAndUpload(imagesToUpload, slideDataString, settings) {\n  if (!imagesToUpload || imagesToUpload.length \u003d\u003d\u003d 0) {\n    return {\n      updatedSlideDataString: slideDataString,\n      imageFolderId: null,\n      error: null\n    };\n  }\n  try {\n    const parentFolderId \u003d settings.driveFolderId || \u0027root\u0027;\n    const parentFolder \u003d DriveApp.getFolderById(parentFolderId);\n    const tempFolderName \u003d `temp_images_${new Date().getTime()}`;\n    const tempFolder \u003d parentFolder.createFolder(tempFolderName);\n    const tempFolderId \u003d tempFolder.getId();\n    const imageIdMap \u003d {};\n    imagesToUpload.forEach((image, index) \u003d\u003e {\n      const base64Data \u003d image.data.split(\u0027,\u0027)[1];\n      const decodedData \u003d Utilities.base64Decode(base64Data);\n      const contentType \u003d image.data.match(/^data:(.*?);/)[1] || \u0027image/jpeg\u0027;\n      const fileName \u003d `image_${index}_${image.key.substring(0,20).replace(/[^a-zA-Z0-9]/g,\u0027_\u0027)}.png`;\n      const blob \u003d Utilities.newBlob(decodedData, contentType, fileName);\n      const file \u003d tempFolder.createFile(blob);\n      const fileId \u003d file.getId();\n      imageIdMap[image.key] \u003d fileId; \n    });\n    let slideData \u003d JSON.parse(slideDataString);\n    const updatedSlideData \u003d slideData.map(slide \u003d\u003e {\n      let currentImageKey \u003d null;\n      if (slide.image) {\n          if (typeof slide.image \u003d\u003d\u003d \u0027string\u0027) {\n              currentImageKey \u003d slide.image;\n          } else if (typeof slide.image \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026 slide.image !\u003d\u003d null) {\n              try {\n                currentImageKey \u003d JSON.stringify(slide.image);\n              } catch (e) {\n              }\n          }\n      }\n      if (currentImageKey \u0026\u0026 imageIdMap[currentImageKey]) {\n          return { ...slide, image: imageIdMap[currentImageKey] };\n      } else {\n          if (currentImageKey) {\n          }\n          return slide; \n      }\n    });\n    const finalJsonString \u003d JSON.stringify(updatedSlideData);\n    return {\n      updatedSlideDataString: finalJsonString,\n      imageFolderId: tempFolderId,\n      error: null\n    };\n  } catch (e) {\n    return {\n      updatedSlideDataString: slideDataString,\n      imageFolderId: null,\n      error: \u0027サーバーサイドで画像のアップロードまたは処理中にエラーが発生しました: \u0027 + e.message\n    };\n  }\n}\nfunction deleteFolderById(folderId) {\n  try {\n    if (folderId) {\n      const folder \u003d DriveApp.getFolderById(folderId);\n      folder.setTrashed(true);\n    }\n  } catch (e) {\n  }\n}\nfunction checkUserActivation() {\n  const SCRIPT_PROPERTY_KEY \u003d \u0027ACTIVATED_USER_LIST\u0027;\n  let userEmail \u003d \u0027\u0027;\n  let isActivated \u003d false;\n  try {\n    userEmail \u003d Session.getEffectiveUser().getEmail();\n    const scriptProperties \u003d PropertiesService.getScriptProperties();\n    const jsonString \u003d scriptProperties.getProperty(SCRIPT_PROPERTY_KEY);\n    if (jsonString) {\n      const activatedUsers \u003d JSON.parse(jsonString);\n      if (Array.isArray(activatedUsers) \u0026\u0026 activatedUsers.includes(userEmail)) {\n        isActivated \u003d true;\n      }\n    }\n  } catch (e) {\n    isActivated \u003d false;\n  }\n  return {\n    isActivated: isActivated,\n    userEmail: userEmail\n  };\n}\nfunction activateUser(userEmail) {\n  const SCRIPT_PROPERTY_KEY \u003d \u0027ACTIVATED_USER_LIST\u0027;\n  if (!userEmail) {\n    return { status: \u0027error\u0027, message: \u0027ユーザーIDがありません。\u0027 };\n  }\n  try {\n    const scriptProperties \u003d PropertiesService.getScriptProperties();\n    const jsonString \u003d scriptProperties.getProperty(SCRIPT_PROPERTY_KEY);\n    let activatedUsers \u003d [];\n    if (jsonString) {\n      try {\n        activatedUsers \u003d JSON.parse(jsonString);\n        if (!Array.isArray(activatedUsers)) {\n          activatedUsers \u003d [];\n        }\n      } catch (e) {\n        activatedUsers \u003d [];\n      }\n    }\n    if (!activatedUsers.includes(userEmail)) {\n      activatedUsers.push(userEmail);\n      scriptProperties.setProperty(SCRIPT_PROPERTY_KEY, JSON.stringify(activatedUsers));\n    } else {\n    }\n    return { status: \u0027success\u0027, message: \u0027アクティベートが完了しました。\u0027 };\n  } catch (e) {\n    return { status: \u0027error\u0027, message: \u0027サーバーエラー: \u0027 + e.message };\n  }\n}\nfunction convertJsonToSvgBatch(jsonStrings) {\n  if (!Array.isArray(jsonStrings)) {\n    return []; \n  }\n  const results \u003d jsonStrings.map(jsonText \u003d\u003e {\n    try {\n      const svgString \u003d jsonToSVG(jsonText);\n      return {\n        key: jsonText,   \n        svg: svgString, \n        error: null\n      };\n    } catch (e) {\n      return {\n        key: jsonText,\n        svg: null,\n        error: e.message\n      };\n    }\n  });\n  return results; \n}\nfunction jsonToSVG(jsonText) {\n  let config;\n  try {\n    config \u003d JSON.parse(jsonText);\n  } catch (e) {\n    throw new Error(`無効なJSONが提供されました: ${e.message}`);\n  }\n  if (!config || !config.chartType) {\n    throw new Error(\"無効なJSON構造です: \u0027chartType\u0027 キーが見つかりません。\");\n  }\n  const chartType \u003d config.chartType;\n  try {\n    const template \u003d getTemplate(chartType);\n    const svgOutput \u003d injectJsonIntoSvg(template, jsonText);\n    return svgOutput;\n  } catch (e) {\n    throw e;\n  }\n}\nfunction injectJsonIntoSvg(template, jsonText) {\n  const regex \u003d /(\u003cscript id\u003d\"chart-json-data\"[^\u003e]*\u003e)([\\s\\S]*?)(\u003c\\/script\u003e)/;\n  if (!regex.test(template)) {\n    throw new Error(\"SVGテンプレートにターゲットのscriptタグ (id\u003d\u0027chart-json-data\u0027) が見つかりません。\");\n  }\n  const replacedSvg \u003d template.replace(regex, `$1\\n    ${jsonText}\\n    $3`);\n  return replacedSvg;\n}\nfunction getTemplate(chartType) {\n  switch (chartType) {\n    case \"combo\":\n      return COMBO_CHART_TEMPLATE;\n    case \"multi-line\":\n      return MULTI_LINE_CHART_TEMPLATE;\n    case \"stacked-bar\":\n      return STACKED_BAR_CHART_TEMPLATE;\n    case \"bar\":\n      return BAR_CHART_TEMPLATE;\n    case \"100-stacked-bar\":\n      return PERCENT_STACKED_BAR_CHART_TEMPLATE;\n    case \"line\":\n      return LINE_CHART_TEMPLATE;\n    case \"donut\":\n      return DONUT_CHART_TEMPLATE;\n    default:\n      throw new Error(`不明な chart type です: \u0027${chartType}\u0027`);\n  }\n}\nfunction getTriangleArrowSvgTemplate() {\n  try {\n    return TRIANGLE_ARROW_SVG_TEMPLATE;\n  } catch (e) {\n    return \u0027\u0027;\n  }\n}\nconst TRIANGLE_ARROW_SVG_TEMPLATE \u003d `\u003c?xml version\u003d\"1.0\" encoding\u003d\"UTF-8\" standalone\u003d\"no\"?\u003e\n\u003csvg\n   width\u003d\"500px\"\n   height\u003d\"500px\"\n   viewBox\u003d\"0 0 500 500\"\n   version\u003d\"1.1\"\n   id\u003d\"svg1\"\n   xmlns\u003d\"http://www.w3.org/2000/svg\"\n   xmlns:svg\u003d\"http://www.w3.org/2000/svg\"\u003e\n  \u003cdefs id\u003d\"defs1\"\u003e\n    \u003cstyle id\u003d\"variable-controller\"\u003e\n      :root {\n        --end-x: {{END_X}};\n        --end-y: {{END_Y}};\n        --curve-intensity: {{CURVE_INTENSITY}};\n        --rotation: {{ROTATION}};\n        --flip-x: {{FLIP_X}};\n        --flip-y: {{FLIP_Y}};\n        --ghost-base-frequency: {{GHOST_BASE_FREQUENCY}};\n        --ghost-color-type: \u0027{{GHOST_COLOR_TYPE}}\u0027;\n        --ghost-alpha-slope: {{GHOST_ALPHA_SLOPE}};\n        --ghost-contrast-slope: {{GHOST_CONTRAST_SLOPE}};\n        --ghost-front-color: \u0027{{GHOST_FRONT_COLOR}}\u0027;\n        --ghost-front-alpha: {{GHOST_FRONT_ALPHA}};\n      }\n    \u003c/style\u003e\n    \u003cfilter id\u003d\"ghostNoiseFilter\"\n       filterUnits\u003d\"userSpaceOnUse\"\n       x\u003d\"0\" y\u003d\"0\" width\u003d\"500\" height\u003d\"500\"\u003e\n      \u003cfeTurbulence id\u003d\"ghostTurbulence\"\n          type\u003d\"fractalNoise\"\n          baseFrequency\u003d\"{{GHOST_BASE_FREQUENCY}}\"\n          numOctaves\u003d\"3\"\n          seed\u003d\"0\"\n          result\u003d\"noise\"/\u003e\n      \u003cfeColorMatrix id\u003d\"ghostColorMatrix\" in\u003d\"noise\" type\u003d\"matrix\"\n          values\u003d\"0.33 0.33 0.33 0 0 0.33 0.33 0.33 0 0 0.33 0.33 0.33 0 0 0 0 0 1 0\"\n          result\u003d\"coloredNoise\"/\u003e\n      \u003cfeComposite id\u003d\"ghostComposite\" in\u003d\"coloredNoise\" in2\u003d\"SourceAlpha\" operator\u003d\"in\" result\u003d\"maskedNoise\"/\u003e\n      \u003cfeComponentTransfer in\u003d\"maskedNoise\" result\u003d\"finalTexture\"\u003e\n          \u003cfeFuncR id\u003d\"ghostFuncR\" type\u003d\"linear\" slope\u003d\"{{GHOST_CONTRAST_SLOPE}}\" intercept\u003d\"0\"/\u003e\n          \u003cfeFuncG id\u003d\"ghostFuncG\" type\u003d\"linear\" slope\u003d\"{{GHOST_CONTRAST_SLOPE}}\" intercept\u003d\"0\"/\u003e\n          \u003cfeFuncB id\u003d\"ghostFuncB\" type\u003d\"linear\" slope\u003d\"{{GHOST_CONTRAST_SLOPE}}\" intercept\u003d\"0\"/\u003e\n          \u003cfeFuncA id\u003d\"ghostFuncA\" type\u003d\"linear\" slope\u003d\"{{GHOST_ALPHA_SLOPE}}\" intercept\u003d\"0\"/\u003e\n      \u003c/feComponentTransfer\u003e\n      \u003cfeMerge\u003e\n        \u003cfeMergeNode in\u003d\"finalTexture\"/\u003e\n      \u003c/feMerge\u003e\n    \u003c/filter\u003e\n    \u003cmask id\u003d\"arrowMask\"\u003e\n      \u003cg id\u003d\"arrow-mask-layer\" style\u003d\"fill:white; stroke:white;\"\u003e\n        \u003cpath\n           id\u003d\"arrow-head-mask\"\n           d\u003d\"M 0 -43.30127 L -25 0 H 25 Z\"\n           style\u003d\"fill-opacity:1; stroke:none;\"\n           transform\u003d\"translate(103.28583, 117.1908) rotate(0)\" /\u003e\n        \u003cpath\n           id\u003d\"arrow-stem-curve-mask\"\n           d\u003d\"\"\n           fill\u003d\"none\"\n           stroke-width\u003d\"21.566\"\n           stroke-linecap\u003d\"butt\"\n           stroke-linejoin\u003d\"bevel\"\n           stroke-opacity\u003d\"1\" /\u003e\n      \u003c/g\u003e\n    \u003c/mask\u003e\n  \u003c/defs\u003e\n  \u003cg id\u003d\"layer1\"\u003e\n    \u003cg id\u003d\"arrow-ghost-layer\" filter\u003d\"url(#ghostNoiseFilter)\"\u003e\n        \u003cpath\n           id\u003d\"arrow-head-ghost\"\n           d\u003d\"M 0 -43.30127 L -25 0 H 25 Z\"\n           style\u003d\"fill:#000000;fill-opacity:1;stroke:none;\"\n           transform\u003d\"translate(103.28583, 117.1908) rotate(0)\" /\u003e\n        \u003cpath\n           id\u003d\"arrow-stem-curve-ghost\"\n           d\u003d\"\"\n           fill\u003d\"none\"\n           stroke\u003d\"#000000\"\n           stroke-width\u003d\"21.566\"\n           stroke-linecap\u003d\"butt\"\n           stroke-linejoin\u003d\"bevel\"\n           stroke-opacity\u003d\"1\" /\u003e\n    \u003c/g\u003e\n    \u003cg id\u003d\"arrow-front-layer\"\u003e\n        \u003cpath\n           id\u003d\"arrow-head-front\"\n           d\u003d\"M 0 -43.30127 L -25 0 H 25 Z\"\n           style\u003d\"fill:{{GHOST_FRONT_COLOR}};fill-opacity:{{GHOST_FRONT_ALPHA}};stroke:none;\"\n           transform\u003d\"translate(103.28583, 117.1908) rotate(0)\" /\u003e\n        \u003cpath\n           id\u003d\"arrow-stem-curve-front\"\n           d\u003d\"\"\n           fill\u003d\"none\"\n           stroke\u003d\"{{GHOST_FRONT_COLOR}}\"\n           stroke-width\u003d\"21.566\"\n           stroke-linecap\u003d\"butt\"\n           stroke-linejoin\u003d\"bevel\"\n           stroke-opacity\u003d\"{{GHOST_FRONT_ALPHA}}\" /\u003e\n    \u003c/g\u003e\n  \u003c/g\u003e\n  \u003cscript\u003e\n      (function() {\n        const root \u003d document.documentElement;\n        const arrowHeadGhost \u003d document.getElementById(\u0027arrow-head-ghost\u0027);\n        const curvePathGhost \u003d document.getElementById(\u0027arrow-stem-curve-ghost\u0027);\n        const arrowHeadFront \u003d document.getElementById(\u0027arrow-head-front\u0027);\n        const curvePathFront \u003d document.getElementById(\u0027arrow-stem-curve-front\u0027);\n        const feTurbulence \u003d document.getElementById(\u0027ghostTurbulence\u0027);\n        const feColorMatrix \u003d document.getElementById(\u0027ghostColorMatrix\u0027);\n        const feComposite \u003d document.getElementById(\u0027ghostComposite\u0027);\n        const feFuncR \u003d document.getElementById(\u0027ghostFuncR\u0027);\n        const feFuncG \u003d document.getElementById(\u0027ghostFuncG\u0027);\n        const feFuncB \u003d document.getElementById(\u0027ghostFuncB\u0027);\n        const feFuncA \u003d document.getElementById(\u0027ghostFuncA\u0027);\n        const startX \u003d 100; const startY \u003d 100;\n        const canvasMin \u003d 0; const canvasMax \u003d 500;\n        const margin \u003d 10;\n        const endPointMin \u003d canvasMin + margin; const endPointMax \u003d canvasMax - margin;\n        function getCssVarNum(name, fallback) { const value \u003d getComputedStyle(root).getPropertyValue(name).trim(); const parsedValue \u003d parseFloat(value); return isNaN(parsedValue) ? fallback : parsedValue; }\n        function getCssVarString(name, fallback) { const value \u003d getComputedStyle(root).getPropertyValue(name).trim(); return value.replace(/^[\u0027\"]|[\u0027\"]$/g, \u0027\u0027) || fallback; }\n        function updatePath() {\n          const relativeX_base \u003d getCssVarNum(\u0027--end-x\u0027, 0);\n          let relativeY_base \u003d getCssVarNum(\u0027--end-y\u0027, 60);\n          let intensity_base \u003d getCssVarNum(\u0027--curve-intensity\u0027, 0);\n          relativeY_base \u003d relativeY_base * -1;\n          intensity_base \u003d Math.max(-100, Math.min(intensity_base, 100));\n          const rotation \u003d getCssVarNum(\u0027--rotation\u0027, 0);\n          const flipX \u003d (getCssVarNum(\u0027--flip-x\u0027, 0) \u003d\u003d\u003d 1) ? -1 : 1;\n          const flipY \u003d (getCssVarNum(\u0027--flip-y\u0027, 0) \u003d\u003d\u003d 1) ? -1 : 1;\n          const baseFrequency \u003d getCssVarNum(\u0027--ghost-base-frequency\u0027, 0.01);\n          const colorType \u003d getCssVarString(\u0027--ghost-color-type\u0027, \u0027gray\u0027);\n          const alphaSlope \u003d getCssVarNum(\u0027--ghost-alpha-slope\u0027, 0.50);\n          const contrastSlope \u003d getCssVarNum(\u0027--ghost-contrast-slope\u0027, 1.0);\n          const frontColor \u003d getCssVarString(\u0027--ghost-front-color\u0027, \u0027#000000\u0027);\n          const frontAlpha \u003d getCssVarNum(\u0027--ghost-front-alpha\u0027, 0.15);\n          const rX_flipped \u003d relativeX_base * flipX;\n          const rY_flipped \u003d relativeY_base * flipY;\n          const intensity \u003d intensity_base * flipX * flipY;\n          const rad \u003d rotation * Math.PI / 180;\n          const cos_r \u003d Math.cos(rad); const sin_r \u003d Math.sin(rad);\n          const relativeX \u003d rX_flipped * cos_r - rY_flipped * sin_r;\n          const relativeY \u003d rX_flipped * sin_r + rY_flipped * cos_r;\n          let endX \u003d startX + relativeX; let endY \u003d startY + relativeY;\n          endX \u003d Math.max(endPointMin, Math.min(endX, endPointMax)); endY \u003d Math.max(endPointMin, Math.min(endY, endPointMax));\n          const midX \u003d (startX + endX) / 2; const midY \u003d (startY + endY) / 2;\n          const vx \u003d endX - startX; const vy \u003d endY - startY; const len \u003d Math.sqrt(vx * vx + vy * vy);\n          let controlX, controlY;\n          if (len \u003d\u003d\u003d 0 || intensity \u003d\u003d\u003d 0) { controlX \u003d midX; controlY \u003d midY; } else { const normX \u003d -vy / len; const normY \u003d vx / len; controlX \u003d midX + normX * intensity; controlY \u003d midY + normY * intensity; }\n          const d \u003d \\`M \\${startX},\\${startY} Q \\${controlX},\\${controlY} \\${endX},\\${endY}\\`;\n          curvePathGhost.setAttribute(\u0027d\u0027, d); curvePathFront.setAttribute(\u0027d\u0027, d);\n          const tangentVx \u003d controlX - startX;\n          const tangentVy \u003d controlY - startY;\n          const angleRad \u003d Math.atan2(startY - controlY, startX - controlX);\n          const angleDeg \u003d (angleRad * 180 / Math.PI) + 90;\n          const transform \u003d \\`translate(\\${startX}, \\${startY}) rotate(\\${angleDeg})\\`;\n          arrowHeadGhost.setAttribute(\u0027transform\u0027, transform); arrowHeadFront.setAttribute(\u0027transform\u0027, transform);\n          feTurbulence.setAttribute(\u0027baseFrequency\u0027, baseFrequency);\n          feTurbulence.setAttribute(\u0027seed\u0027, Math.floor(Math.random() * 1000));\n          let matrixValues \u003d \"0.33 0.33 0.33 0 0 0.33 0.33 0.33 0 0 0.33 0.33 0.33 0 0 0 0 0 1 0\";\n          if (colorType !\u003d\u003d \u0027fullcolor\u0027) {\n              if (colorType \u003d\u003d\u003d \u0027red\u0027) matrixValues \u003d \"1 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0\";\n              else if (colorType \u003d\u003d\u003d \u0027green\u0027) matrixValues \u003d \"0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0\";\n              else if (colorType \u003d\u003d\u003d \u0027blue\u0027) matrixValues \u003d \"0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 1 0\";\n              feColorMatrix.setAttribute(\u0027values\u0027, matrixValues);\n              feColorMatrix.style.display \u003d \u0027block\u0027; feComposite.setAttribute(\u0027in\u0027, \u0027coloredNoise\u0027);\n          } else {\n              feColorMatrix.style.display \u003d \u0027none\u0027; feComposite.setAttribute(\u0027in\u0027, \u0027noise\u0027);\n          }\n          const contrastIntercept \u003d (0.5 * (1 - contrastSlope)).toFixed(2);\n          feFuncR.setAttribute(\u0027slope\u0027, contrastSlope); feFuncR.setAttribute(\u0027intercept\u0027, contrastIntercept);\n          feFuncG.setAttribute(\u0027slope\u0027, contrastSlope); feFuncG.setAttribute(\u0027intercept\u0027, contrastIntercept);\n          feFuncB.setAttribute(\u0027slope\u0027, contrastSlope); feFuncB.setAttribute(\u0027intercept\u0027, contrastIntercept);\n          feFuncA.setAttribute(\u0027slope\u0027, alphaSlope);\n          arrowHeadFront.style.fill \u003d frontColor; arrowHeadFront.style.fillOpacity \u003d frontAlpha;\n          curvePathFront.style.stroke \u003d frontColor; curvePathFront.style.strokeOpacity \u003d frontAlpha;\n        }\n        updatePath();\n      })();\n  \u003c/script\u003e\n\u003c/svg\u003e`;\nconst COMBO_CHART_TEMPLATE \u003d `\n\u003csvg width\u003d\"600\" height\u003d\"510\" viewBox\u003d\"25 25 580 510\" xmlns\u003d\"http://www.w3.org/2000/svg\" font-family\u003d\"\u0027Noto Sans JP\u0027, sans-serif\" id\u003d\"combo-chart-svg\"\u003e\n    \u003cscript id\u003d\"chart-json-data\" type\u003d\"application/json\"\u003e\n        {\n            \"chartType\": \"combo\",\n            \"data\": {\n                \"title\": \"サンプル複合グラフ\",\n                \"subtitle\": \"（系列データの比較）\",\n                \"source\": \"出典：サンプルデータソース\",\n                \"legendBarLabel\": \"系列 A\",\n                \"legendLineLabel\": \"系列 B\",\n                \"yAxisLeftLabel\": \"（数量）\",\n                \"yAxisRightLabel\": \"（割合）\",\n                \"colors\": {\n                    \"bar\": {\n                        \"start\": \"#e68a9c\",\n                        \"end\": \"#b469b8\"\n                    },\n                    \"line\": \"#6b5ce0\"\n                },\n                \"items\": [\n                    {\n                        \"label\": \"項目 1\",\n                        \"barValue\": 245,\n                        \"lineValue\": 16\n                    },\n                    {\n                        \"label\": \"項目 2\",\n                        \"barValue\": 270,\n                        \"lineValue\": 19\n                    },\n                    {\n                        \"label\": \"項目 3\",\n                        \"barValue\": 310,\n                        \"lineValue\": 21\n                    },\n                    {\n                        \"label\": \"項目 4\",\n                        \"barValue\": 290,\n                        \"lineValue\": 18\n                    },\n                    {\n                        \"label\": \"項目 5\",\n                        \"barValue\": 300,\n                        \"lineValue\": 23\n                    }\n                ],\n                \"layout\": {\n                    \"width\": 600,\n                    \"height\": 510,\n                    \"marginTop\": 180,\n                    \"marginBottom\": 50,\n                    \"marginLeft\": 70,\n                    \"marginRight\": 70\n                },\n                \"barOptions\": {\n                    \"barToSlotRatio\": 0.55,\n                    \"labelPosition\": \"auto\"\n                },\n                \"lineOptions\": {\n                    \"markerRadius\": 5\n                },\n                \"yAxisLeft\": {\n                    \"max\": 400,\n                    \"min\": 0,\n                    \"tickCount\": 4\n                },\n                \"yAxisRight\": {\n                    \"max\": 25,\n                    \"min\": 15,\n                    \"tickCount\": 4,\n                    \"unit\": \"%\"\n                },\n                \"animation\": 1\n            }\n        }\n    \u003c/script\u003e\n    \u003cdefs\u003e\n        \u003cfilter id\u003d\"shadow\"\u003e\n            \u003cfeDropShadow dx\u003d\"1\" dy\u003d\"2\" stdDeviation\u003d\"2\" flood-color\u003d\"#000\" flood-opacity\u003d\"0.2\" /\u003e\n        \u003c/filter\u003e\n         \u003cfilter id\u003d\"text-shadow-dark\" x\u003d\"-50%\" y\u003d\"-50%\" width\u003d\"200%\" height\u003d\"200%\"\u003e\n            \u003cfeDropShadow dx\u003d\"0\" dy\u003d\"0\" stdDeviation\u003d\"0.9\" flood-color\u003d\"#000000\" flood-opacity\u003d\"0.9\" in\u003d\"SourceAlpha\" result\u003d\"shadow\" /\u003e\n            \u003cfeMerge\u003e\n                \u003cfeMergeNode in\u003d\"shadow\" /\u003e\n                \u003cfeMergeNode in\u003d\"SourceGraphic\" /\u003e\n            \u003c/feMerge\u003e\n        \u003c/filter\u003e\n         \u003cfilter id\u003d\"text-halo-white\" x\u003d\"-50%\" y\u003d\"-50%\" width\u003d\"200%\" height\u003d\"200%\"\u003e\n            \u003cfeDropShadow dx\u003d\"0\" dy\u003d\"0\" stdDeviation\u003d\"2.5\" flood-color\u003d\"white\" flood-opacity\u003d\"0.95\" in\u003d\"SourceAlpha\" result\u003d\"shadow\" /\u003e\n            \u003cfeMerge\u003e\n                \u003cfeMergeNode in\u003d\"shadow\" /\u003e\n                \u003cfeMergeNode in\u003d\"SourceGraphic\" /\u003e\n            \u003c/feMerge\u003e\n        \u003c/filter\u003e\n     \u003c/defs\u003e\n    \u003cstyle\u003e\n        \u003c![CDATA[\n        @import url(\u0027https://fonts.googleapis.com/css2?family\u003dNoto+Sans+JP:wght@400;500;700\u0026amp;family\u003dRoboto:wght@400;700\u0026amp;display\u003dswap\u0027);\n        .title {\n            font-size: 24px;\n            font-weight: 500;\n            text-anchor: middle;\n            fill: #5f6368;\n        }\n        .subtitle {\n            font-size: 16px;\n            text-anchor: middle;\n            fill: #5f6368;\n        }\n        .source {\n            font-size: 11px;\n            fill: #70757a;\n            text-anchor: end;\n        }\n        .legend-item {\n            font-size: 13px;\n            fill: #202124;\n        }\n        .axis-label {\n            font-size: 13px;\n            fill: #5f6368;\n            text-anchor: middle;\n        }\n        .grid-line {\n            stroke: #e0e0e0;\n            stroke-dasharray: 2 2;\n            stroke-width: 0.8;\n        }\n        .y-axis-value {\n            font-family: \u0027Roboto\u0027, sans-serif;\n            font-size: 12px;\n            fill: #757575;\n        }\n        .data-label-bar-inside {\n            font-family: \u0027Roboto\u0027, sans-serif;\n            font-size: 14px;\n            font-weight: bold;\n            fill: white; \n            text-anchor: middle;\n            filter: url(#text-shadow-dark);\n        }\n        .data-label-bar-outside {\n            font-family: \u0027Roboto\u0027, sans-serif;\n            font-size: 14px;\n            font-weight: bold;\n            fill: #5f6368;\n            text-anchor: middle;\n            filter: url(#text-halo-white);\n        }\n        ]]\u003e\n    \u003c/style\u003e\n    \u003cg id\u003d\"title-group\"\u003e\u003c/g\u003e\n    \u003cg id\u003d\"legend-group\"\u003e\u003c/g\u003e\n    \u003cg id\u003d\"y-axes-group\"\u003e\u003c/g\u003e\n    \u003cg id\u003d\"x-axis-group\"\u003e\u003c/g\u003e\n    \u003cg id\u003d\"bar-chart-group\"\u003e\u003c/g\u003e\n    \u003cg id\u003d\"line-chart-group\"\u003e\u003c/g\u003e\n    \u003cg id\u003d\"source-group\"\u003e\u003c/g\u003e\n    \u003cscript type\u003d\"text/javascript\"\u003e\n        const svgNS \u003d \"http://www.w3.org/2000/svg\";\n        function createSVGElement(name, attributes, textContent) {\n            const el \u003d document.createElementNS(svgNS, name);\n            for (const key in attributes) el.setAttribute(key, attributes[key]);\n            if (textContent !\u003d\u003d undefined \u0026\u0026 textContent !\u003d\u003d null) el.textContent \u003d textContent;\n            return el;\n        }\n        function truncateText(text, maxWidth, className) {\n            const svgRoot \u003d document.getElementById(\u0027combo-chart-svg\u0027);\n            const tempText \u003d createSVGElement(\u0027text\u0027, {\n                class: className,\n                style: \u0027visibility: hidden;\u0027\n            });\n            svgRoot.appendChild(tempText);\n            tempText.textContent \u003d text;\n            if (tempText.getComputedTextLength() \u003c\u003d maxWidth) {\n                svgRoot.removeChild(tempText);\n                return text;\n            }\n            let truncatedText \u003d text;\n            while (truncatedText.length \u003e 0) {\n                truncatedText \u003d truncatedText.slice(0, -1);\n                tempText.textContent \u003d truncatedText + \u0027...\u0027;\n                if (tempText.getComputedTextLength() \u003c\u003d maxWidth) {\n                    svgRoot.removeChild(tempText);\n                    return truncatedText + \u0027...\u0027;\n                }\n            }\n            svgRoot.removeChild(tempText);\n            return \u0027...\u0027;\n        }\n        function hexToRgb(hex) {\n          let shorthandRegex \u003d /^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i;\n          hex \u003d hex.replace(shorthandRegex, function(m, r, g, b) {\n            return r + r + g + g + b + b;\n          });\n          let result \u003d /^#?([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/i.exec(hex);\n          return result ? {\n            r: parseInt(result[1], 16),\n            g: parseInt(result[2], 16),\n            b: parseInt(result[3], 16)\n          } : null;\n        }\n        function rgbToHsl(r, g, b) {\n          r /\u003d 255; g /\u003d 255; b /\u003d 255;\n          let max \u003d Math.max(r, g, b), min \u003d Math.min(r, g, b);\n          let h, s, l \u003d (max + min) / 2;\n          l \u003d Math.round(l * 100);\n          if (max \u003d\u003d min) {\n            h \u003d s \u003d 0;\n          } else {\n            let d \u003d max - min;\n            s \u003d l \u003e 50 ? d / (2 - max - min) : d / (max + min);\n            s \u003d Math.round(s * 100);\n            switch (max) {\n              case r: h \u003d (g - b) / d + (g \u003c b ? 6 : 0); break;\n              case g: h \u003d (b - r) / d + 2; break;\n              case b: h \u003d (r - g) / d + 4; break;\n            }\n            h /\u003d 6;\n          }\n          h \u003d Math.round(h * 360);\n          return [h, s, l];\n        }\n        function hslToRgb(h, s, l) {\n          let r, g, b;\n          h /\u003d 360;\n          s /\u003d 100;\n          l /\u003d 100;\n          if (s \u003d\u003d 0) {\n            r \u003d g \u003d b \u003d l;\n          } else {\n            function hue2rgb(p, q, t) {\n              if (t \u003c 0) t +\u003d 1;\n              if (t \u003e 1) t -\u003d 1;\n              if (t \u003c 1/6) return p + (q - p) * 6 * t;\n              if (t \u003c 1/2) return q;\n              if (t \u003c 2/3) return p + (q - p) * (2/3 - t) * 6;\n              return p;\n            }\n            let q \u003d l \u003c 0.5 ? l * (1 + s) : l + s - l * s;\n            let p \u003d 2 * l - q;\n            r \u003d hue2rgb(p, q, h + 1/3);\n            g \u003d hue2rgb(p, q, h);\n            b \u003d hue2rgb(p, q, h - 1/3);\n          }\n          return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\n        }\n        function rgbToHex(r, g, b) {\n          function componentToHex(c) {\n            let hex \u003d c.toString(16);\n            return hex.length \u003d\u003d 1 ? \"0\" + hex : hex;\n          }\n          return \"#\" + componentToHex(r) + componentToHex(g) + componentToHex(b);\n        }\n        function correctTickCount(range, currentTickCount) {\n            if (range \u003c\u003d 0) return 1;\n            if (currentTickCount \u003c\u003d 0) currentTickCount \u003d 1;\n            if (range % currentTickCount \u003d\u003d\u003d 0) {\n                return currentTickCount;\n            }\n            let lowerCount \u003d 1;\n            for (let i \u003d currentTickCount - 1; i \u003e 1; i--) {\n                if (range % i \u003d\u003d\u003d 0) {\n                    lowerCount \u003d i;\n                    break;\n                }\n            }\n            let upperCount \u003d range;\n            for (let i \u003d currentTickCount + 1; i \u003c range; i++) {\n                if (range % i \u003d\u003d\u003d 0) {\n                    upperCount \u003d i;\n                    break;\n                }\n            }\n            if ((upperCount - currentTickCount) \u003c\u003d (currentTickCount - lowerCount)) {\n                return upperCount;\n            } else {\n                return lowerCount;\n            }\n        }\n        function buildChart(config) {\n            const svgRoot \u003d document.getElementById(\u0027combo-chart-svg\u0027);\n            const defs \u003d svgRoot.querySelector(\u0027defs\u0027);\n            const style \u003d svgRoot.querySelector(\u0027style\u0027);\n            const existingGrads \u003d defs.querySelectorAll(\u0027linearGradient\u0027);\n            existingGrads.forEach(grad \u003d\u003e grad.remove());\n            let styleContent \u003d style.textContent;\n            styleContent \u003d styleContent.replace(/[.]bar {[^}]*}/g, \u0027\u0027);\n            styleContent \u003d styleContent.replace(/[.]line {[^}]*}/g, \u0027\u0027);\n            styleContent \u003d styleContent.replace(/[.]marker {[^}]*}/g, \u0027\u0027);\n            styleContent \u003d styleContent.replace(/[.]data-label-line {[^}]*}/g, \u0027\u0027);\n            style.textContent \u003d styleContent.trim();\n            const gradId \u003d \u0027barGradient\u0027;\n            let gradient \u003d createSVGElement(\u0027linearGradient\u0027, {\n                id: gradId, x1: \"0\", x2: \"0\", y1: \"0\", y2: \"1\"\n             });\n            gradient.appendChild(createSVGElement(\u0027stop\u0027, {\n                offset: \u00270%\u0027, \u0027stop-color\u0027: config.colors.bar.start\n            }));\n            gradient.appendChild(createSVGElement(\u0027stop\u0027, {\n                offset: \u0027100%\u0027, \u0027stop-color\u0027: config.colors.bar.end\n            }));\n            defs.appendChild(gradient);\n            const nl \u003d String.fromCharCode(10);\n            const stylesArray \u003d [\n                \"\",\n                \"            .bar { fill: url(#\" + gradId + \");\",\n                \"            filter: url(#shadow); }\",\n                \"            .line { fill: none; stroke: \" + config.colors.line + \";\",\n                \"            stroke-width: 3; stroke-linejoin: round; filter: url(#shadow); }\",\n                \"            .marker { fill: \" + config.colors.marker + \";\",\n                \"            stroke: white; stroke-width: 2; filter: url(#shadow); }\",\n                \"            .data-label-line { font-family: \u0027Roboto\u0027, sans-serif;\",\n                \"            font-size: 13px; font-weight: bold; fill: \" + config.colors.lineLabel + \"; text-anchor: middle; filter: url(#text-halo-white); }\",\n                 \"        \"\n            ];\n            let dynamicStyles \u003d stylesArray.join(nl);\n            style.textContent +\u003d dynamicStyles;\n            const groups \u003d {\n                title: document.getElementById(\u0027title-group\u0027),\n                legend: document.getElementById(\u0027legend-group\u0027),\n                yAxes: document.getElementById(\u0027y-axes-group\u0027),\n                xAxis: document.getElementById(\u0027x-axis-group\u0027),\n                 barChart: document.getElementById(\u0027bar-chart-group\u0027),\n                lineChart: document.getElementById(\u0027line-chart-group\u0027),\n                source: document.getElementById(\u0027source-group\u0027)\n            };\n            for (const key in groups) {\n                while (groups[key].firstChild) groups[key].removeChild(groups[key].firstChild);\n            }\n            const chartAreaWidth \u003d config.layout.width - config.layout.marginLeft - config.layout.marginRight;\n            const chartAreaHeight \u003d config.layout.height - config.layout.marginTop - config.layout.marginBottom;\n            const bottomY \u003d config.layout.marginTop + chartAreaHeight;\n            const maxBarValue \u003d Math.max(...config.items.map(d \u003d\u003e d.barValue), config.yAxisLeft.max);\n            const minBarValue \u003d Math.min(...config.items.map(d \u003d\u003e d.barValue), config.yAxisLeft.min);\n            const leftTickCount \u003d config.yAxisLeft.tickCount \u003e 0 ? config.yAxisLeft.tickCount : 1;\n            const preliminaryLeftRange \u003d Math.max(1, config.yAxisLeft.max - config.yAxisLeft.min);\n            let leftTickInterval \u003d preliminaryLeftRange / leftTickCount;\n            let effectiveYAxisLeftMin, effectiveYAxisLeftMax;\n            if (minBarValue \u003c config.yAxisLeft.min) {\n                const limit \u003d Math.max(Math.abs(minBarValue), maxBarValue);\n                if (leftTickInterval \u003c\u003d 0 || isNaN(leftTickInterval)) leftTickInterval \u003d Math.max(1, limit / 5);\n                effectiveYAxisLeftMax \u003d Math.ceil(limit / leftTickInterval) * leftTickInterval;\n                effectiveYAxisLeftMin \u003d -effectiveYAxisLeftMax;\n                if (config.yAxisLeft.min \u003e effectiveYAxisLeftMin) effectiveYAxisLeftMin \u003d config.yAxisLeft.min;\n                if (config.yAxisLeft.max \u003c effectiveYAxisLeftMax) effectiveYAxisLeftMax \u003d config.yAxisLeft.max;\n            } else {\n                effectiveYAxisLeftMin \u003d config.yAxisLeft.min;\n                if (leftTickInterval \u003c\u003d 0 || isNaN(leftTickInterval)) leftTickInterval \u003d Math.max(1, (maxBarValue - effectiveYAxisLeftMin) / 5) || 1;\n                effectiveYAxisLeftMax \u003d Math.max(config.yAxisLeft.max, Math.ceil(maxBarValue / leftTickInterval) * leftTickInterval);\n            }\n            if (effectiveYAxisLeftMax \u003c\u003d effectiveYAxisLeftMin) {\n                effectiveYAxisLeftMax \u003d effectiveYAxisLeftMin + leftTickInterval * leftTickCount;\n                if (effectiveYAxisLeftMax \u003c\u003d effectiveYAxisLeftMin) effectiveYAxisLeftMax \u003d effectiveYAxisLeftMin + 1;\n            }\n            if (effectiveYAxisLeftMax \u003d\u003d\u003d effectiveYAxisLeftMin) effectiveYAxisLeftMax +\u003d leftTickInterval;\n            const rightRangeOriginal \u003d config.yAxisRight.max - config.yAxisRight.min;\n            let rightTickCount \u003d config.yAxisRight.tickCount \u003e 0 ? config.yAxisRight.tickCount : 1;\n            if (rightRangeOriginal \u003e 0) {\n                rightTickCount \u003d correctTickCount(rightRangeOriginal, rightTickCount);\n            }\n            const rightTickInterval \u003d (rightRangeOriginal \u003e 0 \u0026\u0026 rightTickCount \u003e 0) ?\n                (rightRangeOriginal) / rightTickCount : 1;\n            const maxLineValue \u003d Math.max(...config.items.map(d \u003d\u003e d.lineValue), config.yAxisRight.max);\n            const minLineValue \u003d Math.min(...config.items.map(d \u003d\u003e d.lineValue), config.yAxisRight.min);\n            let effectiveYAxisRightMin \u003d config.yAxisRight.min;\n            if (minLineValue \u003c config.yAxisRight.min) {\n                effectiveYAxisRightMin \u003d Math.floor(minLineValue / rightTickInterval) * rightTickInterval;\n            }\n            let effectiveYAxisRightMax \u003d config.yAxisRight.max;\n            if (maxLineValue \u003e config.yAxisRight.max) {\n                effectiveYAxisRightMax \u003d Math.ceil(maxLineValue / rightTickInterval) * rightTickInterval;\n            }\n            if (effectiveYAxisRightMax \u003c\u003d effectiveYAxisRightMin) effectiveYAxisRightMax \u003d effectiveYAxisRightMin + rightTickInterval * (rightTickCount || 1);\n            const leftYRange \u003d effectiveYAxisLeftMax - effectiveYAxisLeftMin;\n            const rightYRange \u003d effectiveYAxisRightMax - effectiveYAxisRightMin;\n            const xScale \u003d (index) \u003d\u003e config.layout.marginLeft + (chartAreaWidth / config.items.length) * (index + 0.5);\n            const yScaleLeft \u003d (value) \u003d\u003e bottomY - (leftYRange \u003e 0 ? chartAreaHeight * ((value - effectiveYAxisLeftMin) / leftYRange) : chartAreaHeight / 2);\n            const yScaleRight \u003d (value) \u003d\u003e bottomY - (rightYRange \u003e 0 ? chartAreaHeight * ((value - effectiveYAxisRightMin) / rightYRange) : chartAreaHeight / 2);\n        const animProgress \u003d (config.animation \u003d\u003d null) \n            ? 1.0 \n            : Math.max(0, Math.min(1, Number(config.animation)));\n        let animOpacity;\n        const fadeStart \u003d 0.7;\n        if (animProgress \u003c\u003d fadeStart) {\n            animOpacity \u003d 0;\n        } else {\n            animOpacity \u003d (animProgress - fadeStart) / (1.0 - fadeStart);\n        }\n            groups.title.appendChild(createSVGElement(\u0027text\u0027, { x: 312, y: 65, class: \u0027title\u0027 }, config.title));\n            groups.title.appendChild(createSVGElement(\u0027text\u0027, { x: 312, y: 90, class: \u0027subtitle\u0027 }, config.subtitle));\n            groups.source.appendChild(createSVGElement(\u0027text\u0027, { x: 605, y: 525, class: \u0027source\u0027 }, config.source));\n            const legendY \u003d config.layout.marginTop - 60;\n            const legendAGroup \u003d createSVGElement(\u0027g\u0027, { transform: \u0027translate(\u0027 + config.layout.marginLeft + \u0027, \u0027 + legendY + \u0027)\u0027 });\n            legendAGroup.appendChild(createSVGElement(\u0027rect\u0027, { x: 0, y: -6, width: 12, height: 12, rx: 2, class: \u0027bar\u0027 }));\n            legendAGroup.appendChild(createSVGElement(\u0027text\u0027, { x: 18, y: 0, class: \u0027legend-item\u0027, \u0027dominant-baseline\u0027: \u0027middle\u0027 }, config.legendBarLabel));\n            groups.legend.appendChild(legendAGroup);\n            const legendBGroup \u003d createSVGElement(\u0027g\u0027, { transform: \u0027translate(\u0027 + (config.layout.width - config.layout.marginRight) + \u0027, \u0027 + legendY + \u0027)\u0027 });\n            legendBGroup.appendChild(createSVGElement(\u0027line\u0027, { x1: 0, y1: 0, x2: -12, y2: 0, stroke: config.colors.line, \u0027stroke-width\u0027: 2 }));\n            legendBGroup.appendChild(createSVGElement(\u0027circle\u0027, { cx: -6, cy: 0, r: 3, fill: config.colors.marker, stroke: \u0027white\u0027, \u0027stroke-width\u0027: 1 }));\n            legendBGroup.appendChild(createSVGElement(\u0027text\u0027, { x: -20, y: 0, class: \u0027legend-item\u0027, \u0027dominant-baseline\u0027: \u0027middle\u0027, \u0027text-anchor\u0027: \u0027end\u0027 }, config.legendLineLabel));\n            groups.legend.appendChild(legendBGroup);\n            for (let i \u003d 0; i \u003c\u003d leftTickCount; i++) {\n                const tickValue \u003d effectiveYAxisLeftMin + (leftYRange / leftTickCount) * i;\n                const y \u003d yScaleLeft(tickValue);\n                if (i \u003e 0 \u0026\u0026 i \u003c\u003d leftTickCount) {\n                    groups.yAxes.appendChild(createSVGElement(\u0027line\u0027, { x1: config.layout.marginLeft, y1: y, x2: config.layout.width - config.layout.marginRight, y2: y, class: \u0027grid-line\u0027 }));\n                }\n                groups.yAxes.appendChild(createSVGElement(\u0027text\u0027, { x: config.layout.marginLeft - 10, y, class: \u0027y-axis-value\u0027, \u0027text-anchor\u0027: \u0027end\u0027, \u0027dominant-baseline\u0027: \u0027middle\u0027 }, Math.round(tickValue)));\n            }\n            groups.yAxes.appendChild(createSVGElement(\u0027text\u0027, { x: 30, y: config.layout.marginTop - 20, class: \u0027y-axis-value\u0027 }, config.yAxisLeftLabel));\n            for (let i \u003d 0; i \u003c\u003d rightTickCount; i++) {\n                const tickValue \u003d effectiveYAxisRightMin + (rightYRange / rightTickCount) * i;\n                const y \u003d yScaleRight(tickValue);\n                groups.yAxes.appendChild(createSVGElement(\u0027text\u0027, { x: config.layout.width - config.layout.marginRight + 10, y: y, class: \u0027y-axis-value\u0027, \u0027text-anchor\u0027: \u0027start\u0027, \u0027dominant-baseline\u0027: \u0027middle\u0027 }, Math.round(tickValue) + (config.yAxisRight.unit || \u0027\u0027)));\n            }\n            groups.yAxes.appendChild(createSVGElement(\u0027text\u0027, { x: 585, y: config.layout.marginTop - 20, class: \u0027y-axis-value\u0027, \u0027text-anchor\u0027: \u0027end\u0027 }, config.yAxisRightLabel));\n            const slotWidth \u003d chartAreaWidth / config.items.length;\n            config.items.forEach((item, index) \u003d\u003e {\n                const labelContent \u003d truncateText(item.label, slotWidth * 0.9, \u0027axis-label\u0027);\n                groups.xAxis.appendChild(createSVGElement(\u0027text\u0027, { x: xScale(index), y: bottomY + 20, class: \u0027axis-label\u0027 }, labelContent));\n            });\n            groups.xAxis.appendChild(createSVGElement(\u0027line\u0027, { x1: config.layout.marginLeft, y1: bottomY, x2: config.layout.width - config.layout.marginRight, y2: bottomY, stroke: \u0027#bdbdbd\u0027 }));\n            if (effectiveYAxisLeftMin \u003c 0 \u0026\u0026 effectiveYAxisLeftMax \u003e 0) {\n                const yZero \u003d yScaleLeft(0);\n                groups.yAxes.appendChild(createSVGElement(\u0027line\u0027, { x1: config.layout.marginLeft, y1: yZero, x2: config.layout.width - config.layout.marginRight, y2: yZero, stroke: \u0027#bdbdbd\u0027, \u0027stroke-width\u0027: 1 }));\n            }\n            const barWidth \u003d slotWidth * config.barOptions.barToSlotRatio;\n            const barLabelYPositions \u003d [];\n            const yZero \u003d yScaleLeft(Math.max(0, effectiveYAxisLeftMin));\n            config.items.forEach((item, index) \u003d\u003e {\n                const x \u003d xScale(index) - barWidth / 2;\n                let finalBarY, finalBarHeight;\n                let animatedBarY, animatedBarHeight;\n                if (item.barValue \u003e\u003d 0) {\n                    finalBarY \u003d yScaleLeft(item.barValue);\n                    finalBarHeight \u003d Math.max(0, yZero - finalBarY);\n                    animatedBarHeight \u003d finalBarHeight * animProgress;\n                    animatedBarY \u003d yZero - animatedBarHeight;\n                } else {\n                    finalBarY \u003d yZero;\n                    finalBarHeight \u003d Math.max(0, yScaleLeft(item.barValue) - yZero);\n                    animatedBarHeight \u003d finalBarHeight * animProgress;\n                    animatedBarY \u003d yZero;\n                }\n                if (animatedBarHeight \u003e\u003d 1) {\n                    groups.barChart.appendChild(createSVGElement(\u0027rect\u0027, { \n                        x: x, \n                        y: animatedBarY,\n                        width: barWidth, \n                        height: animatedBarHeight,\n                        class: \u0027bar\u0027, \n                        rx: 4, \n                        ry: 4 \n                    }));\n                }\n                const isOutside \u003d animatedBarHeight \u003c 30;\n                let labelY, labelClass;\n                const labelMarginInside \u003d 20;\n                const labelMarginOutside \u003d 10;\n                if (isOutside) {\n                    labelClass \u003d \u0027data-label-bar-outside\u0027;\n                    labelY \u003d (item.barValue \u003e\u003d 0) ?\n                        animatedBarY - labelMarginOutside : animatedBarY + animatedBarHeight + labelMarginOutside + 8;\n                } else {\n                    labelClass \u003d \u0027data-label-bar-inside\u0027;\n                    labelY \u003d (item.barValue \u003e\u003d 0) ?\n                        animatedBarY + labelMarginInside : animatedBarY + animatedBarHeight - labelMarginInside;\n                }\n                if (!isOutside \u0026\u0026 item.barValue \u003e\u003d 0 \u0026\u0026 labelY \u003e yZero - 5) labelY \u003d yZero - 5;\n                if (!isOutside \u0026\u0026 item.barValue \u003c 0 \u0026\u0026 labelY \u003c yZero + 15) labelY \u003d yZero + 15;\n                barLabelYPositions.push({ index: index, y: labelY });\n                groups.barChart.appendChild(createSVGElement(\u0027text\u0027, { \n                    x: xScale(index), \n                    y: labelY,\n                    class: labelClass,\n                    style: \u0027opacity: \u0027 + animOpacity\n                }, item.barValue));\n            });\n            const yZeroLine \u003d yScaleRight(Math.max(effectiveYAxisRightMin, 0));\n            let allLineValuesSame \u003d false;\n            if (config.items.length \u003e 0) {\n                const firstValue \u003d config.items[0].lineValue;\n                allLineValuesSame \u003d config.items.every(item \u003d\u003e item.lineValue \u003d\u003d\u003d firstValue);\n            }\n            const pointsData \u003d config.items.map((item, index) \u003d\u003e {\n                const x \u003d xScale(index);\n                const finalY \u003d yScaleRight(item.lineValue);\n                let animatedY \u003d yZeroLine + (finalY - yZeroLine) * animProgress;\n                if (allLineValuesSame) {\n                    const jiggle \u003d (index % 2 \u003d\u003d\u003d 0) ? 0.01 : -0.01;\n                    animatedY +\u003d jiggle;\n                }\n                return {\n                    x: x,\n                    finalY: finalY,\n                    animatedY: animatedY,\n                    value: item.lineValue\n                };\n            });\n            const points \u003d pointsData.map(d \u003d\u003e d.x + \u0027,\u0027 + d.animatedY).join(\u0027 \u0027);\ngroups.lineChart.appendChild(createSVGElement(\u0027polyline\u0027, { class: \u0027line\u0027, points }));\n            pointsData.forEach((data, index) \u003d\u003e {\n                const x \u003d data.x;\n                const y \u003d data.animatedY;\n                groups.lineChart.appendChild(createSVGElement(\u0027circle\u0027, { \n                    cx: x, \n                    cy: y,\n                    r: config.lineOptions.markerRadius, \n                    class: \u0027marker\u0027 \n                }));\n                let lineLabelY \u003d y - 20;\nconst correspondingBarLabel \u003d barLabelYPositions.find(pos \u003d\u003e pos.index \u003d\u003d\u003d index);\n                if (correspondingBarLabel \u0026\u0026 Math.abs(lineLabelY - correspondingBarLabel.y) \u003c 20) {\n                    let belowY \u003d y + 25;\nif (belowY \u003c bottomY - 5) { \n                         lineLabelY \u003d belowY;\n                    }\n                }\n                groups.lineChart.appendChild(createSVGElement(\u0027text\u0027, { \n                    x: x, \n                    y: lineLabelY,\n                    class: \u0027data-label-line\u0027,\n                    style: \u0027opacity: \u0027 + animOpacity\n                }, data.value + (config.yAxisRight.unit || \u0027\u0027)));\n            });\n}\n        try {\n            const configJson \u003d document.getElementById(\u0027chart-json-data\u0027).textContent;\n            if (!configJson || configJson.trim() \u003d\u003d\u003d \u0027\u0027) {\n                throw new Error(\"JSON data is empty.\");\n            }\n            let fullConfig;\n            try {\n                fullConfig \u003d JSON.parse(configJson);\n            } catch (parseError) {\n                throw new Error(\u0027JSON parsing error: \u0027 + parseError.message);\n            }\n            if (!fullConfig || typeof fullConfig !\u003d\u003d \u0027object\u0027 || !fullConfig.data) {\n                throw new Error(\"Invalid JSON structure: Missing \u0027data\u0027 key.\");\n            }\n            const config \u003d fullConfig.data;\n            config.layout \u003d { \n                \"width\": 600, \n                \"height\": 450, \n                \"marginTop\": 180, \n                \"marginBottom\": 0, \n                \"marginLeft\": 70, \n                \"marginRight\": 70 \n            };\n            config.barOptions \u003d config.barOptions || {};\n            config.barOptions.barToSlotRatio \u003d (config.barOptions.barToSlotRatio \u003d\u003d null) ? 0.55 : config.barOptions.barToSlotRatio;\n            config.barOptions.labelPosition \u003d config.barOptions.labelPosition || \"auto\";\n            config.lineOptions \u003d config.lineOptions || {};\n            config.lineOptions.markerRadius \u003d (config.lineOptions.markerRadius \u003d\u003d null) ? 5 : config.lineOptions.markerRadius;\n            if (config.colors \u0026\u0026 typeof config.colors \u003d\u003d\u003d \u0027string\u0027) {\n                const colorKeyword \u003d config.colors.toLowerCase();\n                let generatedColorObject;\n                if (colorKeyword \u003d\u003d\u003d \u0027#gemini\u0027) {\n                    generatedColorObject \u003d {\n                        bar: { start: \"#E68A9C\", end: \"#9F63D0\" },\n                        line: \"#616AD8\",\n                        marker: \"#616AD8\",\n                        lineLabel: \"#4D46AE\"\n                    };\n                } else if (colorKeyword \u003d\u003d\u003d \u0027#night\u0027) {\n                    var NIGHT_COLORS \u003d [\n                        { start: \"#8a2be2\", end: \"#4169e1\" },\n                        { start: \u0027#8f83d6\u0027, end: \u0027#5a5188\u0027 },\n                        { start: \u0027#7891dd\u0027, end: \u0027#4456a0\u0027 },\n                        { start: \u0027#FF8F00\u0027, end: \u0027#FF8F00\u0027 },\n                        { start: \u0027#54c5d5\u0027, end: \u0027#267b87\u0027 }\n                    ];\n                    generatedColorObject \u003d {\n                        bar: { start: NIGHT_COLORS[0].start, end: NIGHT_COLORS[0].end },\n                        line: NIGHT_COLORS[3].start,\n                        marker: NIGHT_COLORS[3].start,\n                        lineLabel: NIGHT_COLORS[3].end\n                    };\n              } else {\n                    const inputColorHex \u003d config.colors;\n                    const rgb \u003d hexToRgb(inputColorHex);\n                    if (!rgb) {\n                        throw new Error(\"Invalid HEX color string in \u0027colors\u0027: \" + inputColorHex);\n                    }\n                    let [h_orig, s_orig, l_orig] \u003d rgbToHsl(rgb.r, rgb.g, rgb.b);\n                    const MIN_L \u003d 25;\n                    const MAX_L \u003d 75;\n                    const ACHROMATIC_THRESHOLD_S \u003d 5;\n                    const MIN_S_FOR_COLOR \u003d 30;\n                    let h_base \u003d h_orig;\n                    let s_base;\n                    let l_base \u003d Math.max(MIN_L, Math.min(MAX_L, l_orig));\n                    if (s_orig \u003c ACHROMATIC_THRESHOLD_S) {\n                        s_base \u003d 0;\n                    } else {\n                        s_base \u003d Math.max(s_orig, MIN_S_FOR_COLOR);\n                    }\n                    const hex_base_color \u003d rgbToHex(...hslToRgb(h_base, s_base, l_base));\n                    const hex_bar_end \u003d hex_base_color;\n                    let l_bar_start \u003d Math.min(100, l_base + 15);\n                    let s_bar_start \u003d (l_base \u003e MAX_L - 10) ? s_base * 0.8 : s_base;\n                    const hex_bar_start \u003d rgbToHex(...hslToRgb(h_base, s_bar_start, l_bar_start));\n                    const hex_line_main \u003d hex_base_color;\n                    let l_line_label \u003d Math.max(0, l_base - 25);\n                    let s_line_label \u003d (l_base \u003c MIN_L + 10) ? Math.min(100, s_base * 1.2) : s_base;\n                    const hex_line_label \u003d rgbToHex(...hslToRgb(h_base, s_line_label, l_line_label));\n                    generatedColorObject \u003d {\n                        bar: { start: hex_bar_start, end: hex_bar_end },\n                        line: hex_line_main,\n                        marker: hex_line_main,\n                        lineLabel: hex_line_label\n                    };\n                }\n                config.colors \u003d generatedColorObject;\n            } else if (!config.colors || typeof config.colors !\u003d\u003d \u0027object\u0027 || !config.colors.bar || !config.colors.line) {\n                 throw new Error(\"\u0027colors\u0027 must be a valid color object {bar, line, ...} or a single color string.\");\n            }\n             if (config.colors \u0026\u0026 typeof config.colors \u003d\u003d\u003d \u0027object\u0027) {\n                 if (!config.colors.marker) config.colors.marker \u003d config.colors.line;\n                 if (!config.colors.lineLabel) {\n                     const markerRgb \u003d hexToRgb(config.colors.marker);\n                     if (markerRgb) {\n                         const markerHsl \u003d rgbToHsl(markerRgb.r, markerRgb.g, markerRgb.b);\n                         const label_l \u003d Math.max(10, markerHsl[2] - 25);\n                         const labelRgb \u003d hslToRgb(markerHsl[0], markerHsl[1], label_l);\n                         config.colors.lineLabel \u003d rgbToHex(labelRgb[0], labelRgb[1], labelRgb[2]);\n                     } else {\n                        config.colors.lineLabel \u003d config.colors.line;\n                     }\n                 }\n            }\n            if (!config || typeof config !\u003d\u003d \u0027object\u0027 || !config.items || !Array.isArray(config.items)) {\n                throw new Error(\"Invalid JSON structure: Missing required fields like \u0027items\u0027 inside \u0027data\u0027.\");\n            }\n            buildChart(config);\n        } catch (e) {\n            console.error(\"Chart Error:\", e);\n            const svgRoot \u003d document.getElementById(\u0027combo-chart-svg\u0027);\n            const existingError \u003d svgRoot.querySelector(\u0027.error-message\u0027);\n            if (existingError) existingError.remove();\n            const textEl \u003d createSVGElement(\u0027text\u0027, {\n                x: svgRoot.viewBox.baseVal.width / 2 + svgRoot.viewBox.baseVal.x,\n                y: svgRoot.viewBox.baseVal.height / 2 + svgRoot.viewBox.baseVal.y,\n                \u0027text-anchor\u0027: \u0027middle\u0027,\n                fill: \u0027red\u0027,\n                \u0027font-family\u0027: \"\u0027Noto Sans JP\u0027, sans-serif\",\n                class: \u0027error-message\u0027\n            });\n            textEl.textContent \u003d e.message.includes(\u0027JSON\u0027) ? \u0027JSONデータにエラーがあります。\u0027 : \u0027グラフ描画エラーが発生しました。\u0027;\n            if (e.message.includes(\u0027JSON parsing error\u0027)) {\n                textEl.textContent +\u003d \u0027 (\u0027 + e.message.split(\u0027: \u0027)[1] + \u0027)\u0027;\n            }\n            svgRoot.appendChild(textEl);\n        }\n    \u003c/script\u003e\n\u003c/svg\u003e\n`;\nconst MULTI_LINE_CHART_TEMPLATE \u003d `\n\u003csvg width\u003d\"650\" height\u003d\"510\" viewBox\u003d\"25 15 620 485\" xmlns\u003d\"http://www.w3.org/2000/svg\" font-family\u003d\"\u0027Noto Sans JP\u0027, sans-serif\" id\u003d\"multi-line-chart-svg\"\u003e\n  \u003cscript id\u003d\"chart-json-data\" type\u003d\"application/json\"\u003e\n    {\n      \"chartType\": \"multi-line\",\n      \"data\": {\n        \"title\": \"データ系列の比較\",\n        \"subtitle\": \"（年間サンプルデータ）\",\n        \"source\": \"出典：サンプルデータ\",\n        \"yAxisUnitLabel\": \"（単位）\",\n        \"xAxisLabels\": [\"1月\", \"2月\", \"3月\", \"4月\", \"5月\", \"6月\", \"7月\", \"8月\", \"9月\", \"10月\", \"11月\", \"12月\"],\n        \"series\": [\n          { \"id\": \"A\", \"label\": \"系列A\", \"values\": [10, 12, 15, 20, 24, 27, 29, 28, 25, 20, 16, 12] },\n          { \"id\": \"B\", \"label\": \"系列B\", \"values\": [7, 8, 11, 15, 18, 20, 21, 20, 16, 13, 10, 8] },\n          { \"id\": \"C\", \"label\": \"系列C\", \"values\": [4, 5, 6, 8, 10, 11, 12, 10, 8, 7, 5, 4] }\n        ],\n\"colors\": \n[\n          { \"id\": \"A\", \"start\": \"#e68a9c\", \"end\": \"#d96d8f\" },\n          { \"id\": \"B\", \"start\": \"#b469b8\", \"end\": \"#a656ad\" },\n          { \"id\": \"C\", \"start\": \"#7c6ce8\", \"end\": \"#6b5ce0\" }\n        ],\n        \"layout\": {\n          \"width\": 650,\n          \"height\": 510,\n\"marginTop\": 140,\n          \"marginBottom\": 80,\n          \"marginLeft\": 75,\n          \"marginRight\": 35,\n          \"horizontalPadding\": 20\n        },\n        \"yAxis\": {\n          \"min\": 0,\n          \"max\": 30,\n          \"tickCount\": 6\n   },\n        \"lineOptions\": {\n          \"markerRadius\": 5,\n          \"dataLabelOffsetY\": 8\n        },\n        \"animation\": 1\n      }\n    }\n  \u003c/script\u003e\n  \u003cdefs\u003e\n    \u003cfilter id\u003d\"shadow\"\u003e\u003cfeDropShadow dx\u003d\"1\" dy\u003d\"2\" stdDeviation\u003d\"2\" flood-color\u003d\"#000\" flood-opacity\u003d\"0.2\"/\u003e\u003c/filter\u003e\n    \u003cfilter id\u003d\"text-halo-white\" x\u003d\"-50%\" y\u003d\"-50%\" width\u003d\"200%\" height\u003d\"200%\"\u003e\n      \u003cfeDropShadow dx\u003d\"0\" dy\u003d\"0\" stdDeviation\u003d\"3\" flood-color\u003d\"white\" flood-opacity\u003d\"0.9\" in\u003d\"SourceAlpha\" result\u003d\"shadow\"/\u003e\n      \u003cfeMerge\u003e\n       \u003cfeMergeNode in\u003d\"shadow\"/\u003e\n        \u003cfeMergeNode in\u003d\"SourceGraphic\"/\u003e\n      \u003c/feMerge\u003e\n    \u003c/filter\u003e\n  \u003c/defs\u003e\n  \u003cstyle\u003e\n    @import url(\u0027https://fonts.googleapis.com/css2?family\u003dNoto+Sans+JP:wght@400;500\u0026amp;family\u003dRoboto:wght@400\u0026amp;display\u003dswap\u0027);\n    .title { font-size: 24px; font-weight: 500; text-anchor: middle;\nfill: #5f6368; }\n    .subtitle { font-size: 16px; text-anchor: middle; fill: #5f6368;\n}\n    .source { font-size: 11px; fill: #70757a; text-anchor: end; }\n    .legend-item { font-size: 13px;\nfill: #202124; dominant-baseline: middle; }\n    .grid-line { stroke: #e0e0e0; stroke-dasharray: 2 2; stroke-width: 0.8;\n}\n    .zero-line { stroke: #bdbdbd; stroke-width: 1; }\n    .axis-label { font-size: 13px; fill: #5f6368;\ntext-anchor: middle; }\n    .y-axis-unit-label { font-family: \u0027Noto Sans JP\u0027, sans-serif; font-size: 12px; fill: #757575; text-anchor: start;\n}\n    .y-axis-value { font-family: \u0027Roboto\u0027, sans-serif; font-size: 12px;\nfill: #757575; text-anchor: end; }\n    .data-label { font-family: \u0027Roboto\u0027, sans-serif; font-size: 12px; font-weight: normal; text-anchor: middle;\nfilter: url(#text-halo-white); }\n  \u003c/style\u003e\n  \u003cg id\u003d\"title-group\"\u003e\u003c/g\u003e\n  \u003cg id\u003d\"legend-group\"\u003e\u003c/g\u003e\n  \u003cg id\u003d\"y-axis-group\"\u003e\u003c/g\u003e\n  \u003cg id\u003d\"x-axis-group\"\u003e\u003c/g\u003e\n  \u003cg id\u003d\"chart-area-group\"\u003e\u003c/g\u003e\n  \u003cg id\u003d\"source-group\"\u003e\u003c/g\u003e\n  \u003cscript type\u003d\"text/javascript\"\u003e\n    const svgNS \u003d \"http://www.w3.org/2000/svg\";\nfunction createSVGElement(name, attributes, textContent) {\n      const el \u003d document.createElementNS(svgNS, name);\nfor (const key in attributes) el.setAttribute(key, attributes[key]);\n      if (textContent !\u003d\u003d undefined \u0026\u0026 textContent !\u003d\u003d null) el.textContent \u003d textContent;\n      return el;\n}\n    function hexToRgb(hex) {\n      var shorthandRegex \u003d /^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i;\nhex \u003d hex.replace(shorthandRegex, function(m, r, g, b) {\n        return r + r + g + g + b + b;\n      });\nvar result \u003d /^#?([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/i.exec(hex);\n      return result ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16)\n      } : null;\n}\n    function rgbToHsl(r, g, b) {\n      r /\u003d 255;\ng /\u003d 255; b /\u003d 255;\n      var max \u003d Math.max(r, g, b), min \u003d Math.min(r, g, b);\nvar h, s, l \u003d (max + min) / 2;\n      l \u003d Math.round(l * 100);\n      if (max \u003d\u003d min) {\n        h \u003d s \u003d 0;\n      } else {\n        var d \u003d max - min;\ns \u003d l \u003e 50 ? d / (2 - max - min) : d / (max + min);\ns \u003d Math.round(s * 100);\n        switch (max) {\n          case r: h \u003d (g - b) / d + (g \u003c b ? 6 : 0);\nbreak;\n          case g: h \u003d (b - r) / d + 2; break;\ncase b: h \u003d (r - g) / d + 4; break;\n}\n        h /\u003d 6;\n}\n      h \u003d Math.round(h * 360);\n      return [h, s, l];\n}\n    function hslToRgb(h, s, l) {\n      var r, g, b;\nh /\u003d 360;\n      s /\u003d 100;\n      l /\u003d 100;\n      if (s \u003d\u003d 0) {\n        r \u003d g \u003d b \u003d l;\n      } else {\n        function hue2rgb(p, q, t) {\n          if (t \u003c 0) t +\u003d 1;\nif (t \u003e 1) t -\u003d 1;\n          if (t \u003c 1/6) return p + (q - p) * 6 * t;\nif (t \u003c 1/2) return q;\n          if (t \u003c 2/3) return p + (q - p) * (2/3 - t) * 6;\nreturn p;\n        }\n        var q \u003d l \u003c 0.5 ?\nl * (1 + s) : l + s - l * s;\nvar p \u003d 2 * l - q;\n        r \u003d hue2rgb(p, q, h + 1/3);\n        g \u003d hue2rgb(p, q, h);\nb \u003d hue2rgb(p, q, h - 1/3);\n      }\n      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\n}\n    function rgbToHex(r, g, b) {\n      function componentToHex(c) {\n        var hex \u003d c.toString(16);\nreturn hex.length \u003d\u003d 1 ? \"0\" + hex : hex;\n}\n      return \"#\" + componentToHex(r) + componentToHex(g) + componentToHex(b);\n}\n    function linearInterpolateColor(hex1, hex2, t) {\n      var rgb1 \u003d hexToRgb(hex1);\nvar rgb2 \u003d hexToRgb(hex2);\n      var r \u003d Math.round(rgb1.r + (rgb2.r - rgb1.r) * t);\nvar g \u003d Math.round(rgb1.g + (rgb2.g - rgb1.g) * t);\n      var b \u003d Math.round(rgb1.b + (rgb2.b - rgb1.b) * t);\nreturn rgbToHex(r, g, b);\n    }\n    function generateGradientScale(gradientStops, numSteps) {\n      var palette \u003d [];\nif (numSteps \u003c\u003d 0) return [];\n      if (numSteps \u003d\u003d\u003d 1) return [gradientStops[0]];\n      var numSegments \u003d gradientStops.length - 1;\nfor (var i \u003d 0; i \u003c numSteps; i++) {\n        var t_global \u003d (numSteps \u003d\u003d\u003d 1) ?\n0 : (i / (numSteps - 1));\n        var segmentProgress \u003d t_global * numSegments;\nvar stopIndex1 \u003d Math.floor(segmentProgress);\n        var stopIndex2 \u003d Math.min(stopIndex1 + 1, numSegments);\n        var t_local \u003d segmentProgress - stopIndex1;\nvar hex1 \u003d gradientStops[stopIndex1];\n        var hex2 \u003d gradientStops[stopIndex2];\n        palette.push(linearInterpolateColor(hex1, hex2, t_local));\n      }\n      return palette;\n}\n    function generateMonochromaticScale(primaryHex, colorIds) {\n        var numSteps \u003d colorIds.length;\n        if (numSteps \u003d\u003d\u003d 0) return [];\n        var rgb \u003d hexToRgb(primaryHex);\n        if (!rgb) return [];\n        var hsl \u003d rgbToHsl(rgb.r, rgb.g, rgb.b);\n        var h \u003d hsl[0], s \u003d hsl[1], l_mid_original \u003d hsl[2];\n        var gradientDarken \u003d 7;\n        var L_MAX \u003d 80; \n        var L_MIN \u003d 45;\n        var l_steps_start;\n        if (numSteps \u003d\u003d\u003d 1) {\n            l_steps_start \u003d [L_MIN];\n        } else {\n            var l_step_amount \u003d (L_MAX - L_MIN) / (numSteps - 1);\n            var l_steps_calc \u003d [];\n            for (var i \u003d 0; i \u003c numSteps; i++) {\n                var l_val \u003d L_MAX - (i * l_step_amount);\n                l_steps_calc.push(l_val);\n            }\n            var l_steps_light \u003d [];\n            var l_steps_dark \u003d [];\n            var mid_index \u003d Math.ceil(numSteps / 2);\n            for (var i \u003d 0; i \u003c mid_index; i++) {\n                l_steps_light.push(l_steps_calc[i]);\n            }\n            for (var i \u003d mid_index; i \u003c numSteps; i++) {\n                l_steps_dark.push(l_steps_calc[i]);\n            }\n            l_steps_start \u003d [];\n            for (var i \u003d 0; i \u003c numSteps; i++) {\n                if (i % 2 \u003d\u003d\u003d 0) {\n                    l_steps_start.push(l_steps_light[i / 2]);\n                } else {\n                    l_steps_start.push(l_steps_dark[(i - 1) / 2]);\n                }\n            }\n        }\n        var colors \u003d [];\n        for (var i \u003d 0; i \u003c numSteps; i++) {\n            var l_start_step \u003d l_steps_start[i];\n            var l_start \u003d Math.max(0, Math.min(100, l_start_step));\n            var l_end \u003d Math.max(0, Math.min(100, l_start - gradientDarken));\n            var s_adjusted \u003d s;\n            if (l_start \u003e 85) s_adjusted \u003d s * (1 - (l_start - 85) / 15);\n            if (l_start \u003c 20) s_adjusted \u003d s * (l_start / 20);\n            s_adjusted \u003d Math.max(0, Math.min(100, s_adjusted));\n            var rgb_start \u003d hslToRgb(h, s_adjusted, l_start);\n            var hex_start \u003d rgbToHex(rgb_start[0], rgb_start[1], rgb_start[2]);\n            var rgb_end \u003d hslToRgb(h, s_adjusted, l_end);\n            var hex_end \u003d rgbToHex(rgb_end[0], rgb_end[1], rgb_end[2]);\n            colors.push({\n                id: colorIds[i],\n                start: hex_start,\n                end: hex_end\n            });\n        }\n        return colors;\n    }\n    function buildChart(config) {\n      const svgRoot \u003d document.getElementById(\u0027multi-line-chart-svg\u0027);\nconst defs \u003d svgRoot.querySelector(\u0027defs\u0027);\n      const style \u003d svgRoot.querySelector(\u0027style\u0027);\n      const existingGrads \u003d defs.querySelectorAll(\u0027linearGradient\u0027);\nexistingGrads.forEach(function(grad) { grad.remove(); });\n      let styleContent \u003d style.textContent;\nconst dynamicRulePattern \u003d /\\.((line|marker|area|data-label)-[a-z])\\s*{[^}]*}/g;\n      styleContent \u003d styleContent.replace(dynamicRulePattern, \u0027\u0027);\n      style.textContent \u003d styleContent.trim();\n      const nl \u003d String.fromCharCode(10);\n      let dynamicStyleParts \u003d [];\n      config.colors.forEach(function(color) {\n        const id \u003d color.id;\n        const markerGradId \u003d \u0027markerGradient\u0027 + id;\n        const areaGradId \u003d \u0027areaGradient\u0027 + id;\n        const cssPrefix \n\u003d id.toLowerCase();\n        let markerGrad \u003d createSVGElement(\u0027linearGradient\u0027, { id: markerGradId, x1: \"0\", x2: \"0\", y1: \"0\", y2: \"1\" });\n        markerGrad.appendChild(createSVGElement(\u0027stop\u0027, { offset: \u00270%\u0027, \u0027stop-color\u0027: color.start }));\n        markerGrad.appendChild(createSVGElement(\u0027stop\u0027, { offset: \u0027100%\u0027, \u0027stop-color\u0027: color.end }));\n        defs.appendChild(markerGrad);\n        let areaGrad \u003d createSVGElement(\u0027linearGradient\u0027, { id: areaGradId, x1: \"0\", x2: \"0\", y1: \"0\", y2: \"1\" });\n      areaGrad.appendChild(createSVGElement(\u0027stop\u0027, { offset: \u00270%\u0027, \u0027stop-color\u0027: color.start, \u0027stop-opacity\u0027: \u00270.2\u0027 }));\n        areaGrad.appendChild(createSVGElement(\u0027stop\u0027, { offset: \u0027100%\u0027, \u0027stop-color\u0027: color.end, \u0027stop-opacity\u0027: \u00270\u0027 }));\ndefs.appendChild(areaGrad);\n        dynamicStyleParts.push(\".line-\" + cssPrefix + \" { fill: none; stroke: \" + color.end + \"; stroke-width: 3; stroke-linejoin: round; stroke-linecap: round; filter: url(#shadow); }\");\ndynamicStyleParts.push(\".marker-\" + cssPrefix + \" { fill: url(#\" + markerGradId + \"); stroke: white; stroke-width: 2; filter: url(#shadow); }\");\ndynamicStyleParts.push(\".area-\" + cssPrefix + \" { fill: url(#\" + areaGradId + \"); }\");\ndynamicStyleParts.push(\".data-label-\" + cssPrefix + \" { fill: \" + color.end + \"; }\");\n      });\n      const dynamicStyles \u003d dynamicStyleParts.join(nl);\n      style.textContent +\u003d nl + dynamicStyles + nl;\n      const groups \u003d {\n        title: document.getElementById(\u0027title-group\u0027),\n        legend: document.getElementById(\u0027legend-group\u0027),\n        yAxis: document.getElementById(\u0027y-axis-group\u0027),\n        xAxis: document.getElementById(\u0027x-axis-group\u0027),\n        chartArea: document.getElementById(\u0027chart-area-group\u0027),\n        source: document.getElementById(\u0027source-group\u0027)\n      };\n      for (const key in groups) {\n        while (groups[key].firstChild) groups[key].removeChild(groups[key].firstChild);\n}\n      const allValues \u003d config.series.reduce(function(acc, s) { return acc.concat(s.values); }, []);\nconst dataMin \u003d Math.min.apply(null, allValues.concat([config.yAxis.min]));\n      const dataMax \u003d Math.max.apply(null, allValues.concat([config.yAxis.max]));\n      let effectiveYAxisMin, effectiveYAxisMax;\nconst tickCount \u003d config.yAxis.tickCount \u003e 0 ? config.yAxis.tickCount : 1;\n      const preliminaryRange \u003d Math.max(1, config.yAxis.max - config.yAxis.min);\nlet tickInterval \u003d preliminaryRange / tickCount;\n      if (dataMin \u003c 0) {\n        const absLimit \u003d Math.max(Math.abs(dataMin), dataMax);\nif (tickInterval \u003c\u003d 0 || isNaN(tickInterval)) tickInterval \u003d Math.max(1, absLimit / 5);\n        effectiveYAxisMax \u003d Math.ceil(absLimit / tickInterval) * tickInterval;\neffectiveYAxisMin \u003d -effectiveYAxisMax;\n        if(config.yAxis.min \u003e effectiveYAxisMin) effectiveYAxisMin \u003d config.yAxis.min;\n        if(config.yAxis.max \u003c effectiveYAxisMax) effectiveYAxisMax \u003d config.yAxis.max;\n} else {\n        effectiveYAxisMin \u003d config.yAxis.min;\nif (tickInterval \u003c\u003d 0 || isNaN(tickInterval)) tickInterval \u003d Math.max(1, (dataMax - effectiveYAxisMin) / 5) || 1;\neffectiveYAxisMax \u003d Math.max(config.yAxis.max, Math.ceil(dataMax / tickInterval) * tickInterval);\n      }\n      if (effectiveYAxisMax \u003c\u003d effectiveYAxisMin) {\n        effectiveYAxisMax \u003d effectiveYAxisMin + tickInterval * tickCount;\nif (effectiveYAxisMax \u003c\u003d effectiveYAxisMin) effectiveYAxisMax \u003d effectiveYAxisMin + 1;\n      }\n      var yAxisRange \u003d effectiveYAxisMax - effectiveYAxisMin;\n      const tempYLabel \u003d createSVGElement(\u0027text\u0027, { class: \u0027y-axis-value\u0027, style: \u0027visibility: hidden;\u0027 }, Math.round(effectiveYAxisMax));\nsvgRoot.appendChild(tempYLabel);\n      const yAxisLabelWidth \u003d tempYLabel.getComputedTextLength();\n      svgRoot.removeChild(tempYLabel);\n      const dynamicMarginLeft \u003d Math.max(config.layout.marginLeft, yAxisLabelWidth + 15);\nconst chartAreaWidth \u003d config.layout.width - dynamicMarginLeft - config.layout.marginRight;\n      const chartAreaHeight \u003d config.layout.height - config.layout.marginTop - config.layout.marginBottom;\nconst bottomY \u003d config.layout.marginTop + chartAreaHeight;\n      const horizontalPadding \u003d config.layout.horizontalPadding ||\n0;\n      const effectivePlotWidth \u003d chartAreaWidth - (horizontalPadding * 2);\n      const numPoints \u003d config.xAxisLabels.length;\n      const xScale \u003d function(index) { return (dynamicMarginLeft + horizontalPadding) + (numPoints \u003e 1 ? (effectivePlotWidth * (index / (numPoints - 1))) : effectivePlotWidth / 2);\n};\n      const yScale \u003d function(value) { return bottomY - ((value - effectiveYAxisMin) / yAxisRange) * chartAreaHeight; };\n      const zeroLineY \u003d yScale(0);\n      var animProgress \u003d (config.animation \u003d\u003d null) \n          ? 1.0 \n          : Math.max(0, Math.min(1, Number(config.animation)));\n      var animOpacity;\n      var fadeStart \u003d 0.7;\n      if (animProgress \u003c\u003d fadeStart) {\n          animOpacity \u003d 0;\n      } else {\n          animOpacity \u003d (animProgress - fadeStart) / (1.0 - fadeStart);\n      }\n      groups.title.appendChild(createSVGElement(\u0027text\u0027, { x: 325, y: 40, class: \u0027title\u0027 }, config.title));\ngroups.title.appendChild(createSVGElement(\u0027text\u0027, { x: 325, y: 65, class: \u0027subtitle\u0027 }, config.subtitle));\ngroups.source.appendChild(createSVGElement(\u0027text\u0027, { x: config.layout.width - config.layout.marginRight, y: bottomY + 60, class: \u0027source\u0027 }, config.source));\n    const legendY \u003d 95;\n    const numLegends \u003d config.series.length;\n    const rectSize \u003d 12;\n    const rectTextGap \u003d 6;\n    const legendFontSize \u003d 13;\n    const fontSizeCharWidthRatio \u003d 1.0; \n    let maxCharCount \u003d 0;\n    config.series.forEach(function(series) {\n        const currentLabelLength \u003d (series.label !\u003d null) ? series.label.length : 0;\n        if (currentLabelLength \u003e maxCharCount) {\n            maxCharCount \u003d currentLabelLength;\n        }\n    });\n    const estimatedMaxTextWidth \u003d maxCharCount * legendFontSize * fontSizeCharWidthRatio;\n    const legendItemEndPadding \u003d 25;\n    const idealItemSlotWidth \u003d rectSize + rectTextGap + estimatedMaxTextWidth + legendItemEndPadding;\n    const totalIdealWidth \u003d idealItemSlotWidth * numLegends;\n    const availableLegendAreaLeft \u003d dynamicMarginLeft;\n    const availableLegendAreaRight \u003d config.layout.width - config.layout.marginRight;\n    const availableLegendAreaWidth \u003d availableLegendAreaRight - availableLegendAreaLeft;\n    let finalItemSlotWidth \u003d 0;\n    let legendBlockStartX \u003d 0;\n    if (totalIdealWidth \u003c\u003d availableLegendAreaWidth) {\n        finalItemSlotWidth \u003d idealItemSlotWidth;\n        const svgCenterX \u003d svgRoot.viewBox.baseVal.x + (svgRoot.viewBox.baseVal.width / 2);\n        legendBlockStartX \u003d svgCenterX - (totalIdealWidth / 2);\n    } else {\n        const constrainedItemSlotWidth \u003d availableLegendAreaWidth / numLegends;\n        finalItemSlotWidth \u003d constrainedItemSlotWidth;\n        legendBlockStartX \u003d availableLegendAreaLeft;\n    }\n    config.series.forEach(function(series, i) {\n        const columnStartX \u003d legendBlockStartX + (i * finalItemSlotWidth);\n        const itemGroup \u003d createSVGElement(\u0027g\u0027);\n        var colorEntry \u003d config.colors.find(function(c) { return c.id \u003d\u003d\u003d series.id; });\n        const color \u003d (colorEntry ? colorEntry.end : undefined) || \u0027#000\u0027;\n        itemGroup.appendChild(createSVGElement(\u0027rect\u0027, { x: columnStartX, y: legendY, width: rectSize, height: rectSize, rx: 2, fill: color, filter: \u0027url(#shadow)\u0027 }));\n        let labelContent \u003d series.label;\n        const textStartX \u003d columnStartX + rectSize + rectTextGap;\n        const availableTextWidth \u003d finalItemSlotWidth - (rectSize + rectTextGap) - (legendItemEndPadding / 2); \n        if (estimatedMaxTextWidth \u003e availableTextWidth) {\n            const tempText \u003d createSVGElement(\u0027text\u0027, { class: \u0027legend-item\u0027, style: \u0027visibility: hidden;\u0027 }, labelContent);\n            svgRoot.appendChild(tempText);\n            if (tempText.getComputedTextLength() \u003e availableTextWidth) {\n                labelContent \u003d labelContent.substring(0, Math.max(1, Math.floor(labelContent.length * availableTextWidth / tempText.getComputedTextLength()))) + \u0027..\u0027;\n            }\n            svgRoot.removeChild(tempText);\n        }\n        itemGroup.appendChild(createSVGElement(\u0027text\u0027, { x: textStartX, y: legendY + rectSize / 2, class: \u0027legend-item\u0027 }, labelContent));\n        groups.legend.appendChild(itemGroup);\n    });\n      groups.yAxis.appendChild(createSVGElement(\u0027text\u0027, {\n        x: 30,\n        y: config.layout.marginTop - 15,\n        class: \u0027y-axis-unit-label\u0027\n      }, config.yAxisUnitLabel));\n      const finalTickStep \u003d yAxisRange / tickCount;\nfor (let i \u003d 0; i \u003c\u003d tickCount; i++) {\n        const tickValue \u003d effectiveYAxisMin + (finalTickStep * i);\nconst y \u003d yScale(tickValue);\n        groups.yAxis.appendChild(createSVGElement(\u0027text\u0027, { x: dynamicMarginLeft - 10, y, class: \u0027y-axis-value\u0027, \u0027dominant-baseline\u0027: \u0027middle\u0027 }, Math.round(tickValue)));\nif (Math.abs(tickValue) \u003e 1e-6 || effectiveYAxisMin \u003e\u003d 0) {\n          groups.yAxis.appendChild(createSVGElement(\u0027line\u0027, { x1: dynamicMarginLeft, y1: y, x2: config.layout.width - config.layout.marginRight, y2: y, class: \u0027grid-line\u0027 }));\n}\n      }\n      if (effectiveYAxisMin \u003c 0 \u0026\u0026 effectiveYAxisMax \u003e 0) {\n        groups.xAxis.appendChild(createSVGElement(\u0027line\u0027, { x1: dynamicMarginLeft, y1: zeroLineY, x2: config.layout.width - config.layout.marginRight, y2: zeroLineY, class: \u0027zero-line\u0027 }));\n}\n      groups.xAxis.appendChild(createSVGElement(\u0027line\u0027, { x1: dynamicMarginLeft, y1: bottomY, x2: config.layout.width - config.layout.marginRight, y2: bottomY, class: \u0027zero-line\u0027 }));\n    const labelSlotWidth \u003d effectivePlotWidth / (numPoints \u003e 1 ? numPoints - 1 : 1);\n    const rotationThreshold \u003d 40; \n    const needsRotation \u003d (labelSlotWidth \u003c rotationThreshold \u0026\u0026 numPoints \u003e 1);\n    const labelYOffset \u003d needsRotation ? bottomY + 25 : bottomY + 30;\n    config.xAxisLabels.forEach(function(label, i) {\n      let labelContent \u003d label;\n      const x \u003d xScale(i); \n      const tempText \u003d createSVGElement(\u0027text\u0027, { class: \u0027axis-label\u0027, style: \u0027visibility: hidden;\u0027 });\n      svgRoot.appendChild(tempText);\n      tempText.textContent \u003d label;\n      if (numPoints \u003e 1 \u0026\u0026 tempText.getComputedTextLength() \u003e labelSlotWidth * 0.9 \u0026\u0026 !needsRotation) {\n        labelContent \u003d label.substring(0, Math.max(1, Math.floor(label.length * labelSlotWidth * 0.8 / tempText.getComputedTextLength()))) + \u0027..\u0027;\n      }\n      svgRoot.removeChild(tempText);\n      var attributes \u003d {\n        x: x,\n        y: labelYOffset,\n        class: \u0027axis-label\u0027\n      };\n      if (needsRotation) {\n        attributes[\u0027text-anchor\u0027] \u003d \u0027end\u0027;\n        attributes[\u0027dominant-baseline\u0027] \u003d \u0027middle\u0027;\n        attributes.transform \u003d \u0027rotate(-45, \u0027 + x + \u0027, \u0027 + labelYOffset + \u0027)\u0027;\n      } else {\n      }\n      groups.xAxis.appendChild(createSVGElement(\u0027text\u0027, attributes, labelContent));\n    });\n    const lastDataPoints \u003d [];\n    const totalLabelCharThreshold \u003d 75;\n    config.series.forEach(function(series, seriesIndex) {\n        if (!series.values || series.values.length \u003d\u003d\u003d 0) return;\n        const cssPrefix \u003d series.id.toLowerCase();\n        const areaBaselineY \u003d yScale(Math.max(0, effectiveYAxisMin));\n        var pointsData \u003d series.values.map(function(v, i) {\n            var x \u003d xScale(i);\n            var finalY \u003d yScale(v);\n            var animatedY \u003d areaBaselineY + (finalY - areaBaselineY) * animProgress;\n            return {\n                x: x,\n                finalY: finalY,\n                animatedY: animatedY,\n                value: v\n            };\n        });\n        var points \u003d pointsData.map(function(d) { return d.x + \u0027,\u0027 + d.animatedY; }).join(\u0027 \u0027);\n        var areaPoints \u003d xScale(0) + \u0027,\u0027 + areaBaselineY \n            + \u0027 \u0027 + points + \u0027 \u0027 + xScale(series.values.length - 1) + \u0027,\u0027 + areaBaselineY;\n        groups.chartArea.appendChild(createSVGElement(\u0027polygon\u0027, { class: \u0027area-\u0027 + cssPrefix, points: areaPoints }));\n        groups.chartArea.appendChild(createSVGElement(\u0027polyline\u0027, { class: \u0027line-\u0027 + cssPrefix, points: points }));\n        var totalLabelChars \u003d 0;\n        series.values.forEach(function(value) {\n            totalLabelChars +\u003d (value !\u003d null) ? value.toString().length : 0;\n        });\n        const skipEveryOtherForThisSeries \u003d (totalLabelChars \u003e totalLabelCharThreshold);\n        pointsData.forEach(function(pointData, i) {\n            var pointForLabel \u003d { \n                x: pointData.x, \n                y: pointData.finalY,\n                value: pointData.value, \n                seriesIndex: seriesIndex,\n                skip: (skipEveryOtherForThisSeries \u0026\u0026 i % 2 \u003d\u003d\u003d 1)\n            };\n            lastDataPoints.push(pointForLabel);\n            groups.chartArea.appendChild(createSVGElement(\u0027circle\u0027, { \n                cx: pointData.x, \n                cy: pointData.animatedY,\n                r: config.lineOptions.markerRadius, \n                class: \u0027marker-\u0027 + cssPrefix \n            }));\n        });\n    });\n    lastDataPoints.sort(function(a, b) { return a.x - b.x || a.y - b.y; });\n    const drawnLabels \u003d [];\n    lastDataPoints.forEach(function(point) {\n        if (point.skip) {\n            return;\n        }\n        const series \u003d config.series[point.seriesIndex];\n        const cssPrefix \u003d series.id.toLowerCase();\n        const verticalThreshold \u003d 18;\n        const horizontalThreshold \u003d labelSlotWidth * 0.4;\n        const pointThreshold \u003d config.lineOptions.markerRadius + 12;\n        const yAbove \u003d point.y - config.lineOptions.dataLabelOffsetY - config.lineOptions.markerRadius;\n        const yBelow \u003d point.y + config.lineOptions.dataLabelOffsetY + config.lineOptions.markerRadius + 6;\n        let finalLabelY \u003d yAbove;\n        let shouldDraw \u003d true;\n        let collidesUpLabel \u003d false;\n        let collidesUpPoint \u003d false;\n        for (const drawn of drawnLabels) {\n            if (Math.abs(point.x - drawn.x) \u003c horizontalThreshold \u0026\u0026 Math.abs(yAbove - drawn.y) \u003c verticalThreshold) {\n                collidesUpLabel \u003d true;\n                break;\n            }\n        }\n        if (!collidesUpLabel) {\n             for (const otherPoint of lastDataPoints) { \n                if (point.seriesIndex \u003d\u003d\u003d otherPoint.seriesIndex) continue;\n                if (Math.abs(point.x - otherPoint.x) \u003c horizontalThreshold \u0026\u0026 Math.abs(yAbove - otherPoint.y) \u003c pointThreshold) {\n                    collidesUpPoint \u003d true;\n                    break;\n                }\n            }\n        }\n        let collidesDownLabel \u003d false;\n        if (collidesUpLabel || collidesUpPoint) {\n            for (const drawn of drawnLabels) {\n                if (Math.abs(point.x - drawn.x) \u003c horizontalThreshold \u0026\u0026 Math.abs(yBelow - drawn.y) \u003c verticalThreshold) {\n                    collidesDownLabel \u003d true;\n                    break;\n                }\n            }\n        }\n        if (collidesUpLabel) {\n            if (collidesDownLabel) {\n                shouldDraw \u003d false;\n            } else {\n                finalLabelY \u003d yBelow;\n            }\n        } else if (collidesUpPoint) {\n            if (collidesDownLabel) {\n                finalLabelY \u003d yAbove;\n            } else {\n                finalLabelY \u003d yBelow;\n            }\n        } else {\n            finalLabelY \u003d yAbove;\n        }\n        if (shouldDraw) {\n            groups.chartArea.appendChild(createSVGElement(\u0027text\u0027, { \n                x: point.x, \n                y: finalLabelY,\n                class: \u0027data-label data-label-\u0027 + cssPrefix,\n                style: \u0027opacity: \u0027 + animOpacity \n            }, point.value));\n            drawnLabels.push({x: point.x, y: finalLabelY});\n        }\n    });\n}\n    try {\n      const configJson \u003d document.getElementById(\u0027chart-json-data\u0027).textContent;\nif (!configJson || configJson.trim() \u003d\u003d\u003d \u0027\u0027) {\n        throw new Error(\"JSON data is empty.\");\n}\n      let fullConfig;\n      try {\n        fullConfig \u003d JSON.parse(configJson);\n} catch (parseError) {\n        throw new Error(\u0027JSON parsing error: \u0027 + parseError.message);\n      }\n      if (!fullConfig || typeof fullConfig !\u003d\u003d \u0027object\u0027 || !fullConfig.data) {\n        throw new Error(\"Invalid JSON structure: Missing \u0027data\u0027 key.\");\n}\n      const config \u003d fullConfig.data;\n      if (config.colors \u0026\u0026 typeof config.colors \u003d\u003d\u003d \u0027string\u0027) {\n        const seriesIds \u003d config.series.map(function(s) { return s.id; });\nconst numColors \u003d seriesIds.length;\n        let generatedColors;\n        const colorKeyword \u003d config.colors.toLowerCase();\nconst gradientDarken \u003d 15;\n        if (colorKeyword \u003d\u003d\u003d \u0027#gemini\u0027) {\n          const GEMINI_STOPS \u003d [\u0027#E68A9C\u0027, \u0027#9F63D0\u0027, \u0027#616AD8\u0027];\nconst hexPalette \u003d generateGradientScale(GEMINI_STOPS, numColors);\n          generatedColors \u003d [];\n          for (let i \u003d 0; i \u003c numColors; i++) {\n            const hex_start \u003d hexPalette[i];\nconst rgb_start \u003d hexToRgb(hex_start);\n            const hsl \u003d rgbToHsl(rgb_start.r, rgb_start.g, rgb_start.b);\n            const h \u003d hsl[0], s \u003d hsl[1], l \u003d hsl[2];\nconst l_end \u003d Math.max(0, Math.min(100, l - gradientDarken));\n            const rgb_end \u003d hslToRgb(h, s, l_end);\n            const hex_end \u003d rgbToHex(rgb_end[0], rgb_end[1], rgb_end[2]);\ngeneratedColors.push({\n              id: seriesIds[i],\n              start: hex_start,\n              end: hex_end\n            });\n}\n        } else if (colorKeyword \u003d\u003d\u003d \u0027#night\u0027) {\n          var NIGHT_COLORS \u003d [\n            { start: \u0027#8d58d3\u0027, end: \u0027#704ca4\u0027 },\n            { start: \u0027#8f83d6\u0027, end: \n\u0027#7469a8\u0027 },\n            { start: \u0027#7891dd\u0027, end: \u0027#5c6fbb\u0027 },\n            { start: \u0027#50a89d\u0027, end: \u0027#258a7f\u0027 },\n            { start: \u0027#54c5d5\u0027, end: \u0027#34a0b0\u0027 }\n          ];\ngeneratedColors \u003d [];\n          var M_numColors \u003d numColors;\n          var N_paletteSize \u003d NIGHT_COLORS.length;\n          if (M_numColors \u003c\u003d N_paletteSize) {\n            for (var i \u003d 0; i \u003c M_numColors; i++) {\n              var progress \u003d (M_numColors \n\u003d\u003d\u003d 1) ? 0 : (i / (M_numColors - 1));\n              var colorIndex \u003d Math.round(progress * (N_paletteSize - 1));\nvar colorPair \u003d NIGHT_COLORS[colorIndex];\n              generatedColors.push({\n                id: seriesIds[i],\n                start: colorPair.start,\n                end: colorPair.end\n              });\n}\n          } else {\n            for (var i \u003d 0; i \u003c M_numColors; i++) {\n              var colorPair \u003d NIGHT_COLORS[i] ||\nNIGHT_COLORS[N_paletteSize - 1];\n              generatedColors.push({\n                id: seriesIds[i],\n                start: colorPair.start,\n                end: colorPair.end\n              });\n}\n          }\n        } else {\n          const primaryColor \u003d config.colors;\n          generatedColors \u003d generateMonochromaticScale(primaryColor, seriesIds);\n          if (generatedColors.length \u003d\u003d\u003d 0) {\n             throw new Error(\"Invalid HEX color string in \u0027colors\u0027: \" + primaryColor);\n}\n        }\n        if (generatedColors \u0026\u0026 generatedColors.length \u003e 0) {\n          config.colors \u003d generatedColors;\n} else {\n           throw new Error(\"Failed to generate colors from keyword: \" + config.colors);\n}\n      } else if (!config.colors || !Array.isArray(config.colors)) {\n         throw new Error(\"\u0027colors\u0027 must be an array of color objects or a single primary color string.\");\n}\n      if (!config.lineOptions) {\n        config.lineOptions \u003d {};\n      }\n      if (config.lineOptions.markerRadius \u003d\u003d null) {\n        config.lineOptions.markerRadius \u003d 5;\n}\n      if (config.lineOptions.dataLabelOffsetY \u003d\u003d null) {\n        config.lineOptions.dataLabelOffsetY \u003d 8;\n}\n      if (!config || typeof config !\u003d\u003d \u0027object\u0027 || !config.series || !Array.isArray(config.series)) {\n        throw new Error(\"Invalid JSON structure: Missing required fields like \u0027series\u0027 inside \u0027data\u0027.\");\n}\n      buildChart(config);\n    } catch (e) {\n      console.error(\"Chart Error:\", e);\nconst svgRoot \u003d document.getElementById(\u0027multi-line-chart-svg\u0027);\n      const existingError \u003d svgRoot.querySelector(\u0027.error-message\u0027);\n      if(existingError) existingError.remove();\nconst textEl \u003d createSVGElement(\u0027text\u0027, {\n        x: svgRoot.viewBox.baseVal.width / 2 + (svgRoot.viewBox.baseVal.x || 0),\n        y: svgRoot.viewBox.baseVal.height / 2 + (svgRoot.viewBox.baseVal.y || 0),\n        \u0027text-anchor\u0027: \u0027middle\u0027,\n        fill: \u0027red\u0027,\n        \u0027font-family\u0027: \"\u0027Noto Sans JP\u0027, sans-serif\",\n        class: \u0027error-message\u0027\n      });\ntextEl.textContent \u003d e.message.includes(\u0027JSON\u0027) ? \u0027JSONデータにエラーがあります。\u0027 : \u0027グラフ描画エラーが発生しました。\u0027;\n      if (e.message.includes(\u0027JSON parsing error\u0027)) {\n        textEl.textContent +\u003d \u0027 (\u0027 + e.message.split(\u0027: \u0027)[1] + \u0027)\u0027;\n      }\n      svgRoot.appendChild(textEl);\n}\n  \u003c/script\u003e\n\u003c/svg\u003e\n`;\nconst STACKED_BAR_CHART_TEMPLATE \u003d `\n\u003csvg width\u003d\"600\" height\u003d\"550\" viewBox\u003d\"25 0 575 570\" xmlns\u003d\"http://www.w3.org/2000/svg\" font-family\u003d\"\u0027Noto Sans JP\u0027, sans-serif\" id\u003d\"stacked-bar-chart-svg\"\u003e\n  \u003cscript id\u003d\"chart-json-data\" type\u003d\"application/json\"\u003e\n    {\n      \"chartType\": \"stacked-bar\",\n      \"data\": {\n        \"title\": \"サンプルグラフ：カテゴリ別数量\",\n        \"subtitle\": \"（月別サンプルデータ）\",\n        \"source\": \"出典：サンプルデータソース\",\n        \"yAxisUnitLabel\": \"（単位）\",\n        \"colors\": [\n          { \"id\": \"A\", \"start\": \"#e68a9c\", \"end\": \"#d96d8f\" },\n      { \"id\": \"B\", \"start\": \"#b469b8\", \"end\": \"#a656ad\" },\n          { \"id\": \"C\", \"start\": \"#9f63d0\", \"end\": \"#8c4fc8\" },\n          { \"id\": \"D\", \"start\": \"#7c6ce8\", \"end\": \"#6b5ce0\" },\n          { \"id\": \"E\", \"start\": \"#616ad8\", \"end\": \"#5059d1\" }\n        ],\n        \"legendLabels\": [\"項目 A\", \"項目 B\", \"項目 C\", \"項目 D\", \"項目 E\"],\n        \"barData\": [\n         { \"label\": \"サンプル 1\", \"values\": [60, 50, 40, 25, 20] },\n          { \"label\": \"サンプル 2\", \"values\": [90, 60, 50, 40, 25] },\n          { \"label\": \"サンプル 3\", \"values\": [60, 80, 70, 50, 30] },\n          { \"label\": \"サンプル 4\", \"values\": [40, 50, 60, 70, 80] },\n          { \"label\": \"サンプル 5\", \"values\": [70, 30, 55, 45, 65] }\n       ],\n        \"layout\": {\n          \"width\": 600,\n          \"height\": 550,\n          \"marginTop\": 170,\n          \"marginBottom\": 50,\n          \"marginLeft\": 75,\n          \"marginRight\": 50\n        },\n        \"barOptions\": {\n         \"width\": 50,\n          \"cornerRadius\": 4,\n          \"totalLabelOffset\": 10\n        },\n        \"yAxis\": {\n          \"max\": 300,\n          \"tickCount\": 3\n        },\n        \"animation\": 1\n      }\n    }\n  \u003c/script\u003e\n  \u003cdefs\u003e\n    \u003cfilter id\u003d\"shadow\" x\u003d\"-10%\" \ny\u003d\"-10%\" width\u003d\"120%\" height\u003d\"120%\"\u003e\u003cfeDropShadow dx\u003d\"1\" dy\u003d\"2\" stdDeviation\u003d\"1.5\" flood-color\u003d\"#000\" flood-opacity\u003d\"0.3\"/\u003e\u003c/filter\u003e\n    \u003cfilter id\u003d\"text-shadow\"\u003e\u003cfeDropShadow dx\u003d\"1\" dy\u003d\"1\" stdDeviation\u003d\"1\" flood-color\u003d\"#000\" flood-opacity\u003d\"0.7\"/\u003e\u003c/filter\u003e\n  \u003c/defs\u003e\n  \u003cstyle\u003e\n    @import url(\u0027https://fonts.googleapis.com/css2?family\u003dNoto+Sans+JP:wght@400;500;700\u0026amp;family\u003dRoboto:wght@400;700\u0026amp;display\u003dswap\u0027);\n    .bar-segment { filter: url(#shadow);\n}\n    .axis-label { font-size: 13px; fill: #5f6368; text-anchor: middle;\n}\n    .title { font-size: 24px;\nfont-weight: 500; text-anchor: middle; fill: #5f6368; }\n    .subtitle { font-size: 16px; text-anchor: middle; fill: #5f6368;\n} \n    .source { font-size: 11px; fill: #70757a; text-anchor: end;\n}\n    .grid-line { stroke: #e0e0e0; stroke-dasharray: 2 2; stroke-width: 0.8;\n}\n    .legend-item { font-size: 13px; fill: #202124; dominant-baseline: middle;\n}\n    .segment-label { font-family: \u0027Roboto\u0027, sans-serif; font-size: 13px; font-weight: normal;\nfill: white; filter: url(#text-shadow); text-anchor: middle; pointer-events: none; }\n    .total-label { font-family: \u0027Roboto\u0027, sans-serif; font-size: 14px;\nfont-weight: bold; fill: #5f6368; text-anchor: middle; }\n    .y-axis-value { font-family: \u0027Roboto\u0027, sans-serif; font-size: 12px; fill: #757575;\ntext-anchor: end; }\n  \u003c/style\u003e\n  \u003cg id\u003d\"title-group\"\u003e\u003c/g\u003e\n  \u003cg id\u003d\"legend-group\"\u003e\u003c/g\u003e\n  \u003cg id\u003d\"y-axis-group\"\u003e\u003c/g\u003e\n  \u003cg id\u003d\"chart-area-group\"\u003e\u003c/g\u003e\n  \u003cg id\u003d\"source-group\"\u003e\u003c/g\u003e\n  \u003cscript type\u003d\"text/javascript\"\u003e\n    var svgNS \u003d \"http://www.w3.org/2000/svg\";\nfunction createSVGElement(name, attributes, textContent) {\n      var el \u003d document.createElementNS(svgNS, name);\nfor (var key in attributes) el.setAttribute(key, attributes[key]);\n      if (textContent !\u003d\u003d undefined \u0026\u0026 textContent !\u003d\u003d null) {\n        el.textContent \u003d textContent;\n}\n      return el;\n    }\n    function getEstimatedTextWidth(text, fontSize) {\n        var width \u003d 0;\n        var fullWidthCharSize \u003d fontSize;\n        var halfWidthCharSize \u003d fontSize * 0.6;\n        if (!text) return 0;\n        for (var i \u003d 0; i \u003c text.length; i++) {\n            var charCode \u003d text.charCodeAt(i);\n            if ((charCode \u003e\u003d 0x0020 \u0026\u0026 charCode \u003c\u003d 0x007E) || (charCode \u003e\u003d 0xFF61 \u0026\u0026 charCode \u003c\u003d 0xFF9F)) {\n                width +\u003d halfWidthCharSize;\n            } else {\n                width +\u003d fullWidthCharSize;\n            }\n        }\n        return width;\n    }\n    function hexToRgb(hex) {\n      var shorthandRegex \u003d /^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i;\nhex \u003d hex.replace(shorthandRegex, function(m, r, g, b) {\n        return r + r + g + g + b + b;\n      });\nvar result \u003d /^#?([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/i.exec(hex);\n      return result ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16)\n      } : null;\n}\n    function rgbToHsl(r, g, b) {\n      r /\u003d 255;\ng /\u003d 255; b /\u003d 255;\n      var max \u003d Math.max(r, g, b), min \u003d Math.min(r, g, b);\nvar h, s, l \u003d (max + min) / 2;\n      l \u003d Math.round(l * 100);\n      if (max \u003d\u003d min) {\n        h \u003d s \u003d 0;\n      } else {\n        var d \u003d max - min;\ns \u003d l \u003e 50 ? d / (2 - max - min) : d / (max + min);\ns \u003d Math.round(s * 100);\n        switch (max) {\n          case r: h \u003d (g - b) / d + (g \u003c b ? 6 : 0);\nbreak;\n          case g: h \u003d (b - r) / d + 2; break;\ncase b: h \u003d (r - g) / d + 4; break;\n}\n        h /\u003d 6;\n}\n      h \u003d Math.round(h * 360);\n      return [h, s, l];\n}\n    function hslToRgb(h, s, l) {\n      var r, g, b;\nh /\u003d 360;\n      s /\u003d 100;\n      l /\u003d 100;\n      if (s \u003d\u003d 0) {\n        r \u003d g \u003d b \u003d l;\n      } else {\n        function hue2rgb(p, q, t) {\n          if (t \u003c 0) t +\u003d 1;\nif (t \u003e 1) t -\u003d 1;\n          if (t \u003c 1/6) return p + (q - p) * 6 * t;\nif (t \u003c 1/2) return q;\n          if (t \u003c 2/3) return p + (q - p) * (2/3 - t) * 6;\nreturn p;\n        }\n        var q \u003d l \u003c 0.5 ?\nl * (1 + s) : l + s - l * s;\nvar p \u003d 2 * l - q;\n        r \u003d hue2rgb(p, q, h + 1/3);\n        g \u003d hue2rgb(p, q, h);\nb \u003d hue2rgb(p, q, h - 1/3);\n      }\n      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\n}\n    function rgbToHex(r, g, b) {\n      function componentToHex(c) {\n        var hex \u003d c.toString(16);\nreturn hex.length \u003d\u003d 1 ? \"0\" + hex : hex;\n}\n      return \"#\" + componentToHex(r) + componentToHex(g) + componentToHex(b);\n}\n    function linearInterpolateColor(hex1, hex2, t) {\n      var rgb1 \u003d hexToRgb(hex1);\nvar rgb2 \u003d hexToRgb(hex2);\n      var r \u003d Math.round(rgb1.r + (rgb2.r - rgb1.r) * t);\nvar g \u003d Math.round(rgb1.g + (rgb2.g - rgb1.g) * t);\n      var b \u003d Math.round(rgb1.b + (rgb2.b - rgb1.b) * t);\nreturn rgbToHex(r, g, b);\n    }\n    function generateGradientScale(gradientStops, numSteps) {\n      var palette \u003d [];\nif (numSteps \u003c\u003d 0) return [];\n      if (numSteps \u003d\u003d\u003d 1) return [gradientStops[0]];\n      var numSegments \u003d gradientStops.length - 1;\nfor (var i \u003d 0; i \u003c numSteps; i++) {\n        var t_global \u003d (numSteps \u003d\u003d\u003d 1) ?\n0 : (i / (numSteps - 1));\n        var segmentProgress \u003d t_global * numSegments;\nvar stopIndex1 \u003d Math.floor(segmentProgress);\n        var stopIndex2 \u003d Math.min(stopIndex1 + 1, numSegments);\n        var t_local \u003d segmentProgress - stopIndex1;\nvar hex1 \u003d gradientStops[stopIndex1];\n        var hex2 \u003d gradientStops[stopIndex2];\n        palette.push(linearInterpolateColor(hex1, hex2, t_local));\n      }\n      return palette;\n}\n    function generateMonochromaticScale(primaryHex, colorIds) {\n      var numSteps \u003d colorIds.length;\nif (numSteps \u003d\u003d\u003d 0) return [];\n      var rgb \u003d hexToRgb(primaryHex);\n      if (!rgb) return [];\n      var hsl \u003d rgbToHsl(rgb.r, rgb.g, rgb.b);\nvar h \u003d hsl[0], s \u003d hsl[1], l_mid_original \u003d hsl[2];\n      var gradientDarken \u003d 7;\n      var L_MAX \u003d 80; \n      var L_MIN \u003d 45;\nvar l_step_amount \u003d numSteps \u003e 1 ? (L_MAX - L_MIN) / (numSteps - 1) : 0;\n      var l_steps_calc \u003d [];\nfor (var i \u003d 0; i \u003c numSteps; i++) {\n        var l_val \u003d L_MAX - (i * l_step_amount);\nl_steps_calc.push(l_val);\n      }\n      var l_steps_light \u003d [];\nvar l_steps_dark \u003d [];\n      var mid_index \u003d Math.ceil(numSteps / 2);\n      for (var i \u003d 0; i \u003c mid_index; i++) {\n        l_steps_light.push(l_steps_calc[i]);\n}\n      for (var i \u003d mid_index; i \u003c numSteps; i++) {\n        l_steps_dark.push(l_steps_calc[i]);\n}\n      var l_steps_start \u003d [];\nfor (var i \u003d 0; i \u003c numSteps; i++) {\n        if (i % 2 \u003d\u003d\u003d 0) {\n          l_steps_start.push(l_steps_light[i / 2]);\n} else {\n          l_steps_start.push(l_steps_dark[(i - 1) / 2]);\n}\n      }\n      var colors \u003d [];\nfor (var i \u003d 0; i \u003c numSteps; i++) {\n        var l_start_step \u003d l_steps_start[i];\nvar l_start \u003d Math.max(0, Math.min(100, l_start_step));\n        var l_end \u003d Math.max(0, Math.min(100, l_start - gradientDarken));\n        var s_adjusted \u003d s;\nif (l_start \u003e 85) s_adjusted \u003d s * (1 - (l_start - 85) / 15);\nif (l_start \u003c 20) s_adjusted \u003d s * (l_start / 20);\n        s_adjusted \u003d Math.max(0, Math.min(100, s_adjusted));\nvar rgb_start \u003d hslToRgb(h, s_adjusted, l_start);\n        var hex_start \u003d rgbToHex(rgb_start[0], rgb_start[1], rgb_start[2]);\n        var rgb_end \u003d hslToRgb(h, s_adjusted, l_end);\nvar hex_end \u003d rgbToHex(rgb_end[0], rgb_end[1], rgb_end[2]);\n        colors.push({\n          id: colorIds[i],\n          start: hex_start,\n          end: hex_end\n        });\n}\n      return colors;\n    }\n    function buildChart(config) {\n      var chartConfig \u003d config;\nvar colorConfig \u003d config.colors;\n      var svgRoot \u003d document.getElementById(\u0027stacked-bar-chart-svg\u0027);\n      var defs \u003d svgRoot.querySelector(\u0027defs\u0027);\n      var existingGrads \u003d defs.querySelectorAll(\u0027linearGradient\u0027);\n      existingGrads.forEach(function(grad) { grad.remove(); });\n      var styleContent \u003d document.querySelector(\u0027style\u0027).textContent;\n      var dynamicRulePattern \u003d /\\.bar-[a-z]\\s*{[^}]*}/g;\n      styleContent \u003d styleContent.replace(dynamicRulePattern, \u0027\u0027);\n      document.querySelector(\u0027style\u0027).textContent \u003d styleContent.trim();\n      var dynamicStyles \u003d [];\n      colorConfig.forEach(function(color) {\n        var gradId \u003d \u0027grad\u0027 + color.id;\n        var cssClass \u003d \u0027bar-\u0027 + color.id.toLowerCase();\n        var gradient \u003d createSVGElement(\u0027linearGradient\u0027, { id: gradId, x1:\"0\", x2:\"0\", y1:\"0\", y2:\"1\" });\n        gradient.appendChild(createSVGElement(\u0027stop\u0027, { offset: \u00270%\u0027, \u0027stop-color\u0027: color.start }));\n        gradient.appendChild(createSVGElement(\u0027stop\u0027, { offset: \u0027100%\u0027, \u0027stop-color\u0027: color.end }));\n        defs.appendChild(gradient);\n        dynamicStyles.push(\u0027.\u0027 + cssClass + \u0027 { fill: url(#\u0027 + gradId + \u0027); }\u0027);\n      });\n      document.querySelector(\u0027style\u0027).textContent +\u003d dynamicStyles.join(String.fromCharCode(10));\n      var titleGroup \u003d document.getElementById(\u0027title-group\u0027);\nvar legendGroup \u003d document.getElementById(\u0027legend-group\u0027);\n      var yAxisGroup \u003d document.getElementById(\u0027y-axis-group\u0027);\n      var chartAreaGroup \u003d document.getElementById(\u0027chart-area-group\u0027);\n      var sourceGroup \u003d document.getElementById(\u0027source-group\u0027);\n      var groups \u003d [titleGroup, legendGroup, yAxisGroup, chartAreaGroup, sourceGroup];\nfor(var i \u003d 0; i \u003c groups.length; i++) {\n        var group \u003d groups[i];\nwhile (group.firstChild) group.removeChild(group.firstChild);\n      }\n      var chartAreaWidth \u003d chartConfig.layout.width - chartConfig.layout.marginLeft - chartConfig.layout.marginRight;\nvar chartAreaHeight \u003d chartConfig.layout.height - chartConfig.layout.marginTop - chartConfig.layout.marginBottom;\n      var bottomY \u003d chartConfig.layout.marginTop + chartAreaHeight;\n      var totals \u003d chartConfig.barData.map(function(d) { \n        return d.values.reduce(function(sum, v) { return sum + v; }, 0); \n      });\nvar maxTotal \u003d Math.max.apply(null, totals.concat([config.yAxis.max]));\n      var tickCount \u003d chartConfig.yAxis.tickCount \u003e 0 ?\nchartConfig.yAxis.tickCount : 1;\n      var preliminaryTickInterval \u003d (config.yAxis.max \u003e 0 \u0026\u0026 tickCount \u003e 0) ? config.yAxis.max / tickCount : 1;\n      var effectiveYAxisMax \u003d Math.max(config.yAxis.max, Math.ceil(maxTotal / preliminaryTickInterval) * preliminaryTickInterval);\n      if (effectiveYAxisMax \u003c\u003d 0) effectiveYAxisMax \u003d preliminaryTickInterval * tickCount;\n      if (effectiveYAxisMax \u003d\u003d\u003d 0) effectiveYAxisMax \u003d 1;\n      var yAxisRange \u003d effectiveYAxisMax;\n      var xScale \u003d function(index) { return chartConfig.layout.marginLeft + (chartAreaWidth / chartConfig.barData.length) * (index + 0.5);\n};\n      var yScale \u003d function(value) { return bottomY - (value / effectiveYAxisMax) * chartAreaHeight; };\n      var animProgress \u003d (config.animation \u003d\u003d null) \n          ? 1.0 \n          : Math.max(0, Math.min(1, Number(config.animation)));\n      var animOpacity;\n      var fadeStart \u003d 0.7;\n      if (animProgress \u003c\u003d fadeStart) {\n          animOpacity \u003d 0;\n      } else {\n          animOpacity \u003d (animProgress - fadeStart) / (1.0 - fadeStart);\n      }\n      var svgWidth \u003d svgRoot.viewBox.baseVal.width;\ntitleGroup.appendChild(createSVGElement(\u0027text\u0027, { x: svgWidth/2, y: 50, class: \u0027title\u0027 }, chartConfig.title));\n      titleGroup.appendChild(createSVGElement(\u0027text\u0027, { x: svgWidth/2, y: 75, class: \u0027subtitle\u0027 }, chartConfig.subtitle));\nsourceGroup.appendChild(createSVGElement(\u0027text\u0027, { x: 600, y: 555, class: \u0027source\u0027 }, chartConfig.source));\n//\n      var legendY \u003d 110;\n      var numLegends \u003d chartConfig.legendLabels.length;\n      var legendStartX \u003d chartConfig.layout.marginLeft;\n      var rectSize \u003d 12;\n      var rectTextGap \u003d 6;\n      var legendFontSize \u003d 13;\n      var legendPadding \u003d 15;\n      var requiredWidths \u003d chartConfig.legendLabels.map(function(label) {\n          var textWidth \u003d getEstimatedTextWidth(label, legendFontSize);\n          return rectSize + rectTextGap + textWidth + legendPadding;\n      });\n      var totalRequiredWidth \u003d requiredWidths.reduce(function(sum, w) { return sum + w; }, 0) - legendPadding;\n      if (numLegends \u003d\u003d\u003d 0) totalRequiredWidth \u003d 0;\n      var useEqualWidths \u003d false;\n      var legendColumnWidth \u003d 0;\n      if (totalRequiredWidth \u003e chartAreaWidth || numLegends \u003d\u003d\u003d 0) {\n          useEqualWidths \u003d true;\n          legendColumnWidth \u003d (numLegends \u003e 0) ? (chartAreaWidth / numLegends) : 0;\n      } else {\n          useEqualWidths \u003d false;\n          legendStartX \u003d chartConfig.layout.marginLeft + (chartAreaWidth - totalRequiredWidth) / 2;\n      }\n      var currentX \u003d legendStartX;\n      chartConfig.legendLabels.forEach(function(label, i) {\n        var cssClass \u003d \u0027bar-\u0027 + colorConfig[i].id.toLowerCase();\n        var columnStartX;\n        var currentColumnWidth;\n        if (useEqualWidths) {\n            columnStartX \u003d legendStartX + (i * legendColumnWidth);\n            currentColumnWidth \u003d legendColumnWidth;\n        } else {\n            columnStartX \u003d currentX;\n            currentColumnWidth \u003d requiredWidths[i];\n            currentX +\u003d currentColumnWidth;\n        }\n        var itemGroup \u003d createSVGElement(\u0027g\u0027);\n        itemGroup.appendChild(createSVGElement(\u0027rect\u0027, {\n          x: columnStartX, y: legendY, width: rectSize, height: rectSize, rx: 2, class: \u0027bar-segment \u0027 + cssClass\n        }));\n        var textX \u003d columnStartX + rectSize + rectTextGap;\n        var clipId \u003d \u0027legend-clip-\u0027 + i;\n        var clipMargin \u003d (legendPadding / 2);\n        if (useEqualWidths) clipMargin \u003d 5;\n        var clipWidth \u003d (currentColumnWidth - rectSize - rectTextGap - clipMargin); \n        clipWidth \u003d Math.max(0, clipWidth); \n        var clipPath \u003d createSVGElement(\u0027clipPath\u0027, { id: clipId });\n        clipPath.appendChild(createSVGElement(\u0027rect\u0027, {\n            x: textX,\n            y: legendY - (rectSize / 2), \n            width: clipWidth,\n            height: rectSize * 2 \n        }));\n        defs.appendChild(clipPath);\n        itemGroup.appendChild(createSVGElement(\u0027text\u0027, { \n            x: textX, \n            y: legendY + rectSize / 2, \n            class: \u0027legend-item\u0027,\n            \u0027clip-path\u0027: \u0027url(#\u0027 + clipId + \u0027)\u0027 \n        }, label));\n         legendGroup.appendChild(itemGroup);\n      });\n//\nyAxisGroup.appendChild(createSVGElement(\u0027text\u0027, { x: 65, y: chartConfig.layout.marginTop - 30, class: \u0027y-axis-value\u0027 }, chartConfig.yAxisUnitLabel));\n      var finalTickStep \u003d yAxisRange / tickCount;\n      for (var i \u003d 0; i \u003c\u003d tickCount; i++) {\n        var value \u003d Math.round(finalTickStep * i);\n        var y \u003d yScale(value);\nyAxisGroup.appendChild(createSVGElement(\u0027line\u0027, { x1: chartConfig.layout.marginLeft, y1: y, x2: chartConfig.layout.width - chartConfig.layout.marginRight, y2: y, class: \u0027grid-line\u0027 }));\nyAxisGroup.appendChild(createSVGElement(\u0027text\u0027, { x: 65, y: y, class: \u0027y-axis-value\u0027, \u0027dominant-baseline\u0027: \u0027middle\u0027 }, value));\n}\n      chartConfig.barData.forEach(function(bar, index) {\n        var barGroup \u003d createSVGElement(\u0027g\u0027, { class: \u0027bar-group\u0027 });\n        var centerX \u003d xScale(index);\n        var total \u003d bar.values.reduce(function(sum, v) { return sum + v; }, 0);\n        var finalTotal \u003d total;\n        var animatedTotal \u003d finalTotal * animProgress;\n        if (finalTotal \u003e 0) {\n          barGroup.appendChild(createSVGElement(\u0027text\u0027, { \n            x: centerX, \n            y: yScale(animatedTotal) - chartConfig.barOptions.totalLabelOffset,\n            class: \u0027total-label\u0027,\n            style: \u0027opacity: \u0027 + animOpacity\n          }, finalTotal));\n        }\n        barGroup.appendChild(createSVGElement(\u0027text\u0027, { x: centerX, y: bottomY + 20, class: \u0027axis-label\u0027 }, bar.label));\n        var yOffset \u003d 0;\n        bar.values.slice().reverse().forEach(function(value, i) {\n          if (value \u003c\u003d 0) return;\n          var finalValue \u003d value;\n          var finalYOffset \u003d yOffset;\n          var animatedYOffset \u003d finalYOffset * animProgress;\n          var animatedValue \u003d finalValue * animProgress;\n          var segmentIndex \u003d bar.values.length - 1 - i;\n          var cssClass \u003d \u0027bar-\u0027 + colorConfig[segmentIndex].id.toLowerCase();\n          var yTop \u003d yScale(animatedYOffset + animatedValue);\n          var yBottom \u003d yScale(animatedYOffset);\n          var height \u003d yBottom - yTop;\n          if (height \u003c\u003d 0.5) return;\n          var r \u003d chartConfig.barOptions.cornerRadius;\nvar x \u003d centerX - chartConfig.barOptions.width / 2;\n          var w \u003d chartConfig.barOptions.width;\n          var segment;\n          var isBottomSegment \u003d (finalYOffset \u003d\u003d\u003d 0);\n          var isTopSegment \u003d Math.abs((finalYOffset + finalValue) - finalTotal) \u003c 0.01;\n          if (isBottomSegment \u0026\u0026 isTopSegment) {\n            segment \u003d createSVGElement(\u0027rect\u0027, { x: x, y: yTop, width: w, height: height, rx: r, ry: r, class: \u0027bar-segment \u0027 + cssClass });\n          } else if (isBottomSegment) {\n            var d \u003d \u0027M \u0027 + x + \u0027 \u0027 + yTop + \u0027 H \u0027 + (x+w) + \u0027 V \u0027 + (yBottom-r) + \u0027 A \u0027 + r + \u0027 \u0027 + r + \u0027 0 0 1 \u0027 + (x+w-r) + \u0027 \u0027 + yBottom + \u0027 H \u0027 + (x+r) + \n\u0027 A \u0027 + r + \u0027 \u0027 + r + \u0027 0 0 1 \u0027 + x + \u0027 \u0027 + (yBottom-r) + \u0027 Z\u0027;\n            segment \u003d createSVGElement(\u0027path\u0027, { d: d, class: \u0027bar-segment \u0027 + cssClass });\n          } else if (isTopSegment) {\n            var d \u003d \u0027M \u0027 + x + \u0027 \u0027 + yBottom + \u0027 H \u0027 + (x+w) + \u0027 V \u0027 + (yTop+r) + \u0027 A \u0027 + r + \u0027 \u0027 + r + \u0027 0 0 0 \u0027 + (x+w-r) + \u0027 \u0027 + yTop + \u0027 H \u0027 + (x+r) + \n\u0027 A \u0027 + r + \u0027 \u0027 + r + \u0027 0 0 0 \u0027 + x + \u0027 \u0027 + (yTop+r) + \u0027 Z\u0027;\n            segment \u003d createSVGElement(\u0027path\u0027, { d: d, class: \u0027bar-segment \u0027 + cssClass });\n          } else {\n            segment \u003d createSVGElement(\u0027rect\u0027, { x: x, y: yTop, width: w, height: height, class: \u0027bar-segment \u0027 + cssClass });\n          }\n          barGroup.appendChild(segment);\n          if(height \u003e 15){\n            barGroup.appendChild(createSVGElement(\u0027text\u0027, { \n                x: centerX, \n                y: yTop + height / 2,\n                \u0027dominant-baseline\u0027: \u0027middle\u0027, \n                class: \u0027segment-label\u0027,\n                style: \u0027opacity: \u0027 + animOpacity\n            }, finalValue));\n}\n          yOffset +\u003d value;\n        });\n        chartAreaGroup.appendChild(barGroup);\n      });\n}\n    try {\n      var configJson \u003d document.getElementById(\u0027chart-json-data\u0027).textContent;\nif (!configJson || configJson.trim() \u003d\u003d\u003d \u0027\u0027) {\n        throw new Error(\"JSON data is empty.\");\n}\n      var fullConfig;\n      try {\n        fullConfig \u003d JSON.parse(configJson);\n} catch (parseError) {\n        throw new Error(\u0027JSON parsing error: \u0027 + parseError.message);\n      }\n      if (!fullConfig || typeof fullConfig !\u003d\u003d \u0027object\u0027 || !fullConfig.data) {\n        throw new Error(\"Invalid JSON structure: Missing \u0027data\u0027 key.\");\n}\n      var config \u003d fullConfig.data;\n      if (config.colors \u0026\u0026 typeof config.colors \u003d\u003d\u003d \u0027string\u0027) {\n        var numColors \u003d config.legendLabels ?\nconfig.legendLabels.length : 5;\n        var generatedIds \u003d [];\n        for (var i \u003d 0; i \u003c numColors; i++) {\n          generatedIds.push(String.fromCharCode(65 + i));\n        }\n        var generatedColors;\n        var colorKeyword \u003d config.colors.toLowerCase();\n        var gradientDarken \u003d 15;\n        if (colorKeyword \u003d\u003d\u003d \u0027#gemini\u0027) {\n          var GEMINI_STOPS \u003d [\u0027#E68A9C\u0027, \u0027#9F63D0\u0027, \u0027#616AD8\u0027];\nvar hexPalette \u003d generateGradientScale(GEMINI_STOPS, numColors);\n          generatedColors \u003d [];\n          for (var i \u003d 0; i \u003c numColors; i++) {\n            var hex_start \u003d hexPalette[i];\nvar rgb_start \u003d hexToRgb(hex_start);\n            var hsl \u003d rgbToHsl(rgb_start.r, rgb_start.g, rgb_start.b);\n            var h \u003d hsl[0], s \u003d hsl[1], l \u003d hsl[2];\nvar l_end \u003d Math.max(0, Math.min(100, l - gradientDarken));\n            var rgb_end \u003d hslToRgb(h, s, l_end);\n            var hex_end \u003d rgbToHex(rgb_end[0], rgb_end[1], rgb_end[2]);\ngeneratedColors.push({\n              id: generatedIds[i],\n              start: hex_start,\n              end: hex_end\n            });\n}\n        } else if (colorKeyword \u003d\u003d\u003d \u0027#night\u0027) {\n          var NIGHT_COLORS \u003d [\n            { start: \u0027#8d58d3\u0027, end: \u0027#704ca4\u0027 },\n            { start: \u0027#8f83d6\u0027, end: \u0027#7469a8\u0027 \n},\n            { start: \u0027#7891dd\u0027, end: \u0027#5c6fbb\u0027 },\n            { start: \u0027#50a89d\u0027, end: \u0027#258a7f\u0027 },\n            { start: \u0027#54c5d5\u0027, end: \u0027#34a0b0\u0027 }\n          ];\ngeneratedColors \u003d [];\n          for (var i \u003d 0; i \u003c numColors; i++) {\n            var colorPair \u003d NIGHT_COLORS[i] ||\nNIGHT_COLORS[NIGHT_COLORS.length - 1];\n            generatedColors.push({\n              id: generatedIds[i],\n              start: colorPair.start,\n              end: colorPair.end\n            });\n}\n        } else {\n          var primaryColor \u003d config.colors;\n          generatedColors \u003d generateMonochromaticScale(primaryColor, generatedIds);\n          if (generatedColors.length \u003d\u003d\u003d 0) {\n             throw new Error(\"Invalid HEX color string in \u0027colors\u0027: \" + primaryColor);\n}\n        }\n        if (generatedColors \u0026\u0026 generatedColors.length \u003e 0) {\n          config.colors \u003d generatedColors;\n} else {\n           throw new Error(\"Failed to generate colors from keyword: \" + config.colors);\n}\n      } else if (!config.colors || !Array.isArray(config.colors)) {\n         throw new Error(\"\u0027colors\u0027 must be an array of color objects or a single primary color string.\");\n}\n      if (!config.layout) {\n        config.layout \u003d {\n          width: 600,\n          height: 550,\n          marginTop: 170,\n          marginBottom: 50,\n          marginLeft: 75,\n          marginRight: 50\n        };\n      }\n      if (!config.barOptions) {\n        config.barOptions \u003d {\n          width: 50,\n          cornerRadius: 4,\n          totalLabelOffset: 10\n        };\n      }\n      if (!config || typeof config !\u003d\u003d \u0027object\u0027 || !config.barData || !Array.isArray(config.barData)) {\n        throw new Error(\"Invalid JSON structure: Missing required fields like \u0027barData\u0027 inside \u0027data\u0027.\");\n}\n      buildChart(config);\n    } catch(e) {\n      console.error(\"Chart Error:\", e);\nvar svgRoot \u003d document.getElementById(\u0027stacked-bar-chart-svg\u0027);\n      var existingError \u003d svgRoot.querySelector(\u0027.error-message\u0027);\n      if(existingError) existingError.remove();\nvar textEl \u003d createSVGElement(\u0027text\u0027, {\n        x: svgRoot.viewBox.baseVal.width / 2 + svgRoot.viewBox.baseVal.x,\n        y: svgRoot.viewBox.baseVal.height / 2 + svgRoot.viewBox.baseVal.y,\n        \u0027text-anchor\u0027: \u0027middle\u0027, fill: \u0027red\u0027,\n        \u0027font-family\u0027: \"\u0027Noto Sans JP\u0027, sans-serif\",\n        class: \u0027error-message\u0027\n      });\ntextEl.textContent \u003d e.message.includes(\u0027JSON\u0027) ? \u0027JSONデータにエラーがあります。\u0027 : \u0027グラフ描画エラーが発生しました。\u0027;\n      if (e.message.includes(\u0027JSON parsing error\u0027)) {\n        textEl.textContent +\u003d \u0027 (\u0027 + e.message.split(\u0027: \u0027)[1] + \u0027)\u0027;\n      }\n      svgRoot.appendChild(textEl);\n}\n  \u003c/script\u003e\n\u003c/svg\u003e\n`;\nconst BAR_CHART_TEMPLATE \u003d `\n\u003csvg width\u003d\"600\" height\u003d\"450\" viewBox\u003d\"25 25 570 435\" xmlns\u003d\"http://www.w3.org/2000/svg\" font-family\u003d\"\u0027Noto Sans JP\u0027, sans-serif\" id\u003d\"bar-chart-svg\"\u003e\n    \u003cscript id\u003d\"chart-json-data\" type\u003d\"application/json\"\u003e\n{\n        \"chartType\": \"bar\",\n        \"data\": {\n            \"title\": \"サンプル棒グラフ（動的レイアウト）\",\n            \"subtitle\": \"項目数に応じて幅が均等に調整されます\",\n            \"source\": \"出典：サンプルデータソース\",\n            \"items\": [\n                { \"label\": \"項目A\", \"value\": 85 },\n                { \"label\": \"項目B\", \"value\": 72 },\n                { \"label\": \"項目C\", \"value\": 93 },\n                { \"label\": \"項目D\", \"value\": 65 },\n                { \"label\": \"項目E\", \"value\": 48 },\n                { \"label\": \"項目F\", \"value\": 78 },\n                { \"label\": \"項目G\", \"value\": 55 },\n                { \"label\": \"項目H\", \"value\": 30 }\n             ],\n            \"colors\": {\n                \"start\": \"#e68a9c\",\n                \"end\": \"#9f63d0\"\n            },\n            \"layout\": {\n                \"width\": 600,\n                \"height\": 450,\n                \"marginTop\": 100,\n                \"marginBottom\": 65,\n                \"marginLeft\": 70,\n                \"marginRight\": 40\n            },\n            \"barOptions\": {\n                \"barToSlotRatio\": 0.6\n            },\n            \"yAxis\": {\n                \"max\": 100,\n                \"min\": 0,\n                \"tickCount\": 4,\n                \"unit\": \"%\"\n            },\n            \"animation\": 1\n        }\n    }\n    \u003c/script\u003e\n    \u003cdefs\u003e\n        \u003cfilter id\u003d\"shadow\"\u003e\n            \u003cfeDropShadow dx\u003d\"1\" dy\u003d\"2\" stdDeviation\u003d\"2\" flood-color\u003d\"#000\" flood-opacity\u003d\"0.2\"/\u003e\n        \u003c/filter\u003e\n         \u003cfilter id\u003d\"text-shadow\"\u003e\n            \u003cfeDropShadow dx\u003d\"0\" dy\u003d\"0\" stdDeviation\u003d\"2.5\" flood-color\u003d\"#000000\" flood-opacity\u003d\"0.9\"/\u003e\n        \u003c/filter\u003e\n    \u003c/defs\u003e\n    \u003cstyle\u003e\n        @import url(\u0027https://fonts.googleapis.com/css2?family\u003dNoto+Sans+JP:wght@400;500\u0026amp;family\u003dRoboto:wght@400\u0026amp;display\u003dswap\u0027);\n        .bar { filter: url(#shadow); }\n        .axis-label { font-size: 13px; fill: #5f6368; text-anchor: middle; }\n        .title { font-size: 21px; font-weight: 500; text-anchor: middle; fill: #5f6368; }\n        .subtitle { font-size: 16px; text-anchor: middle; fill: #5f6368; }\n        .source { font-size: 11px; fill: #70757a; text-anchor: end; }\n        .grid-line { stroke: #e0e0e0; stroke-dasharray: 2 2; stroke-width: 0.8; }\n        .y-axis-unit { font-size: 12px; fill: #5f6368; text-anchor: end; } \n        .data-label { font-family: \u0027Roboto\u0027, sans-serif; font-size: 14px; font-weight: normal; text-anchor: middle; }\n        .y-axis-value { font-family: \u0027Roboto\u0027, sans-serif; font-size: 12px; fill: #757575; text-anchor: end; }\n    \u003c/style\u003e\n    \u003cg id\u003d\"title-group\"\u003e\u003c/g\u003e\n    \u003cg id\u003d\"y-axis-group\"\u003e\u003c/g\u003e\n    \u003cg id\u003d\"chart-area-group\"\u003e\u003c/g\u003e\n    \u003cg id\u003d\"x-axis-group\"\u003e\u003c/g\u003e\n    \u003cg id\u003d\"source-group\"\u003e\u003c/g\u003e\n    \u003cscript type\u003d\"text/javascript\"\u003e\n    const svgNS \u003d \"http://www.w3.org/2000/svg\";\n    function createSVGElement(name, attributes, textContent) {\n        const el \u003d document.createElementNS(svgNS, name);\n        for (const key in attributes) el.setAttribute(key, attributes[key]);\n        if (textContent !\u003d\u003d undefined \u0026\u0026 textContent !\u003d\u003d null) {\n            el.textContent \u003d textContent;\n        }\n        return el;\n    }\n    function hexToRgb(hex) {\n      let shorthandRegex \u003d /^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i;\n      hex \u003d hex.replace(shorthandRegex, function(m, r, g, b) {\n        return r + r + g + g + b + b;\n      });\n      let result \u003d /^#?([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/i.exec(hex);\n      return result ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16)\n      } : null;\n    }\n    function rgbToHsl(r, g, b) {\n      r /\u003d 255; g /\u003d 255; b /\u003d 255;\n      let max \u003d Math.max(r, g, b), min \u003d Math.min(r, g, b);\n      let h, s, l \u003d (max + min) / 2;\n      l \u003d Math.round(l * 100);\n      if (max \u003d\u003d min) {\n        h \u003d s \u003d 0;\n      } else {\n        let d \u003d max - min;\n        s \u003d l \u003e 50 ? d / (2 - max - min) : d / (max + min);\n        s \u003d Math.round(s * 100);\n        switch (max) {\n          case r: h \u003d (g - b) / d + (g \u003c b ? 6 : 0); break;\n          case g: h \u003d (b - r) / d + 2; break;\n          case b: h \u003d (r - g) / d + 4; break;\n        }\n        h /\u003d 6;\n      }\n      h \u003d Math.round(h * 360);\n      return [h, s, l];\n    }\n    function hslToRgb(h, s, l) {\n      let r, g, b;\n      h /\u003d 360;\n      s /\u003d 100;\n      l /\u003d 100;\n      if (s \u003d\u003d 0) {\n        r \u003d g \u003d b \u003d l;\n      } else {\n        function hue2rgb(p, q, t) {\n          if (t \u003c 0) t +\u003d 1;\n          if (t \u003e 1) t -\u003d 1;\n          if (t \u003c 1/6) return p + (q - p) * 6 * t;\n          if (t \u003c 1/2) return q;\n          if (t \u003c 2/3) return p + (q - p) * (2/3 - t) * 6;\n          return p;\n        }\n        let q \u003d l \u003c 0.5 ? l * (1 + s) : l + s - l * s;\n        let p \u003d 2 * l - q;\n        r \u003d hue2rgb(p, q, h + 1/3);\n        g \u003d hue2rgb(p, q, h);\n        b \u003d hue2rgb(p, q, h - 1/3);\n      }\n      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\n    }\n    function rgbToHex(r, g, b) {\n      function componentToHex(c) {\n        let hex \u003d c.toString(16);\n        return hex.length \u003d\u003d 1 ? \"0\" + hex : hex;\n      }\n      return \"#\" + componentToHex(r) + componentToHex(g) + componentToHex(b);\n    }\n    function clampLuminance(hex, minL, maxL) {\n      var rgb \u003d hexToRgb(hex);\n      if (!rgb) return hex;\n      var hsl \u003d rgbToHsl(rgb.r, rgb.g, rgb.b);\n      var h \u003d hsl[0], s \u003d hsl[1], l \u003d hsl[2];\n      var clamped_l \u003d Math.max(minL, Math.min(maxL, l));\n      if (clamped_l \u003d\u003d\u003d l) {\n        return hex;\n      }\n      var clamped_rgb \u003d hslToRgb(h, s, clamped_l);\n      return rgbToHex(clamped_rgb[0], clamped_rgb[1], clamped_rgb[2]);\n    }\nfunction truncateText(text, maxWidth) {\n    const AVERAGE_CHAR_WIDTH \u003d 10; \n    const ELLIPSIS_WIDTH \u003d 3 * AVERAGE_CHAR_WIDTH; \n    if (text.length * AVERAGE_CHAR_WIDTH \u003c\u003d maxWidth) {\n        return text;\n    }\n    const maxVisibleChars \u003d Math.floor((maxWidth - ELLIPSIS_WIDTH) / AVERAGE_CHAR_WIDTH);\n    if (maxVisibleChars \u003c\u003d 0) {\n        return \u0027...\u0027;\n    }\n    return text.slice(0, maxVisibleChars) + \u0027...\u0027;\n}\n    function buildChart(config) {\n        const svgRoot \u003d document.getElementById(\u0027bar-chart-svg\u0027);\n        const defs \u003d svgRoot.querySelector(\u0027defs\u0027);\n        let animRatio \u003d (config.animation \u003d\u003d null) ? 1.0 : parseFloat(config.animation);\n        config.animationRatio \u003d Math.max(0.0, Math.min(1.0, isNaN(animRatio) ? 1.0 : animRatio));\n        const existingGrad \u003d document.getElementById(\u0027barGradient\u0027);\n        if (existingGrad) existingGrad.remove();\n        const styleElement \u003d svgRoot.querySelector(\u0027style\u0027);\n        if (styleElement) {\n            styleElement.textContent \u003d styleElement.textContent.replace(/[.]bar {[^}]*}/g, \u0027\u0027);\n        }\n        const gradId \u003d \u0027barGradient\u0027;\n        let gradient \u003d createSVGElement(\u0027linearGradient\u0027, { id: gradId, x1:\"0\", x2:\"0\", y1:\"0\", y2:\"1\" });\n        gradient.appendChild(createSVGElement(\u0027stop\u0027, { offset: \u00270%\u0027, \u0027stop-color\u0027: config.color.start }));\n        gradient.appendChild(createSVGElement(\u0027stop\u0027, { offset: \u0027100%\u0027, \u0027stop-color\u0027: config.color.end }));\n        defs.appendChild(gradient);\n        const barStyleRule \u003d \u0027.bar { fill: url(#\u0027 + gradId + \u0027); filter: url(#shadow); }\u0027;\n        if(styleElement \u0026\u0026 !styleElement.textContent.includes(barStyleRule)) {\n             styleElement.textContent +\u003d barStyleRule;\n        }\n        const groups \u003d {\n            titleGroup: document.getElementById(\u0027title-group\u0027),\n            yAxisGroup: document.getElementById(\u0027y-axis-group\u0027),\n            chartAreaGroup: document.getElementById(\u0027chart-area-group\u0027),\n            xAxisGroup: document.getElementById(\u0027x-axis-group\u0027),\n            sourceGroup: document.getElementById(\u0027source-group\u0027)\n        };\n        for (let key in groups) {\n            while (groups[key].firstChild) groups[key].removeChild(groups[key].firstChild);\n        }\n        const chartAreaHeight \u003d config.layout.height - config.layout.marginTop - config.layout.marginBottom;\n        const dataMax \u003d Math.max(...config.items.map(item \u003d\u003e item.value), config.yAxis.max);\n        const dataMin \u003d Math.min(...config.items.map(item \u003d\u003e item.value), config.yAxis.min);\n        let effectiveYAxisMax, effectiveYAxisMin;\n        const tickCount \u003d config.yAxis.tickCount \u003e 0 ? config.yAxis.tickCount : 1;\n        const preliminaryRange \u003d Math.max(1, config.yAxis.max - config.yAxis.min);\n        let tickInterval \u003d preliminaryRange / tickCount;\n        if (dataMin \u003c config.yAxis.min) {\n            const limit \u003d Math.max(Math.abs(dataMin), dataMax);\n            if (tickInterval \u003c\u003d 0 || isNaN(tickInterval)) tickInterval \u003d Math.max(1, limit / 5);\n             effectiveYAxisMax \u003d Math.ceil(limit / tickInterval) * tickInterval;\n             effectiveYAxisMin \u003d -effectiveYAxisMax;\n             if (config.yAxis.min \u003e effectiveYAxisMin) effectiveYAxisMin \u003d config.yAxis.min;\n             if (config.yAxis.max \u003c effectiveYAxisMax) effectiveYAxisMax \u003d config.yAxis.max;\n        } else {\n             effectiveYAxisMin \u003d config.yAxis.min;\n             if (tickInterval \u003c\u003d 0 || isNaN(tickInterval)) tickInterval \u003d Math.max(1, (dataMax - effectiveYAxisMin) / 5) || 1;\n             effectiveYAxisMax \u003d Math.max(config.yAxis.max, Math.ceil(dataMax / tickInterval) * tickInterval);\n        }\n        if (effectiveYAxisMax \u003c\u003d effectiveYAxisMin) {\n            effectiveYAxisMax \u003d effectiveYAxisMin + tickInterval * tickCount;\n            if (effectiveYAxisMax \u003c\u003d effectiveYAxisMin) effectiveYAxisMax \u003d effectiveYAxisMin + 1;\n        }\n        const yRange \u003d effectiveYAxisMax - effectiveYAxisMin;\n        const yScale \u003d (value) \u003d\u003e (yRange \u003d\u003d\u003d 0) ? config.layout.marginTop + chartAreaHeight / 2 : config.layout.marginTop + chartAreaHeight * (1 - (value - effectiveYAxisMin) / yRange);\n        groups.titleGroup.appendChild(createSVGElement(\u0027text\u0027, { x: 300, y: 50, class: \u0027title\u0027 }, config.title));\n        groups.titleGroup.appendChild(createSVGElement(\u0027text\u0027, { x: 300, y: 75, class: \u0027subtitle\u0027 }, config.subtitle));\n        groups.yAxisGroup.appendChild(createSVGElement(\u0027text\u0027, { x: config.layout.marginLeft, y: config.layout.marginTop - 25, class: \u0027y-axis-unit\u0027 }, \u0027(\u0027 + config.yAxis.unit + \u0027)\u0027));\n        const finalTickStep \u003d yRange / tickCount;\n        for (let i \u003d 0; i \u003c\u003d tickCount; i++) {\n            const tickValue \u003d effectiveYAxisMin + (finalTickStep * i);\n            const y \u003d yScale(tickValue);\n            groups.yAxisGroup.appendChild(createSVGElement(\u0027text\u0027, { x: config.layout.marginLeft - 10, y: y, class: \u0027y-axis-value\u0027, \u0027dominant-baseline\u0027: \u0027middle\u0027 }, Math.round(tickValue)));\n            if (i \u003e 0 \u0026\u0026 i \u003c\u003d tickCount \u0026\u0026 Math.abs(tickValue) \u003e 1e-6) {\n                groups.yAxisGroup.appendChild(createSVGElement(\u0027line\u0027, { x1: config.layout.marginLeft, y1: y, x2: config.layout.width - config.layout.marginRight, y2: y, class: \u0027grid-line\u0027 }));\n            }\n        }\n        const bottomY \u003d config.layout.marginTop + chartAreaHeight;\n        groups.xAxisGroup.appendChild(createSVGElement(\u0027line\u0027, { x1: config.layout.marginLeft, y1: bottomY, x2: config.layout.width - config.layout.marginRight, y2: bottomY, stroke: \u0027#bdbdbd\u0027 }));\n        if (effectiveYAxisMin \u003c 0 \u0026\u0026 effectiveYAxisMax \u003e 0) {\n            const yZero \u003d yScale(0);\n            groups.yAxisGroup.appendChild(createSVGElement(\u0027line\u0027, { x1: config.layout.marginLeft, y1: yZero, x2: config.layout.width - config.layout.marginRight, y2: yZero, stroke: \u0027#bdbdbd\u0027, \u0027stroke-width\u0027: 1 }));\n        }\n        const plotAreaWidth \u003d config.layout.width - config.layout.marginLeft - config.layout.marginRight;\n        const slotWidth \u003d plotAreaWidth / config.items.length;\n        const barWidth \u003d slotWidth * config.barOptions.barToSlotRatio;\n        const yZero \u003d yScale(Math.max(0, effectiveYAxisMin));\n        const rotationThreshold \u003d 50; \n        const numItems \u003d config.items.length;\n        const needsRotation \u003d (slotWidth \u003c rotationThreshold \u0026\u0026 numItems \u003e 1);\n        const labelYOffset \u003d needsRotation ? bottomY + 25 : bottomY + 30;\n        const animationRatio \u003d config.animationRatio;\n        let animationOpacity;\n        const fadeStart \u003d 0.7;\n        if (animationRatio \u003c\u003d fadeStart) {\n            animationOpacity \u003d 0;\n        } else {\n            animationOpacity \u003d (animationRatio - fadeStart) / (1.0 - fadeStart);\n        }\n        config.items.forEach((item, index) \u003d\u003e {\n            const isEllipsisItem \u003d (item.label \u003d\u003d\u003d \u0027...\u0027);\n            const animatedValue \u003d item.value * animationRatio;\n            const centerX \u003d config.layout.marginLeft + (index * slotWidth) + (slotWidth / 2);\n            const barX \u003d centerX - barWidth / 2;\n            let barY, barHeight;\n            if (item.value \u003e\u003d 0) {\n                barY \u003d yScale(animatedValue); \n                barHeight \u003d Math.max(0, yZero - barY); \n            } else {\n                barY \u003d yZero;\n                barHeight \u003d Math.max(0, yScale(animatedValue) - yZero); \n            }\n            if (barHeight \u003e\u003d 1 \u0026\u0026 !isEllipsisItem) {\n                 groups.chartAreaGroup.appendChild(createSVGElement(\u0027rect\u0027, { x: barX, y: barY, width: barWidth, height: barHeight, rx: 4, ry: 4, class: \u0027bar\u0027 }));\n            }\n            const isOutside \u003d barHeight \u003c 30;\n            if (!isEllipsisItem) {\n                const dataLabel \u003d createSVGElement(\u0027text\u0027, { \n                    x: centerX, \n                    class: \u0027data-label\u0027,\n                    style: \u0027opacity: \u0027 + animationOpacity\n                }, item.value);\n                if (isOutside) {\n                    dataLabel.setAttribute(\u0027fill\u0027, \u0027#424242\u0027);\n                    dataLabel.setAttribute(\u0027filter\u0027, \u0027none\u0027);\n                    dataLabel.setAttribute(\u0027y\u0027, item.value \u003e\u003d 0 ? barY - 8 : barY + barHeight + 18);\n                } else {\n                    dataLabel.setAttribute(\u0027fill\u0027, \u0027white\u0027);\n                    dataLabel.setAttribute(\u0027filter\u0027, \u0027url(#text-shadow)\u0027);\n                    dataLabel.setAttribute(\u0027y\u0027, item.value \u003e\u003d 0 ? barY + 20 : barY + barHeight - 10);\n                }\n                groups.chartAreaGroup.appendChild(dataLabel);\n            }\n            let labelContent;\n            if (needsRotation \u0026\u0026 !isEllipsisItem) {\n                labelContent \u003d item.label;\n            } else {\n                if (isEllipsisItem) {\n                    labelContent \u003d item.label;\n                } else {\n                    labelContent \u003d truncateText(item.label, slotWidth * 0.9);\n                }\n            }\n            var attributes \u003d {\n                x: centerX,\n                y: labelYOffset,\n                class: \u0027axis-label\u0027\n            };\n            if (needsRotation \u0026\u0026 !isEllipsisItem) {\n                attributes[\u0027text-anchor\u0027] \u003d \u0027end\u0027;\n                attributes[\u0027dominant-baseline\u0027] \u003d \u0027middle\u0027;\n                attributes.transform \u003d \u0027rotate(-45, \u0027 + centerX + \u0027, \u0027 + labelYOffset + \u0027)\u0027;\n            } else {\n            }\n            groups.xAxisGroup.appendChild(createSVGElement(\u0027text\u0027, attributes, labelContent));\n        });\n        groups.sourceGroup.appendChild(createSVGElement(\u0027text\u0027, { x: 595, y: config.layout.height - 10, class: \u0027source\u0027 }, config.source));\n    }\n    try {\n        const configJson \u003d document.getElementById(\u0027chart-json-data\u0027).textContent;\n        if (!configJson || configJson.trim() \u003d\u003d\u003d \u0027\u0027) {\n            throw new Error(\"JSON data is empty.\");\n        }\n        let fullConfig;\n        try {\n            fullConfig \u003d JSON.parse(configJson);\n        } catch (parseError) {\n             throw new Error(\u0027JSON parsing error: \u0027 + parseError.message);\n        }\n        if (!fullConfig || typeof fullConfig !\u003d\u003d \u0027object\u0027 || !fullConfig.data) {\n             throw new Error(\"Invalid JSON structure: Missing \u0027data\u0027 key.\");\n        }\n        const config \u003d fullConfig.data;\n        if (config.colors) {\n            config.color \u003d config.colors;\n        }\n        if (config.color \u0026\u0026 typeof config.color \u003d\u003d\u003d \u0027string\u0027) {\n            const colorKeyword \u003d config.color.toLowerCase();\n            let generatedColorObject;\n            if (colorKeyword \u003d\u003d\u003d \u0027#gemini\u0027) {\n                generatedColorObject \u003d {\n                    start: \"#E68A9C\",\n                    end:   \"#9F63D0\"\n                };\n            } else if (colorKeyword \u003d\u003d\u003d \u0027#night\u0027) {\n                const NIGHT_COLORS_SUBSET \u003d [\n                     { start: \u0027#8d58d3\u0027, end: \u0027#704ca4\u0027 },\n                     { start: \u0027#8f83d6\u0027, end: \u0027#7469a8\u0027 },\n                     { start: \u0027#7891dd\u0027, end: \u0027#5c6fbb\u0027 }\n                ];\n                generatedColorObject \u003d {\n                    start: NIGHT_COLORS_SUBSET[0].start,\n                    end:   NIGHT_COLORS_SUBSET[2].end\n                };\n            } else {\n                const primaryColor \u003d config.color;\n                const rgb \u003d hexToRgb(primaryColor);\n                if (!rgb) {\n                    throw new Error(\"Invalid HEX color string in \u0027color\u0027: \" + primaryColor);\n                }\n                const hsl \u003d rgbToHsl(rgb.r, rgb.g, rgb.b);\n                const h \u003d hsl[0], s \u003d hsl[1], l \u003d hsl[2];\n                const l_start \u003d Math.min(100, l + 20);\n                const s_start \u003d (l \u003e 80) ? s * 0.7 : s;\n                const rgb_start \u003d hslToRgb(h, s_start, l_start);\n                const hex_start \u003d rgbToHex(rgb_start[0], rgb_start[1], rgb_start[2]);\n                generatedColorObject \u003d {\n                    start: hex_start,\n                    end:   primaryColor\n                };\n            }\n            config.color \u003d generatedColorObject;\n        } else if (!config.color || typeof config.color !\u003d\u003d \u0027object\u0027) {\n             throw new Error(\"\u0027color\u0027 must be a color object or a single color string.\");\n        }\n        const L_MIN_CLAMP \u003d 30;\n        const L_MAX_CLAMP \u003d 70;\n        if (config.color \u0026\u0026 typeof config.color \u003d\u003d\u003d \u0027object\u0027) {\n            if (config.color.start) {\n                config.color.start \u003d clampLuminance(config.color.start, L_MIN_CLAMP, L_MAX_CLAMP);\n            }\n            if (config.color.end) {\n                config.color.end \u003d clampLuminance(config.color.end, L_MIN_CLAMP, L_MAX_CLAMP);\n            }\n        }\n        if (!config.barOptions) {\n          config.barOptions \u003d {};\n        }\n        if (config.barOptions.barToSlotRatio \u003d\u003d null) {\n          config.barOptions.barToSlotRatio \u003d 0.7;\n        }\n         if (!config || typeof config !\u003d\u003d \u0027object\u0027 || !config.items || !Array.isArray(config.items)) {\n             throw new Error(\"Invalid JSON structure: Missing required fields like \u0027items\u0027 inside \u0027data\u0027.\");\n         }\n        buildChart(config);\n    } catch(e) {\n        console.error(\"Chart Error:\", e);\n        const svgRoot \u003d document.getElementById(\u0027bar-chart-svg\u0027);\n        const existingError \u003d svgRoot.querySelector(\u0027.error-message\u0027);\n        if(existingError) existingError.remove();\n        const textEl \u003d createSVGElement(\u0027text\u0027, {\n            x: svgRoot.viewBox.baseVal.width / 2 + svgRoot.viewBox.baseVal.x,\n            y: svgRoot.viewBox.baseVal.height / 2 + svgRoot.viewBox.baseVal.y,\n            \u0027text-anchor\u0027: \u0027middle\u0027, fill: \u0027red\u0027,\n            \u0027font-family\u0027: \"\u0027Noto Sans JP\u0027, sans-serif\",\n            class: \u0027error-message\u0027\n            });\n        textEl.textContent \u003d e.message.includes(\u0027JSON\u0027) ? \u0027JSONデータにエラーがあります。\u0027 : \u0027グラフ描画エラーが発生しました。\u0027;\n        if (e.message.includes(\u0027JSON parsing error\u0027)) {\n           textEl.textContent +\u003d \u0027 (\u0027 + e.message.split(\u0027: \u0027)[1] + \u0027)\u0027;\n        }\n        svgRoot.appendChild(textEl);\n    }\n    \u003c/script\u003e\n\u003c/svg\u003e\n`;\nconst PERCENT_STACKED_BAR_CHART_TEMPLATE \u003d `\n\u003csvg width\u003d\"600\" height\u003d\"510\" viewBox\u003d\"15 15 580 505\" xmlns\u003d\"http://www.w3.org/2000/svg\" font-family\u003d\"\u0027Noto Sans JP\u0027, sans-serif\" id\u003d\"100-stacked-bar-chart-svg\"\u003e\n  \u003cscript id\u003d\"chart-json-data\" type\u003d\"application/json\"\u003e\n    {\n      \"chartType\": \"100-stacked-bar\",\n      \"data\": {\n        \"title\": \"サンプルグラフ：カテゴリ別割合\",\n        \"subtitle\": \"（月別サンプルデータ）\",\n        \"source\": \"出典：サンプルデータソース\",\n        \"colors\": [\n          { \"id\": \"A\", \"start\": \"#e68a9c\", \"end\": \"#d96d8f\" },\n          { \"id\": \"B\", \n\"start\": \"#b469b8\", \"end\": \"#a656ad\" },\n          { \"id\": \"C\", \"start\": \"#9f63d0\", \"end\": \"#8c4fc8\" },\n          { \"id\": \"D\", \"start\": \"#7c6ce8\", \"end\": \"#6b5ce0\" },\n          { \"id\": \"E\", \"start\": \"#616ad8\", \"end\": \"#5059d1\" }\n        ],\n        \"legendLabels\": [\"項目 A\", \"項目 B\", \"項目 C\", \"項目 D\", \"項目 E\"],\n        \"barData\": [\n{ \"label\": \"サンプル 1\", \"values\": [40, 60, 30, 50, 20] },\n          { \"label\": \"サンプル 2\", \"values\": [70, 50, 40, 20, 20] },\n          { \"label\": \"サンプル 3\", \"values\": [30, 40, 60, 40, 30] },\n          { \"label\": \"サンプル 4\", \"values\": [25, 35, 55, 65, 45] },\n          { \"label\": \"サンプル 5\", \"values\": [50, 40, 30, 20, 60] }\n        ],\n      \"layout\": {\n          \"width\": 600,\n          \"height\": 510,\n          \"marginTop\": 150,\n          \"marginBottom\": 80,\n          \"marginLeft\": 70,\n          \"marginRight\": 25\n        },\n        \"barOptions\": {\n\"width\": 50,\n          \"cornerRadius\": 4\n        },\n        \"yAxis\": {\n          \"tickCount\": 4\n        },\n        \"animation\": 1\n      }\n    }\n  \u003c/script\u003e\n  \u003cdefs\u003e\n    \u003cfilter id\u003d\"shadow\"\u003e\u003cfeDropShadow dx\u003d\"1\" dy\u003d\"2\" stdDeviation\u003d\"2\" flood-color\u003d\"#000\" flood-opacity\u003d\"0.4\"/\u003e\u003c/filter\u003e\n    \u003cfilter id\u003d\"text-shadow\"\u003e\u003cfeDropShadow dx\u003d\"1\" dy\u003d\"1\" stdDeviation\u003d\"1\" flood-color\u003d\"#000\" flood-opacity\u003d\"0.7\"/\u003e\u003c/filter\u003e\n  \u003c/defs\u003e\n  \u003cstyle\u003e\n    @import url(\u0027https://fonts.googleapis.com/css2?family\u003dNoto+Sans+JP:wght@400;500\u0026amp;family\u003dRoboto:wght@400\u0026amp;display\u003dswap\u0027);\n    .bar-segment { filter: url(#shadow); }\n    .axis-label { font-size: 13px; fill: #5f6368; text-anchor: middle; }\n    .title { font-size: 24px; font-weight: 500; text-anchor: middle; fill: #5f6368; }\n    .subtitle { font-size: 16px; text-anchor: middle; fill: #5f6368; } \n    .source { font-size: 11px; fill: #70757a; text-anchor: end; }\n    .grid-line { stroke: #e0e0e0; stroke-dasharray: 2 2; stroke-width: 0.8; }\n    .legend-item { font-size: 13px; fill: #202124; dominant-baseline: middle; }\n    .segment-label { font-family: \u0027Roboto\u0027, sans-serif; font-size: 14px; font-weight: normal; fill: white; filter: url(#text-shadow); text-anchor: middle; pointer-events: none; }\n    .y-axis-value { font-family: \u0027Roboto\u0027, sans-serif; font-size: 12px; fill: #757575; text-anchor: end; }\n  \u003c/style\u003e\n  \u003cg id\u003d\"title-group\"\u003e\u003c/g\u003e\n  \u003cg id\u003d\"legend-group\"\u003e\u003c/g\u003e\n  \u003cg id\u003d\"y-axis-group\"\u003e\u003c/g\u003e\n  \u003cg id\u003d\"chart-area-group\"\u003e\u003c/g\u003e\n  \u003cg id\u003d\"source-group\"\u003e\u003c/g\u003e\n  \u003cscript type\u003d\"text/javascript\"\u003e\n    const svgNS \u003d \"http://www.w3.org/2000/svg\";\n    function createSVGElement(name, attributes, textContent) {\n      const el \u003d document.createElementNS(svgNS, name);\n      for (const key in attributes) el.setAttribute(key, attributes[key]);\n      if (textContent !\u003d\u003d undefined \u0026\u0026 textContent !\u003d\u003d null) {\n        el.textContent \u003d textContent;\n      }\n      return el;\n    }\n    function getEstimatedTextWidth(text, fontSize) {\n        let width \u003d 0;\n        const fullWidthCharSize \u003d fontSize;\n        const halfWidthCharSize \u003d fontSize * 0.6;\n        if (!text) return 0;\n        for (let i \u003d 0; i \u003c text.length; i++) {\n            const charCode \u003d text.charCodeAt(i);\n            if ((charCode \u003e\u003d 0x0020 \u0026\u0026 charCode \u003c\u003d 0x007E) || (charCode \u003e\u003d 0xFF61 \u0026\u0026 charCode \u003c\u003d 0xFF9F)) {\n                width +\u003d halfWidthCharSize;\n            } else {\n                width +\u003d fullWidthCharSize;\n            }\n        }\n        return width;\n    }\n    function hexToRgb(hex) {\n      let shorthandRegex \u003d /^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i;\n      hex \u003d hex.replace(shorthandRegex, function(m, r, g, b) {\n        return r + r + g + g + b + b;\n      });\n      let result \u003d /^#?([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/i.exec(hex);\n      return result ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16)\n      } : null;\n    }\n    function rgbToHsl(r, g, b) {\n      r /\u003d 255; g /\u003d 255; b /\u003d 255;\n      let max \u003d Math.max(r, g, b), min \u003d Math.min(r, g, b);\n      let h, s, l \u003d (max + min) / 2;\n      l \u003d Math.round(l * 100);\n      if (max \u003d\u003d min) {\n        h \u003d s \u003d 0;\n      } else {\n        let d \u003d max - min;\n        s \u003d l \u003e 50 ? d / (2 - max - min) : d / (max + min);\n        s \u003d Math.round(s * 100);\n        switch (max) {\n          case r: h \u003d (g - b) / d + (g \u003c b ? 6 : 0); break;\n          case g: h \u003d (b - r) / d + 2; break;\n          case b: h \u003d (r - g) / d + 4; break;\n        }\n        h /\u003d 6;\n      }\n      h \u003d Math.round(h * 360);\n      return [h, s, l];\n    }\n    function hslToRgb(h, s, l) {\n      let r, g, b;\n      h /\u003d 360;\n      s /\u003d 100;\n      l /\u003d 100;\n      if (s \u003d\u003d 0) {\n        r \u003d g \u003d b \u003d l;\n      } else {\n        function hue2rgb(p, q, t) {\n          if (t \u003c 0) t +\u003d 1;\n          if (t \u003e 1) t -\u003d 1;\n          if (t \u003c 1/6) return p + (q - p) * 6 * t;\n          if (t \u003c 1/2) return q;\n          if (t \u003c 2/3) return p + (q - p) * (2/3 - t) * 6;\n          return p;\n        }\n        let q \u003d l \u003c 0.5 ? l * (1 + s) : l + s - l * s;\n        let p \u003d 2 * l - q;\n        r \u003d hue2rgb(p, q, h + 1/3);\n        g \u003d hue2rgb(p, q, h);\n        b \u003d hue2rgb(p, q, h - 1/3);\n      }\n      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\n    }\n    function rgbToHex(r, g, b) {\n      function componentToHex(c) {\n        let hex \u003d c.toString(16);\n        return hex.length \u003d\u003d 1 ? \"0\" + hex : hex;\n      }\n      return \"#\" + componentToHex(r) + componentToHex(g) + componentToHex(b);\n    }\n    function linearInterpolateColor(hex1, hex2, t) {\n      const rgb1 \u003d hexToRgb(hex1);\n      const rgb2 \u003d hexToRgb(hex2);\n      const r \u003d Math.round(rgb1.r + (rgb2.r - rgb1.r) * t);\n      const g \u003d Math.round(rgb1.g + (rgb2.g - rgb1.g) * t);\n      const b \u003d Math.round(rgb1.b + (rgb2.b - rgb1.b) * t);\n      return rgbToHex(r, g, b);\n    }\n    function generateGradientScale(gradientStops, numSteps) {\n      const palette \u003d [];\n      if (numSteps \u003c\u003d 0) return [];\n      if (numSteps \u003d\u003d\u003d 1) return [gradientStops[0]];\n      const numSegments \u003d gradientStops.length - 1;\n      for (let i \u003d 0; i \u003c numSteps; i++) {\n        const t_global \u003d (numSteps \u003d\u003d\u003d 1) ? 0 : (i / (numSteps - 1));\n        const segmentProgress \u003d t_global * numSegments;\n        const stopIndex1 \u003d Math.floor(segmentProgress);\n        const stopIndex2 \u003d Math.min(stopIndex1 + 1, numSegments); \n        const t_local \u003d segmentProgress - stopIndex1;\n        const hex1 \u003d gradientStops[stopIndex1];\n        const hex2 \u003d gradientStops[stopIndex2];\n        palette.push(linearInterpolateColor(hex1, hex2, t_local));\n      }\n      return palette;\n    }\n    function generateMonochromaticScale(primaryHex, colorIds) {\n      const numSteps \u003d colorIds.length;\n      if (numSteps \u003d\u003d\u003d 0) return [];\n      const rgb \u003d hexToRgb(primaryHex);\n      if (!rgb) return [];\n      const [h, s, l_mid_original] \u003d rgbToHsl(rgb.r, rgb.g, rgb.b);\n      const gradientDarken \u003d 7; \n      const L_MAX \u003d 80; \n      const L_MIN \u003d 45; \n      const l_step_amount \u003d numSteps \u003e 1 ? (L_MAX - L_MIN) / (numSteps - 1) : 0;\n      const l_steps_calc \u003d [];\n      for (let i \u003d 0; i \u003c numSteps; i++) {\n        const l_val \u003d L_MAX - (i * l_step_amount);\n        l_steps_calc.push(l_val);\n      }\n      const l_steps_light \u003d [];\n      const l_steps_dark \u003d [];\n      const mid_index \u003d Math.ceil(numSteps / 2);\n      for (let i \u003d 0; i \u003c mid_index; i++) {\n        l_steps_light.push(l_steps_calc[i]);\n      }\n      for (let i \u003d mid_index; i \u003c numSteps; i++) {\n        l_steps_dark.push(l_steps_calc[i]);\n      }\n      const l_steps_start \u003d [];\n      for (let i \u003d 0; i \u003c numSteps; i++) {\n        if (i % 2 \u003d\u003d\u003d 0) {\n          l_steps_start.push(l_steps_light[i / 2]);\n        } else {\n          l_steps_start.push(l_steps_dark[(i - 1) / 2]);\n        }\n      }\n      const colors \u003d [];\n      for (let i \u003d 0; i \u003c numSteps; i++) {\n        const l_start_step \u003d l_steps_start[i];\n        let l_start \u003d Math.max(0, Math.min(100, l_start_step));\n        let l_end \u003d Math.max(0, Math.min(100, l_start - gradientDarken));\n        let s_adjusted \u003d s;\n        if (l_start \u003e 85) s_adjusted \u003d s * (1 - (l_start - 85) / 15);\n        if (l_start \u003c 20) s_adjusted \u003d s * (l_start / 20);\n        s_adjusted \u003d Math.max(0, Math.min(100, s_adjusted));\n        const rgb_start \u003d hslToRgb(h, s_adjusted, l_start);\n        const hex_start \u003d rgbToHex(rgb_start[0], rgb_start[1], rgb_start[2]);\n        const rgb_end \u003d hslToRgb(h, s_adjusted, l_end);\n        const hex_end \u003d rgbToHex(rgb_end[0], rgb_end[1], rgb_end[2]);\n        colors.push({\n          id: colorIds[i],\n          start: hex_start,\n          end: hex_end\n        });\n      }\n      return colors;\n    }\n    function buildChart(config) {\n      const nl \u003d String.fromCharCode(10);\n  const animProgress \u003d (config.animation \u003d\u003d null) \n      ? 1.0 \n      : Math.max(0, Math.min(1, Number(config.animation)));\n  let animOpacity;\n  const fadeStart \u003d 0.7;\n  if (animProgress \u003c\u003d fadeStart) {\n      animOpacity \u003d 0;\n  } else {\n      animOpacity \u003d (animProgress - fadeStart) / (1.0 - fadeStart);\n  }\n         const defaultLayout \u003d {\n          width: 600,\n          height: 510,\n          marginTop: 150,\n          marginBottom: 80,\n          marginLeft: 70,\n          marginRight: 25\n      };\n      if (config.layout \u0026\u0026 typeof config.layout \u003d\u003d\u003d \u0027object\u0027) {\n          config.layout \u003d {\n              width: (config.layout.width !\u003d\u003d undefined) ? config.layout.width : defaultLayout.width,\n              height: (config.layout.height !\u003d\u003d undefined) ? config.layout.height : defaultLayout.height,\n              marginTop: (config.layout.marginTop !\u003d\u003d undefined) ? config.layout.marginTop : defaultLayout.marginTop,\n              marginBottom: (config.layout.marginBottom !\u003d\u003d undefined) ? config.layout.marginBottom : defaultLayout.marginBottom,\n              marginLeft: (config.layout.marginLeft !\u003d\u003d undefined) ? config.layout.marginLeft : defaultLayout.marginLeft,\n              marginRight: (config.layout.marginRight !\u003d\u003d undefined) ? config.layout.marginRight : defaultLayout.marginRight\n          };\n      } else {\n          config.layout \u003d defaultLayout;\n      }\n         const defaultBarOptions \u003d {\n               width: 50,\n               cornerRadius: 4\n         };\n         if (config.barOptions \u0026\u0026 typeof config.barOptions \u003d\u003d\u003d \u0027object\u0027) {\n               config.barOptions \u003d {\n                     width: (config.barOptions.width !\u003d\u003d undefined \u0026\u0026 typeof config.barOptions.width \u003d\u003d\u003d \u0027number\u0027) ? config.barOptions.width : defaultBarOptions.width,\n                     cornerRadius: (config.barOptions.cornerRadius !\u003d\u003d undefined \u0026\u0026 typeof config.barOptions.cornerRadius \u003d\u003d\u003d \u0027number\u0027) ? config.barOptions.cornerRadius : defaultBarOptions.cornerRadius\n               };\n         } else {\n               config.barOptions \u003d defaultBarOptions;\n         }\n      const chartConfig \u003d config;\n      const colorConfig \u003d config.colors;\n      const svgRoot \u003d document.getElementById(\u0027100-stacked-bar-chart-svg\u0027);\n      const defs \u003d svgRoot.querySelector(\u0027defs\u0027);\n      const style \u003d svgRoot.querySelector(\u0027style\u0027);\n      const existingGrads \u003d defs.querySelectorAll(\u0027linearGradient\u0027);\n      existingGrads.forEach(grad \u003d\u003e grad.remove());\n      const existingClips \u003d defs.querySelectorAll(\u0027clipPath\u0027);\n      existingClips.forEach(clip \u003d\u003e clip.remove());\n      let dynamicStyleParts \u003d [];\n      colorConfig.forEach(color \u003d\u003e {\n        const gradId \u003d \u0027grad\u0027 + color.id;\n        const cssClass \u003d \u0027bar-\u0027 + color.id.toLowerCase();\n        const gradient \u003d createSVGElement(\u0027linearGradient\u0027, { id: gradId, x1:\"0\", x2:\"0\", y1:\"0\", y2:\"1\" });\n        gradient.appendChild(createSVGElement(\u0027stop\u0027, { offset: \u00270%\u0027, \u0027stop-color\u0027: color.start }));\n        gradient.appendChild(createSVGElement(\u0027stop\u0027, { offset: \u0027100%\u0027, \u0027stop-color\u0027: color.end }));\n        defs.appendChild(gradient);\n        dynamicStyleParts.push(\u0027.\u0027 + cssClass + \u0027 { fill: url(#\u0027 + gradId + \u0027); }\u0027);\n      });\n      const dynamicStyles \u003d dynamicStyleParts.join(nl);\n      const styleElement \u003d svgRoot.querySelector(\u0027style\u0027);\n      const firstRuleSelector \u003d \u0027.bar-\u0027 + (config.colors[0] ? config.colors[0].id.toLowerCase() : \u0027\u0027);\n      if (styleElement \u0026\u0026 firstRuleSelector \u0026\u0026 !styleElement.textContent.includes(firstRuleSelector)) {\n        styleElement.textContent +\u003d nl + dynamicStyles + nl;\n      }\n      const titleGroup \u003d document.getElementById(\u0027title-group\u0027);\n      const legendGroup \u003d document.getElementById(\u0027legend-group\u0027);\n      const yAxisGroup \u003d document.getElementById(\u0027y-axis-group\u0027);\n      const chartAreaGroup \u003d document.getElementById(\u0027chart-area-group\u0027);\n      const sourceGroup \u003d document.getElementById(\u0027source-group\u0027);\n      for(let group of [titleGroup, legendGroup, yAxisGroup, chartAreaGroup, sourceGroup]) {\n        while (group.firstChild) {\n          group.removeChild(group.firstChild);\n        }\n      }\n      const chartAreaWidth \u003d chartConfig.layout.width - chartConfig.layout.marginLeft - chartConfig.layout.marginRight;\n      const chartAreaHeight \u003d chartConfig.layout.height - chartConfig.layout.marginTop - chartConfig.layout.marginBottom;\n      const bottomY \u003d chartConfig.layout.marginTop + chartAreaHeight;\n      const xScale \u003d (index) \u003d\u003e chartConfig.layout.marginLeft + (chartAreaWidth / chartConfig.barData.length) * (index + 0.5);\n      const yScale \u003d (percentage) \u003d\u003e bottomY - (percentage / 100) * chartAreaHeight;\n      titleGroup.appendChild(createSVGElement(\u0027text\u0027, { x: 300, y: 50, class: \u0027title\u0027 }, chartConfig.title));\n      titleGroup.appendChild(createSVGElement(\u0027text\u0027, { x: 300, y: 75, class: \u0027subtitle\u0027 }, chartConfig.subtitle));\n      sourceGroup.appendChild(createSVGElement(\u0027text\u0027, { x: 595, y: 485, class: \u0027source\u0027 }, chartConfig.source));\n//\n      const legendY \u003d 105;\n      const numLegends \u003d chartConfig.legendLabels.length;\n      let legendStartX \u003d chartConfig.layout.marginLeft;\n      const rectSize \u003d 12;\n      const rectTextGap \u003d 6;\n      const legendFontSize \u003d 13;\n      const legendPadding \u003d 15;\n      let maxTextWidth \u003d 0;\n      chartConfig.legendLabels.forEach(function(label) {\n          const textWidth \u003d getEstimatedTextWidth(label, legendFontSize);\n          if (textWidth \u003e maxTextWidth) {\n              maxTextWidth \u003d textWidth;\n          }\n      });\n      const standardItemWidth \u003d rectSize + rectTextGap + maxTextWidth + legendPadding;\n      const totalRequiredWidth \u003d standardItemWidth * numLegends;\n      let useEqualWidths \u003d false;\n      let layoutItemWidth \u003d 0;\n      if (totalRequiredWidth \u003e chartAreaWidth || numLegends \u003d\u003d\u003d 0) {\n          useEqualWidths \u003d true;\n          layoutItemWidth \u003d (numLegends \u003e 0) ? (chartAreaWidth / numLegends) : 0;\n      } else {\n          useEqualWidths \u003d false;\n          layoutItemWidth \u003d standardItemWidth;\n          legendStartX \u003d chartConfig.layout.marginLeft + (chartAreaWidth - totalRequiredWidth) / 2;\n      }\n      chartConfig.legendLabels.forEach(function(label, i) {\n        const cssClass \u003d \u0027bar-\u0027 + colorConfig[i].id.toLowerCase();\n        const columnStartX \u003d legendStartX + (i * layoutItemWidth);\n        const currentColumnWidth \u003d layoutItemWidth;\n        const itemGroup \u003d createSVGElement(\u0027g\u0027);\n        itemGroup.appendChild(createSVGElement(\u0027rect\u0027, {\n          x: columnStartX, y: legendY, width: rectSize, height: rectSize, rx: 2, class: \u0027bar-segment \u0027 + cssClass\n        }));\n        const textX \u003d columnStartX + rectSize + rectTextGap;\n        const clipId \u003d \u0027legend-clip-\u0027 + i;\n        let clipMargin \u003d (legendPadding / 2);\n        if (useEqualWidths) clipMargin \u003d 5;\n        let clipWidth \u003d (currentColumnWidth - rectSize - rectTextGap - clipMargin); \n        clipWidth \u003d Math.max(0, clipWidth);\n        const clipPath \u003d createSVGElement(\u0027clipPath\u0027, { id: clipId });\n        clipPath.appendChild(createSVGElement(\u0027rect\u0027, {\n            x: textX,\n            y: legendY - (rectSize / 2),\n            width: clipWidth,\n            height: rectSize * 2\n        }));\n        defs.appendChild(clipPath);\n        const textElement \u003d createSVGElement(\u0027text\u0027, { \n            x: textX, \n            y: legendY + rectSize / 2, \n            class: \u0027legend-item\u0027,\n            \u0027clip-path\u0027: \u0027url(#\u0027 + clipId + \u0027)\u0027 \n        }, label);\n        itemGroup.appendChild(textElement);\n         legendGroup.appendChild(itemGroup);\n      });\n//\n      const tickCount \u003d chartConfig.yAxis.tickCount \u003e 0 ? chartConfig.yAxis.tickCount : 1;\n      for (let i \u003d 0; i \u003c\u003d tickCount; i++) {\n        const tickPercentage \u003d (100 / tickCount) * i;\n        const y \u003d yScale(tickPercentage);\n        yAxisGroup.appendChild(createSVGElement(\u0027text\u0027, { x: 60, y: y, class: \u0027y-axis-value\u0027, \u0027dominant-baseline\u0027: \u0027middle\u0027 }, Math.round(tickPercentage) + \u0027%\u0027));\n        if (i \u003e 0 \u0026\u0026 i \u003c tickCount) {\n          yAxisGroup.appendChild(createSVGElement(\u0027line\u0027, { x1: chartConfig.layout.marginLeft, y1: y, x2: chartConfig.layout.width - chartConfig.layout.marginRight, y2: y, class: \u0027grid-line\u0027 }));\n        }\n      }\n      yAxisGroup.appendChild(createSVGElement(\u0027line\u0027, { x1: chartConfig.layout.marginLeft, y1: bottomY, x2: chartConfig.layout.width - chartConfig.layout.marginRight, y2: bottomY, stroke: \u0027#bdbdbd\u0027 }));\n      yAxisGroup.appendChild(createSVGElement(\u0027line\u0027, { x1: chartConfig.layout.marginLeft, y1: config.layout.marginTop, x2: chartConfig.layout.width - chartConfig.layout.marginRight, y2: config.layout.marginTop, stroke: \u0027#bdbdbd\u0027 }));\n      const slotWidth \u003d chartAreaWidth / chartConfig.barData.length;\n      const minGap \u003d 5;\n      const maxBarWidth \u003d chartConfig.barOptions.width;\n      const calculatedWidth \u003d slotWidth - minGap;\n      const finalBarWidth \u003d Math.max(1, Math.min(maxBarWidth, calculatedWidth));\n      chartConfig.barData.forEach((bar, index) \u003d\u003e {\n        const barGroup \u003d createSVGElement(\u0027g\u0027, { class: \u0027bar-group\u0027 });\n        const centerX \u003d xScale(index);\n        const total \u003d bar.values.reduce((sum, v) \u003d\u003e sum + v, 0);\n        barGroup.appendChild(createSVGElement(\u0027text\u0027, { x: centerX, y: bottomY + 20, class: \u0027axis-label\u0027 }, bar.label));\n        let yOffsetPercentage \u003d 0;\n    const numItems \u003d bar.values.length;\n    const equalPercentage \u003d 100 / numItems;\n    const finalPercentages \u003d bar.values.map(value \u003d\u003e (total \u003e 0 ? (value / total) * 100 : 0));\n    const equalPercentages \u003d bar.values.map(() \u003d\u003e equalPercentage);\n        let animatedYOffsetPercentage \u003d 0;\n        bar.values.slice().reverse().forEach((originalValue, i) \u003d\u003e {\n            const segmentIndex \u003d bar.values.length - 1 - i;\n            const eqPerc \u003d equalPercentages[segmentIndex];\n            const finPerc \u003d finalPercentages[segmentIndex];\n            const animatedPercentage \u003d eqPerc + (finPerc - eqPerc) * animProgress;\n            if (animatedPercentage \u003c\u003d 0.01) return;\n            const yTop \u003d yScale(animatedYOffsetPercentage + animatedPercentage);\n            const yBottom \u003d yScale(animatedYOffsetPercentage);\n            const height \u003d yBottom - yTop;\n            if (height \u003c\u003d 0.5) return;\n            const cssClass \u003d \u0027bar-\u0027 + colorConfig[segmentIndex].id.toLowerCase();\n            const r \u003d chartConfig.barOptions.cornerRadius;\n            const w \u003d finalBarWidth;\n            const x \u003d centerX - w / 2;\n            let segment;\n            let currentFinalOffset \u003d 0;\n            for(let j \u003d bar.values.length - 1; j \u003e segmentIndex; j--) {\n                currentFinalOffset +\u003d finalPercentages[j];\n            }\n            const isBottomSegment \u003d (Math.abs(currentFinalOffset) \u003c 0.01);\n            const isTopSegment \u003d (Math.abs((currentFinalOffset + finPerc) - 100) \u003c 0.01);\n            if (isBottomSegment \u0026\u0026 isTopSegment) {\n                segment \u003d createSVGElement(\u0027rect\u0027, { x: x, y: yTop, width: w, height: height, rx: r, ry: r, class: \u0027bar-segment \u0027 + cssClass });\n            } else if (isBottomSegment) {\n                const d \u003d [\n                    \u0027M \u0027 + x + \u0027 \u0027 + yTop, \u0027H \u0027 + (x+w), \u0027V \u0027 + (yBottom-r),\n                    \u0027A \u0027 + r + \u0027 \u0027 + r + \u0027 0 0 1 \u0027 + (x+w-r) + \u0027 \u0027 + yBottom, \u0027H \u0027 + (x+r),\n                    \u0027A \u0027 + r + \u0027 \u0027 + r + \u0027 0 0 1 \u0027 + x + \u0027 \u0027 + (yBottom-r), \u0027Z\u0027\n                ].join(\u0027 \u0027);\n                segment \u003d createSVGElement(\u0027path\u0027, { d: d, class: \u0027bar-segment \u0027 + cssClass });\n            } else if (isTopSegment) {\n                const d \u003d [\n                    \u0027M \u0027 + x + \u0027 \u0027 + yBottom, \u0027H \u0027 + (x+w), \u0027V \u0027 + (yTop+r),\n                    \u0027A \u0027 + r + \u0027 \u0027 + r + \u0027 0 0 0 \u0027 + (x+w-r) + \u0027 \u0027 + yTop, \u0027H \u0027 + (x+r),\n                    \u0027A \u0027 + r + \u0027 \u0027 + r + \u0027 0 0 0 \u0027 + x + \u0027 \u0027 + (yTop+r), \u0027Z\u0027\n                ].join(\u0027 \u0027);\n                segment \u003d createSVGElement(\u0027path\u0027, { d: d, class: \u0027bar-segment \u0027 + cssClass });\n            } else {\n                segment \u003d createSVGElement(\u0027rect\u0027, { x: x, y: yTop, width: w, height: height, class: \u0027bar-segment \u0027 + cssClass });\n            }\n            barGroup.appendChild(segment);\n            const finalPercentageValue \u003d finPerc;\n            if (finalPercentageValue \u003e 5) {\n                barGroup.appendChild(createSVGElement(\u0027text\u0027, { \n                    x: centerX, \n                    y: yTop + height / 2,\n                    \u0027dominant-baseline\u0027: \u0027middle\u0027, \n                    class: \u0027segment-label\u0027,\n                    style: \u0027opacity: \u0027 + animOpacity\n                }, Math.round(finalPercentageValue) + \u0027%\u0027));\n            }\n            animatedYOffsetPercentage +\u003d animatedPercentage;\n        });\n        chartAreaGroup.appendChild(barGroup);\n      });\n    }\n    try {\n      const configJson \u003d document.getElementById(\u0027chart-json-data\u0027).textContent;\n      if (!configJson || configJson.trim() \u003d\u003d\u003d \u0027\u0027) {\n        throw new Error(\"JSON data is empty.\");\n      }\n      let fullConfig;\n      try {\n        fullConfig \u003d JSON.parse(configJson);\n      } catch (parseError) {\n        throw new Error(\u0027JSON parsing error: \u0027 + parseError.message);\n      }\n      if (!fullConfig || typeof fullConfig !\u003d\u003d \u0027object\u0027 || !fullConfig.data) {\n        throw new Error(\"Invalid JSON structure: Missing \u0027data\u0027 key.\");\n      }\n      const config \u003d fullConfig.data;\n      if (config.colors \u0026\u0026 typeof config.colors \u003d\u003d\u003d \u0027string\u0027) {\n        const numColors \u003d config.legendLabels ? config.legendLabels.length : 5;\n        const generatedIds \u003d [];\n        for (let i \u003d 0; i \u003c numColors; i++) {\n          generatedIds.push(String.fromCharCode(65 + i));\n        }\n        let generatedColors;\n        const colorKeyword \u003d config.colors.toLowerCase();\n        const gradientDarken \u003d 15;\n        if (colorKeyword \u003d\u003d\u003d \u0027#gemini\u0027) {\n          const GEMINI_STOPS \u003d [\u0027#E68A9C\u0027, \u0027#9F63D0\u0027, \u0027#616AD8\u0027];\n          const hexPalette \u003d generateGradientScale(GEMINI_STOPS, numColors);\n          generatedColors \u003d [];\n          for (let i \u003d 0; i \u003c numColors; i++) {\n            const hex_start \u003d hexPalette[i];\n            const rgb_start \u003d hexToRgb(hex_start);\n            const [h, s, l] \u003d rgbToHsl(rgb_start.r, rgb_start.g, rgb_start.b);\n            const l_end \u003d Math.max(0, Math.min(100, l - gradientDarken));\n            const rgb_end \u003d hslToRgb(h, s, l_end);\n            const hex_end \u003d rgbToHex(rgb_end[0], rgb_end[1], rgb_end[2]);\n            generatedColors.push({\n              id: generatedIds[i],\n              start: hex_start,\n              end: hex_end\n            });\n          }\n        } else if (colorKeyword \u003d\u003d\u003d \u0027#night\u0027) {\nconst NIGHT_COLORS \u003d [\n          { start: \u0027#8d58d3\u0027, end: \u0027#704ca4\u0027 },\n          { start: \u0027#8f83d6\u0027, end: \u0027#7469a8\u0027 },\n          { start: \u0027#7891dd\u0027, end: \u0027#5c6fbb\u0027 },\n          { start: \u0027#50a89d\u0027, end: \u0027#258a7f\u0027 },\n          { start: \u0027#54c5d5\u0027, end: \u0027#34a0b0\u0027 }\n        ];\n          generatedColors \u003d [];\n          for (let i \u003d 0; i \u003c numColors; i++) {\n            const colorPair \u003d NIGHT_COLORS[i] || NIGHT_COLORS[NIGHT_COLORS.length - 1];\n            generatedColors.push({\n              id: generatedIds[i],\n              start: colorPair.start,\n              end: colorPair.end\n            });\n          }\n        } else {\n          const primaryColor \u003d config.colors;\n          generatedColors \u003d generateMonochromaticScale(primaryColor, generatedIds);\n          if (generatedColors.length \u003d\u003d\u003d 0) {\n             throw new Error(\"Invalid HEX color string in \u0027colors\u0027: \" + primaryColor);\n          }\n        }\n        if (generatedColors \u0026\u0026 generatedColors.length \u003e 0) {\n          config.colors \u003d generatedColors;\n        } else {\n           throw new Error(\"Failed to generate colors from keyword: \" + config.colors);\n        }\n      } else if (!config.colors || !Array.isArray(config.colors)) {\n         throw new Error(\"\u0027colors\u0027 must be an array of color objects or a single primary color string.\");\n      }\n      if (!config || typeof config !\u003d\u003d \u0027object\u0027 || !config.barData || !Array.isArray(config.barData)) {\n        throw new Error(\"Invalid JSON structure: Missing required fields like \u0027barData\u0027 inside \u0027data\u0027.\");\n      }\n      buildChart(config);\n    } catch(e) {\n      console.error(\"Chart Error:\", e);\n      const svgRoot \u003d document.getElementById(\u0027100-stacked-bar-chart-svg\u0027);\n      const existingError \u003d svgRoot.querySelector(\u0027.error-message\u0027);\n      if(existingError) existingError.remove();\n      const textEl \u003d createSVGElement(\u0027text\u0027, {\n        x: svgRoot.viewBox.baseVal.width / 2 + svgRoot.viewBox.baseVal.x,\n        y: svgRoot.viewBox.baseVal.height / 2 + svgRoot.viewBox.baseVal.y,\n        \u0027text-anchor\u0027: \u0027middle\u0027, fill: \u0027red\u0027,\n        \u0027font-family\u0027: \"\u0027Noto Sans JP\u0027, sans-serif\",\n        class: \u0027error-message\u0027\n      });\n      textEl.textContent \u003d e.message.includes(\u0027JSON\u0027) ? \u0027JSONデータにエラーがあります。\u0027 : \u0027グラフ描画エラーが発生しました。\u0027;\n      if (e.message.includes(\u0027JSON parsing error\u0027)) {\n        textEl.textContent +\u003d \u0027 (\u0027 + e.message.split(\u0027: \u0027)[1] + \u0027)\u0027;\n      }\n      svgRoot.appendChild(textEl);\n    }\n  \u003c/script\u003e\n\u003c/svg\u003e\n`;\nconst LINE_CHART_TEMPLATE \u003d `\n\u003csvg width\u003d\"600\" height\u003d\"465\" viewBox\u003d\"25 25 575 430\" xmlns\u003d\"http://www.w3.org/2000/svg\" font-family\u003d\"\u0027Noto Sans JP\u0027, sans-serif\" id\u003d\"line-chart-svg\"\u003e\n  \u003cscript id\u003d\"chart-json-data\" type\u003d\"application/json\"\u003e\n    {\n      \"chartType\": \"line\",\n      \"data\": {\n        \"title\": \"年間データ推移\",\n        \"subtitle\": \"（サンプルデータ）\",\n        \"source\": \"出典：サンプルデータ\",\n        \"yAxisUnitLabel\": \"（単位）\",\n        \"items\": [\n          { \"label\": \"1月\", \"value\": 8 },\n          { \"label\": \"2月\", \"value\": 9 },\n          { \"label\": \"3月\", \"value\": 12 },\n          { \"label\": \"4月\", \"value\": 16 },\n          { \"label\": \"5月\", \"value\": 20 },\n          { \"label\": \"6月\", \"value\": 24 },\n          { \"label\": \"7月\", \"value\": 28 },\n          { \"label\": \"8月\", \"value\": 27 },\n          { \"label\": \"9月\", \"value\": 35 }\n        ],\n        \"colors\": {\n          \"start\": \"#e68a9c\",\n          \"end\": \"#b469b8\",\n          \"line\": \"#b469b8\",\n          \"label\": \"#8c4fc8\"\n        },\n        \"layout\": {\n          \"width\": 600,\n          \"height\": 465,\n          \"marginTop\": 110,\n          \"marginBottom\": 75,\n          \"marginLeft\": 75,\n          \"marginRight\": 25\n        },\n        \"yAxis\": {\n          \"max\": 40,\n          \"min\": 0,\n          \"tickCount\": 4\n        },\n        \"lineOptions\": {\n          \"markerRadius\": 5,\n          \"dataLabelOffsetY\": 15,\n          \"horizontalPadding\": 30\n        },\n        \"animation\": 1\n      }\n    }\n\u003c/script\u003e\n  \u003cdefs\u003e\n    \u003cfilter id\u003d\"shadow\"\u003e\n      \u003cfeDropShadow dx\u003d\"1\" dy\u003d\"2\" stdDeviation\u003d\"2\" flood-color\u003d\"#000\" flood-opacity\u003d\"0.2\"/\u003e\n    \u003c/filter\u003e\n    \u003cfilter id\u003d\"text-halo\"\u003e\n      \u003cfeDropShadow dx\u003d\"0\" dy\u003d\"0\" stdDeviation\u003d\"3\" flood-color\u003d\"white\" flood-opacity\u003d\"0.9\"/\u003e\n    \u003c/filter\u003e\n  \u003c/defs\u003e\n  \u003cstyle\u003e\n    @import url(\u0027https://fonts.googleapis.com/css2?family\u003dNoto+Sans+JP:wght@400;500;700\u0026amp;family\u003dRoboto:wght@400;700\u0026amp;display\u003dswap\u0027);\n    .title { font-size: 24px; font-weight: 500; text-anchor: middle; fill: #5f6368; }\n    .subtitle { font-size: 16px; text-anchor: middle; fill: #5f6368; }\n    .grid-line { stroke: #e0e0e0; stroke-dasharray: 2 2; stroke-width: 0.8; }\n    .axis-label { font-size: 13px; fill: #5f6368; text-anchor: middle; }\n    .source { font-size: 11px; fill: #70757a; text-anchor: end; }\n    .y-axis-value { font-family: \u0027Roboto\u0027, sans-serif; font-size: 12px; fill: #757575; text-anchor: end; }\n  \u003c/style\u003e\n  \u003cg id\u003d\"title-group\"\u003e\u003c/g\u003e\n  \u003cg id\u003d\"y-axis-group\"\u003e\u003c/g\u003e\n  \u003cg id\u003d\"chart-area-group\"\u003e\u003c/g\u003e\n  \u003cg id\u003d\"x-axis-group\"\u003e\u003c/g\u003e\n  \u003cg id\u003d\"source-group\"\u003e\u003c/g\u003e\n  \u003cscript type\u003d\"text/javascript\"\u003e\n    const svgNS \u003d \"http://www.w3.org/2000/svg\";\n    function createSVGElement(name, attributes, textContent) {\n      const el \u003d document.createElementNS(svgNS, name);\n      for (const key in attributes) el.setAttribute(key, attributes[key]);\n      if (textContent !\u003d\u003d undefined \u0026\u0026 textContent !\u003d\u003d null) el.textContent \u003d textContent;\n      return el;\n    }\n    function hexToRgb(hex) {\n      let shorthandRegex \u003d /^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i;\n      hex \u003d hex.replace(shorthandRegex, function(m, r, g, b) {\n        return r + r + g + g + b + b;\n      });\n      let result \u003d /^#?([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/i.exec(hex);\n      return result ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16)\n      } : null;\n    }\n    function rgbToHsl(r, g, b) {\n      r /\u003d 255; g /\u003d 255; b /\u003d 255;\n      let max \u003d Math.max(r, g, b), min \u003d Math.min(r, g, b);\n      let h, s, l \u003d (max + min) / 2;\n      l \u003d Math.round(l * 100);\n      if (max \u003d\u003d min) { h \u003d s \u003d 0; } else {\n        let d \u003d max - min;\n        s \u003d l \u003e 50 ? d / (2 - max - min) : d / (max + min);\n        s \u003d Math.round(s * 100);\n        switch (max) {\n          case r: h \u003d (g - b) / d + (g \u003c b ? 6 : 0); break;\n          case g: h \u003d (b - r) / d + 2; break;\n          case b: h \u003d (r - g) / d + 4; break;\n        }\n        h /\u003d 6;\n      }\n      h \u003d Math.round(h * 360);\n      return [h, s, l];\n    }\n    function hslToRgb(h, s, l) {\n      let r, g, b;\n      h /\u003d 360; s /\u003d 100; l /\u003d 100;\n      if (s \u003d\u003d 0) { r \u003d g \u003d b \u003d l; } else {\n        function hue2rgb(p, q, t) {\n          if (t \u003c 0) t +\u003d 1;\n          if (t \u003e 1) t -\u003d 1;\n          if (t \u003c 1/6) return p + (q - p) * 6 * t;\n          if (t \u003c 1/2) return q;\n          if (t \u003c 2/3) return p + (q - p) * (2/3 - t) * 6;\n          return p;\n        }\n        let q \u003d l \u003c 0.5 ? l * (1 + s) : l + s - l * s;\n        let p \u003d 2 * l - q;\n        r \u003d hue2rgb(p, q, h + 1/3);\n        g \u003d hue2rgb(p, q, h);\n        b \u003d hue2rgb(p, q, h - 1/3);\n      }\n      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\n    }\n    function rgbToHex(r, g, b) {\n      function componentToHex(c) {\n        let hex \u003d c.toString(16);\n        return hex.length \u003d\u003d 1 ? \"0\" + hex : hex;\n      }\n      return \"#\" + componentToHex(r) + componentToHex(g) + componentToHex(b);\n    }\n    function truncateText(text, maxWidth, className) {\n      const svgRoot \u003d document.getElementById(\u0027line-chart-svg\u0027);\n      const tempText \u003d createSVGElement(\u0027text\u0027, { class: className, style: \u0027visibility: hidden;\u0027 });\n      svgRoot.appendChild(tempText);\n      tempText.textContent \u003d text;\n      if (tempText.getComputedTextLength() \u003c\u003d maxWidth) {\n        svgRoot.removeChild(tempText);\n        return text;\n      }\n      let truncatedText \u003d text;\n      while (truncatedText.length \u003e 0) {\n        truncatedText \u003d truncatedText.slice(0, -1);\n        tempText.textContent \u003d truncatedText + \u0027...\u0027;\n        if (tempText.getComputedTextLength() \u003c\u003d maxWidth) {\n          svgRoot.removeChild(tempText);\n          return truncatedText + \u0027...\u0027;\n        }\n      }\n      svgRoot.removeChild(tempText);\n      return \u0027...\u0027;\n    }\n    function buildChart(config) {\n      const svgRoot \u003d document.getElementById(\u0027line-chart-svg\u0027);\n      const defs \u003d svgRoot.querySelector(\u0027defs\u0027);\n      const style \u003d svgRoot.querySelector(\u0027style\u0027);\n      const existingGrads \u003d defs.querySelectorAll(\u0027linearGradient\u0027);\n      existingGrads.forEach(grad \u003d\u003e grad.remove());\n      let styleContent \u003d style.textContent;\n      styleContent \u003d styleContent.replace(/[.]line {[^}]*}/g, \u0027\u0027);\n      styleContent \u003d styleContent.replace(/[.]marker {[^}]*}/g, \u0027\u0027);\n      styleContent \u003d styleContent.replace(/[.]area {[^}]*}/g, \u0027\u0027);\n      styleContent \u003d styleContent.replace(/[.]data-label {[^}]*}/g, \u0027\u0027);\n      style.textContent \u003d styleContent.trim();\n      const markerGradId \u003d \u0027markerGradient\u0027;\n      let markerGrad \u003d createSVGElement(\u0027linearGradient\u0027, { id: markerGradId, x1:\"0\", x2:\"0\", y1:\"0\", y2:\"1\" });\n      markerGrad.appendChild(createSVGElement(\u0027stop\u0027, { offset: \u00270%\u0027, \u0027stop-color\u0027: config.color.start }));\n      markerGrad.appendChild(createSVGElement(\u0027stop\u0027, { offset: \u0027100%\u0027, \u0027stop-color\u0027: config.color.end }));\n      defs.appendChild(markerGrad);\n      const areaGradId \u003d \u0027areaGradient\u0027;\n      let areaGrad \u003d createSVGElement(\u0027linearGradient\u0027, { id: areaGradId, x1:\"0\", x2:\"0\", y1:\"0\", y2:\"1\" });\n      areaGrad.appendChild(createSVGElement(\u0027stop\u0027, { offset: \u00270%\u0027, \u0027stop-color\u0027: config.color.start, \u0027stop-opacity\u0027: \u00270.2\u0027 }));\n      areaGrad.appendChild(createSVGElement(\u0027stop\u0027, { offset: \u0027100%\u0027, \u0027stop-color\u0027: config.color.end, \u0027stop-opacity\u0027: \u00270\u0027 }));\n      defs.appendChild(areaGrad);\n      const nl \u003d String.fromCharCode(10);\n      let dynamicStyles \u003d [\n          \"\",\n          \"            .line { fill: none; stroke: \" + config.color.line + \"; stroke-width: 3; stroke-linejoin: round; stroke-linecap: round; filter: url(#shadow);\",\n          \"            }\",\n          \"            .marker { fill: url(#\" + markerGradId + \"); stroke: white; stroke-width: 2; filter: url(#shadow); }\",\n          \"            .area { fill: url(#\" + areaGradId + \");\",\n          \"            }\",\n          \"            .data-label { font-family: \u0027Roboto\u0027, sans-serif; font-size: 14px; font-weight: bold; fill: \" + config.color.label + \"; text-anchor: middle; filter: url(#text-halo); }\",\n          \"        \"\n      ].join(nl);\n      style.textContent +\u003d dynamicStyles;\n      const groups \u003d {\n        title: document.getElementById(\u0027title-group\u0027),\n        yAxis: document.getElementById(\u0027y-axis-group\u0027),\n        chartArea: document.getElementById(\u0027chart-area-group\u0027),\n        xAxis: document.getElementById(\u0027x-axis-group\u0027),\n        source: document.getElementById(\u0027source-group\u0027)\n      };\n      for (const key in groups) {\n        while (groups[key].firstChild) groups[key].removeChild(groups[key].firstChild);\n      }\n      const chartAreaWidth \u003d config.layout.width - config.layout.marginLeft - config.layout.marginRight;\n      const chartAreaHeight \u003d config.layout.height - config.layout.marginTop - config.layout.marginBottom;\n      const effectivePlotWidth \u003d chartAreaWidth - (config.lineOptions.horizontalPadding * 2);\n      const dataMax \u003d Math.max.apply(null, config.items.map(function(item) { return item.value; }).concat([config.yAxis.max]));\n      const dataMin \u003d Math.min.apply(null, config.items.map(function(item) { return item.value; }).concat([config.yAxis.min]));\n      const hasDataDecimals \u003d config.items.some(function(item) {\n        return typeof item.value \u003d\u003d\u003d \u0027number\u0027 \u0026\u0026 item.value % 1 !\u003d\u003d 0;\n      });\n      const hasAxisDecimals \u003d (typeof config.yAxis.min \u003d\u003d\u003d \u0027number\u0027 \u0026\u0026 config.yAxis.min % 1 !\u003d\u003d 0) ||\n        (typeof config.yAxis.max \u003d\u003d\u003d \u0027number\u0027 \u0026\u0026 config.yAxis.max % 1 !\u003d\u003d 0);\n      const showDecimals \u003d hasDataDecimals || hasAxisDecimals;\n      let effectiveYAxisMax, effectiveYAxisMin;\n      const tickCount \u003d config.yAxis.tickCount \u003e 0 ? config.yAxis.tickCount : 1;\n      const preliminaryRange \u003d Math.max(0.1, config.yAxis.max - config.yAxis.min);\n      let tickInterval \u003d preliminaryRange / tickCount;\n      if (dataMin \u003c config.yAxis.min) {\n        const limit \u003d Math.max(Math.abs(dataMin), dataMax);\n        if (tickInterval \u003c\u003d 0 || isNaN(tickInterval)) tickInterval \u003d Math.max(1, limit / 5);\n        effectiveYAxisMax \u003d Math.ceil(limit / tickInterval) * tickInterval;\n        effectiveYAxisMin \u003d -effectiveYAxisMax;\n        if (config.yAxis.min \u003e effectiveYAxisMin) effectiveYAxisMin \u003d config.yAxis.min;\n        if (config.yAxis.max \u003c effectiveYAxisMax) effectiveYAxisMax \u003d config.yAxis.max;\n      } else {\n        effectiveYAxisMin \u003d config.yAxis.min;\n        if (tickInterval \u003c\u003d 0 || isNaN(tickInterval)) tickInterval \u003d Math.max(1, (dataMax - effectiveYAxisMin) / 5) || 1;\n        effectiveYAxisMax \u003d Math.max(config.yAxis.max, Math.ceil(dataMax / tickInterval) * tickInterval);\n      }\n      if (effectiveYAxisMax \u003c\u003d effectiveYAxisMin) {\n        effectiveYAxisMax \u003d effectiveYAxisMin + tickInterval * tickCount;\n        if (effectiveYAxisMax \u003c\u003d effectiveYAxisMin) effectiveYAxisMax \u003d effectiveYAxisMin + 1;\n      }\n      const yRange \u003d effectiveYAxisMax - effectiveYAxisMin;\n      const xScale \u003d function(index) { return (config.layout.marginLeft + config.lineOptions.horizontalPadding) + (config.items.length \u003e 1 ? (index * (effectivePlotWidth / (config.items.length - 1))) : effectivePlotWidth / 2 ); };\n      const yScale \u003d function(value) { return (yRange \u003d\u003d\u003d 0) ? config.layout.marginTop + chartAreaHeight / 2 : config.layout.marginTop + chartAreaHeight * (1 - (value - effectiveYAxisMin) / yRange); };\n      const bottomY \u003d config.layout.marginTop + chartAreaHeight;\n      const animationProgress \u003d (config.animation \u003d\u003d null) \n          ? 1.0 \n          : Math.max(0, Math.min(1, Number(config.animation)));\n      let animationOpacity;\n      const fadeStart \u003d 0.7;\n      if (animationProgress \u003c\u003d fadeStart) {\n          animationOpacity \u003d 0;\n      } else {\n          animationOpacity \u003d (animationProgress - fadeStart) / (1.0 - fadeStart);\n      }\n      groups.title.appendChild(createSVGElement(\u0027text\u0027, { x: 312, y: 50, class: \u0027title\u0027 }, config.title));\n      groups.title.appendChild(createSVGElement(\u0027text\u0027, { x: 312, y: 75, class: \u0027subtitle\u0027 }, config.subtitle));\n      groups.source.appendChild(createSVGElement(\u0027text\u0027, { x: 600, y: 450, class: \u0027source\u0027 }, config.source));\n      groups.yAxis.appendChild(createSVGElement(\u0027text\u0027, { x: config.layout.marginLeft, y: config.layout.marginTop - 15, class: \u0027y-axis-value\u0027, \u0027text-anchor\u0027: \u0027end\u0027 }, config.yAxisUnitLabel));\n      const finalTickStep \u003d yRange / tickCount;\n      for (let i \u003d 0; i \u003c\u003d tickCount; i++) {\n        const tickValue \u003d effectiveYAxisMin + (finalTickStep * i);\n        const y \u003d yScale(tickValue);\n        let tickLabel;\n        if (showDecimals) {\n          tickLabel \u003d parseFloat(tickValue.toFixed(5));\n        } else {\n          tickLabel \u003d Math.round(tickValue);\n        }\n        groups.yAxis.appendChild(createSVGElement(\u0027text\u0027, { x: config.layout.marginLeft - 10, y, class: \u0027y-axis-value\u0027, \u0027dominant-baseline\u0027: \u0027middle\u0027 }, tickLabel));\n        if (i \u003e 0 \u0026\u0026 (Math.abs(tickValue) \u003e 1e-6 || effectiveYAxisMin \u003e\u003d 0)) {\n          groups.yAxis.appendChild(createSVGElement(\u0027line\u0027, { x1: config.layout.marginLeft, y1: y, x2: config.layout.width - config.layout.marginRight, y2: y, class: \u0027grid-line\u0027 }));\n        }\n      }\n      if (effectiveYAxisMin \u003c 0 \u0026\u0026 effectiveYAxisMax \u003e 0) {\n        groups.yAxis.appendChild(createSVGElement(\u0027line\u0027, { x1: config.layout.marginLeft, y1: yScale(0), x2: config.layout.width - config.layout.marginRight, y2: yScale(0), stroke: \u0027#bdbdbd\u0027, \u0027stroke-width\u0027: 1 }));\n      }\n      groups.xAxis.appendChild(createSVGElement(\u0027line\u0027, { x1: config.layout.marginLeft, y1: bottomY, x2: config.layout.width - config.layout.marginRight, y2: bottomY, stroke: \u0027#bdbdbd\u0027, \u0027stroke-width\u0027: 1 }));\n      const xSlotWidth \u003d config.items.length \u003e 1 ? effectivePlotWidth / (config.items.length - 1) : effectivePlotWidth;\n      config.items.forEach(function(item, index) {\n        const x \u003d xScale(index);\n        const labelContent \u003d truncateText(item.label, xSlotWidth * 0.9, \u0027axis-label\u0027);\n        groups.xAxis.appendChild(createSVGElement(\u0027text\u0027, { x: x, y: bottomY + 20, class: \u0027axis-label\u0027 }, labelContent));\n      });\n      if (config.items.length \u003e 0) {\n        const areaBottomY \u003d yScale(Math.max(0, effectiveYAxisMin));\n        const pointsData \u003d config.items.map(function(item, index) {\n            const x \u003d xScale(index);\n            const finalY \u003d yScale(item.value);\n            const animatedY \u003d areaBottomY + (finalY - areaBottomY) * animationProgress;\n            return {\n                x: x,\n                finalY: finalY,\n                animatedY: animatedY,\n                value: item.value\n            };\n        });\n        const points \u003d pointsData.map(function(d) { return d.x + \u0027,\u0027 + d.animatedY; });\n        const areaPoints \u003d xScale(0) + \u0027,\u0027 + areaBottomY + \u0027 \u0027 + points.join(\u0027 \u0027) + \u0027 \u0027 + xScale(config.items.length - 1) + \u0027,\u0027 + areaBottomY;\n        groups.chartArea.appendChild(createSVGElement(\u0027polygon\u0027, { class: \u0027area\u0027, points: areaPoints }));\n        groups.chartArea.appendChild(createSVGElement(\u0027polyline\u0027, { class: \u0027line\u0027, points: points.join(\u0027 \u0027) }));\n        const dataPointsGroup \u003d createSVGElement(\u0027g\u0027, { class: \u0027data-points\u0027 });\n        pointsData.forEach(function(data, index) {\n          const x \u003d data.x;\n          const y \u003d data.animatedY;\n          const finalY \u003d data.finalY; \n          dataPointsGroup.appendChild(createSVGElement(\u0027circle\u0027, { \n              cx: x, \n              cy: y,\n              r: config.lineOptions.markerRadius, \n              class: \u0027marker\u0027 \n          }));\n          let labelY;\n  if (y \u003c config.layout.marginTop + 20) { \n            labelY \u003d y + config.lineOptions.dataLabelOffsetY + 5; \n          } else {\n            labelY \u003d y - config.lineOptions.dataLabelOffsetY;\n  }\n          let dataLabelValue \u003d data.value;\n          if (!showDecimals) {\n            dataLabelValue \u003d Math.round(dataLabelValue);\n          }\n          dataPointsGroup.appendChild(createSVGElement(\u0027text\u0027, { \n              x: x, \n              y: labelY,\n              class: \u0027data-label\u0027,\n              style: \u0027opacity: \u0027 + animationOpacity\n          }, dataLabelValue));\n        });\n        groups.chartArea.appendChild(dataPointsGroup);\n      }\n    }\n    try {\n      const configJson \u003d document.getElementById(\u0027chart-json-data\u0027).textContent;\n      if (!configJson || configJson.trim() \u003d\u003d\u003d \u0027\u0027) {\n        throw new Error(\"JSON data is empty.\");\n      }\n      let fullConfig;\n      try {\n        fullConfig \u003d JSON.parse(configJson);\n      } catch (parseError) {\n        throw new Error(\u0027JSON parsing error: \u0027 + parseError.message);\n      }\n      if (!fullConfig || typeof fullConfig !\u003d\u003d \u0027object\u0027 || !fullConfig.data) {\n        throw new Error(\"Invalid JSON structure: Missing \u0027data\u0027 key.\");\n      }\n      const config \u003d fullConfig.data;\n      const defaultLineOptions \u003d {\n          markerRadius: 5,\n          dataLabelOffsetY: 15,\n          horizontalPadding: 30\n      };\n      if (config.lineOptions \u0026\u0026 typeof config.lineOptions \u003d\u003d\u003d \u0027object\u0027) {\n          config.lineOptions \u003d {\n              markerRadius: (config.lineOptions.markerRadius !\u003d\u003d undefined \u0026\u0026 typeof config.lineOptions.markerRadius \u003d\u003d\u003d \u0027number\u0027) ?\n                config.lineOptions.markerRadius : defaultLineOptions.markerRadius,\n              dataLabelOffsetY: (config.lineOptions.dataLabelOffsetY !\u003d\u003d undefined \u0026\u0026 typeof config.lineOptions.dataLabelOffsetY \u003d\u003d\u003d \u0027number\u0027) ?\n                config.lineOptions.dataLabelOffsetY : defaultLineOptions.dataLabelOffsetY,\n              horizontalPadding: (config.lineOptions.horizontalPadding !\u003d\u003d undefined \u0026\u0026 typeof config.lineOptions.horizontalPadding \u003d\u003d\u003d \u0027number\u0027) ?\n                config.lineOptions.horizontalPadding : defaultLineOptions.horizontalPadding\n          };\n      } else {\n          config.lineOptions \u003d defaultLineOptions;\n      }\n      if (config.colors) {\n          config.color \u003d config.colors;\n      }\n      if (config.color \u0026\u0026 typeof config.color \u003d\u003d\u003d \u0027string\u0027) {\n        const colorKeyword \u003d config.color.toLowerCase();\n        let generatedColorObject;\n        if (colorKeyword \u003d\u003d\u003d \u0027#gemini\u0027) {\n          const GEMINI_STOPS \u003d [\u0027#E68A9C\u0027, \u0027#9F63D0\u0027, \u0027#616AD8\u0027];\n          generatedColorObject \u003d {\n            start: GEMINI_STOPS[0], line:  GEMINI_STOPS[1],\n            end:   GEMINI_STOPS[1], label: GEMINI_STOPS[2]\n          };\n        } else if (colorKeyword \u003d\u003d\u003d \u0027#night\u0027) {\n          const NIGHT_COLORS \u003d [\n            { start: \u0027#8d58d3\u0027, end: \u0027#704ca4\u0027 },\n            { start: \u0027#8f83d6\u0027, end: \u0027#7469a8\u0027 },\n            { start: \u0027#7891dd\u0027, end: \u0027#5c6fbb\u0027 }\n          ];\n          generatedColorObject \u003d {\n            start: NIGHT_COLORS[0].start, end:   NIGHT_COLORS[1].start,\n            line:  NIGHT_COLORS[1].end,   label: NIGHT_COLORS[2].end\n          };\n        } else {\n          const primaryColor \u003d config.color;\n          const rgb \u003d hexToRgb(primaryColor);\n          if (!rgb) { throw new Error(\"Invalid HEX color string in \u0027color\u0027: \" + primaryColor); }\n          const hsl \u003d rgbToHsl(rgb.r, rgb.g, rgb.b);\n          const h \u003d hsl[0], s \u003d hsl[1], l \u003d hsl[2];\n          const l_start \u003d Math.min(100, l + 20);\n          const s_start \u003d (l \u003e 80) ? s * 0.7 : s;\n          const rgb_start \u003d hslToRgb(h, s_start, l_start);\n          const hex_start \u003d rgbToHex(rgb_start[0], rgb_start[1], rgb_start[2]);\n          const l_label \u003d Math.max(0, l - 15);\n          const s_label \u003d (l \u003c 20) ? s * 0.7 : s;\n          const rgb_label \u003d hslToRgb(h, s_label, l_label);\n          const hex_label \u003d rgbToHex(rgb_label[0], rgb_label[1], rgb_label[2]);\n          generatedColorObject \u003d {\n            start: hex_start, end:   primaryColor,\n            line:  primaryColor, label: hex_label\n          };\n        }\n        config.color \u003d generatedColorObject;\n      } else if (!config.color || typeof config.color !\u003d\u003d \u0027object\u0027) {\n         throw new Error(\"\u0027color\u0027 must be a color object or a single color string.\");\n      }\n      if (!config || typeof config !\u003d\u003d \u0027object\u0027 || !config.items || !Array.isArray(config.items)) {\n        throw new Error(\"Invalid JSON structure: Missing required fields like \u0027items\u0027 inside \u0027data\u0027.\");\n      }\n      buildChart(config);\n    } catch (e) {\n      console.error(\"Chart Error:\", e);\n      const svgRoot \u003d document.getElementById(\u0027line-chart-svg\u0027);\n      const existingError \u003d svgRoot.querySelector(\u0027.error-message\u0027);\n      if(existingError) existingError.remove();\n      const textEl \u003d createSVGElement(\u0027text\u0027, {\n        x: svgRoot.viewBox.baseVal.width / 2 + svgRoot.viewBox.baseVal.x,\n        y: svgRoot.viewBox.baseVal.height / 2 + svgRoot.viewBox.baseVal.y,\n        \u0027text-anchor\u0027: \u0027middle\u0027, fill: \u0027red\u0027,\n        \u0027font-family\u0027: \"\u0027Noto Sans JP\u0027, sans-serif\",\n        class: \u0027error-message\u0027\n      });\n      textEl.textContent \u003d e.message.includes(\u0027JSON\u0027) ? \u0027JSONデータにエラーがあります。\u0027 : \u0027グラフ描画エラーが発生しました。\u0027;\n      if (e.message.includes(\u0027JSON parsing error\u0027)) {\n        textEl.textContent +\u003d \u0027 (\u0027 + e.message.split(\u0027: \u0027)[1] + \u0027)\u0027;\n      }\n      svgRoot.appendChild(textEl);\n    }\n  \u003c/script\u003e\n\u003c/svg\u003e\n`;\nconst DONUT_CHART_TEMPLATE \u003d `\n\u003csvg width\u003d\"600\" height\u003d\"460\" viewBox\u003d\"0 25 600 425\" xmlns\u003d\"http://www.w3.org/2000/svg\" font-family\u003d\"\u0027Noto Sans JP\u0027, sans-serif\" id\u003d\"donut-chart-svg\"\u003e\n  \u003cscript id\u003d\"chart-json-data\" type\u003d\"application/json\"\u003e\n    {\n      \"chartType\": \"donut\",\n      \"data\": {\n        \"title\": \"グラフタイトル\",\n        \"subtitle\": \"グラフサブタイトル\",\n        \"source\": \"出典: データソース\",\n        \"centerLabel\": \"合計ラベル\",\n        \"colors\": [\n          { \"id\": \"A\", \"start\": \"#e68a9c\", \"end\": \"#d96d8f\" },\n          { \"id\": \"B\", \"start\": \"#b469b8\", \"end\": \"#a656ad\" },\n          { \"id\": \"C\", \"start\": \"#9f63d0\", \"end\": \"#8c4fc8\" },\n          { \"id\": \"D\", \"start\": \"#7c6ce8\", \"end\": \"#6b5ce0\" },\n          { \"id\": \"E\", \"start\": \"#616ad8\", \"end\": \"#5059d1\" }\n        ],\n        \"items\": [\n          { \"label\": \"項目 A\", \"value\": 40, \"id\": \"A\" },\n          { \"label\": \"項目 B\", \"value\": 25, \"id\": \"B\" },\n          { \"label\": \"項目 C\", \"value\": 15, \"id\": \"C\" },\n          { \"label\": \"項目 D\", \"value\": 10, \"id\": \"D\" },\n          { \"label\": \"項目 E\", \"value\": 10, \"id\": \"E\" }\n        ],\n        \"animation\" : 1\n      }\n    }\n  \u003c/script\u003e\n  \u003cdefs\u003e\n    \u003cfilter id\u003d\"shadow\"\u003e\u003cfeDropShadow dx\u003d\"1\" dy\u003d\"2\" stdDeviation\u003d\"2\" flood-color\u003d\"#000\" flood-opacity\u003d\"0.4\"/\u003e\u003c/filter\u003e\n  \u003c/defs\u003e\n  \u003cstyle\u003e\n    @import url(\u0027https://fonts.googleapis.com/css2?family\u003dNoto+Sans+JP:wght@400;500;700\u0026amp;family\u003dRoboto:wght@400;700\u0026amp;display\u003dswap\u0027);\n    .title { font-size: 24px; font-weight: 500; text-anchor: middle; fill: #5f6368; }\n    .subtitle { font-size: 16px; text-anchor: middle; fill: #5f6368; }\n    .source { font-size: 11px; fill: #70757a; text-anchor: end; }\n    .center-total-label { font-size: 14px; fill: #5f6368; text-anchor: middle; dominant-baseline: central; }\n    .legend-item { font-size: 13px; fill: #5f6368; dominant-baseline: middle; }\n    .donut-segment { filter: url(#shadow); }\n    .center-total-value { font-family: \u0027Roboto\u0027, sans-serif; font-size: 28px; font-weight: bold; fill: #5f6368; text-anchor: middle; dominant-baseline: central; }\n    .legend-percentage { font-family: \u0027Roboto\u0027, sans-serif; font-weight: 400; }\n  \u003c/style\u003e\n  \u003cg id\u003d\"title-group\"\u003e\u003c/g\u003e\n  \u003cg id\u003d\"donut-group\"\u003e\u003c/g\u003e\n  \u003cg id\u003d\"legend-group\"\u003e\u003c/g\u003e\n  \u003cg id\u003d\"source-group\"\u003e\u003c/g\u003e\n  \u003cscript type\u003d\"text/javascript\"\u003e\n    const svgNS \u003d \"http://www.w3.org/2000/svg\";\n    function createSVGElement(name, attributes, textContent) {\n      const el \u003d document.createElementNS(svgNS, name);\n      for (const key in attributes) el.setAttribute(key, attributes[key]);\n      if (textContent !\u003d\u003d undefined \u0026\u0026 textContent !\u003d\u003d null) el.textContent \u003d textContent;\n      return el;\n    }\n    function polarToCartesian(centerX, centerY, radius, angleInDegrees) {\n      const angleInRadians \u003d (angleInDegrees - 90) * Math.PI / 180.0;\n      return {\n        x: centerX + (radius * Math.cos(angleInRadians)),\n        y: centerY + (radius * Math.sin(angleInRadians))\n      };\n    }\n    function createDonutSegmentPath(x, y, radius, startAngle, endAngle) {\n      if (endAngle - startAngle \u003e\u003d 360) endAngle \u003d 359.99;\n      const start \u003d polarToCartesian(x, y, radius, endAngle);\n      const end \u003d polarToCartesian(x, y, radius, startAngle);\n      const largeArcFlag \u003d endAngle - startAngle \u003c\u003d 180 ? \"0\" : \"1\";\n      return \u0027M \u0027 + x + \u0027 \u0027 + y + \u0027 L \u0027 + start.x + \u0027 \u0027 + start.y + \u0027 A \u0027 + radius + \u0027 \u0027 + radius + \u0027 0 \u0027 + largeArcFlag + \u0027 0 \u0027 + end.x + \u0027 \u0027 + end.y + \u0027 Z\u0027;\n    }\n    function hexToRgb(hex) {\n      let shorthandRegex \u003d /^#?([a-f0-9])([a-f0-9])([a-f0-9])$/i;\n      hex \u003d hex.replace(shorthandRegex, function(m, r, g, b) {\n        return r + r + g + g + b + b;\n      });\n      let result \u003d /^#?([a-f0-9]{2})([a-f0-9]{2})([a-f0-9]{2})$/i.exec(hex);\n      return result ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16)\n      } : null;\n    }\n    function rgbToHsl(r, g, b) {\n      r /\u003d 255; g /\u003d 255; b /\u003d 255;\n      let max \u003d Math.max(r, g, b), min \u003d Math.min(r, g, b);\n      let h, s, l \u003d (max + min) / 2;\n      l \u003d Math.round(l * 100);\n      if (max \u003d\u003d min) {\n        h \u003d s \u003d 0;\n      } else {\n        let d \u003d max - min;\n        s \u003d l \u003e 50 ? d / (2 - max - min) : d / (max + min);\n        s \u003d Math.round(s * 100);\n        switch (max) {\n          case r: h \u003d (g - b) / d + (g \u003c b ? 6 : 0); break;\n          case g: h \u003d (b - r) / d + 2; break;\n          case b: h \u003d (r - g) / d + 4; break;\n        }\n        h /\u003d 6;\n      }\n      h \u003d Math.round(h * 360);\n      return [h, s, l];\n    }\n    function hslToRgb(h, s, l) {\n      let r, g, b;\n      h /\u003d 360;\n      s /\u003d 100;\n      l /\u003d 100;\n      if (s \u003d\u003d 0) {\n        r \u003d g \u003d b \u003d l;\n      } else {\n        function hue2rgb(p, q, t) {\n          if (t \u003c 0) t +\u003d 1;\n          if (t \u003e 1) t -\u003d 1;\n          if (t \u003c 1/6) return p + (q - p) * 6 * t;\n          if (t \u003c 1/2) return q;\n          if (t \u003c 2/3) return p + (q - p) * (2/3 - t) * 6;\n          return p;\n        }\n        let q \u003d l \u003c 0.5 ? l * (1 + s) : l + s - l * s;\n        let p \u003d 2 * l - q;\n        r \u003d hue2rgb(p, q, h + 1/3);\n        g \u003d hue2rgb(p, q, h);\n        b \u003d hue2rgb(p, q, h - 1/3);\n      }\n      return [Math.round(r * 255), Math.round(g * 255), Math.round(b * 255)];\n    }\n    function rgbToHex(r, g, b) {\n      function componentToHex(c) {\n        let hex \u003d c.toString(16);\n        return hex.length \u003d\u003d 1 ? \"0\" + hex : hex;\n      }\n      return \"#\" + componentToHex(r) + componentToHex(g) + componentToHex(b);\n    }\n    function linearInterpolateColor(hex1, hex2, t) {\n      const rgb1 \u003d hexToRgb(hex1);\n      const rgb2 \u003d hexToRgb(hex2);\n      const r \u003d Math.round(rgb1.r + (rgb2.r - rgb1.r) * t);\n      const g \u003d Math.round(rgb1.g + (rgb2.g - rgb1.g) * t);\n      const b \u003d Math.round(rgb1.b + (rgb2.b - rgb1.b) * t);\n      return rgbToHex(r, g, b);\n    }\n    function generateGradientScale(gradientStops, numSteps) {\n      const palette \u003d [];\n      if (numSteps \u003c\u003d 0) return [];\n      if (numSteps \u003d\u003d\u003d 1) return [gradientStops[0]];\n      const numSegments \u003d gradientStops.length - 1;\n      for (let i \u003d 0; i \u003c numSteps; i++) {\n        const t_global \u003d (numSteps \u003d\u003d\u003d 1) ? 0 : (i / (numSteps - 1));\n        const segmentProgress \u003d t_global * numSegments;\n        const stopIndex1 \u003d Math.floor(segmentProgress);\n        const stopIndex2 \u003d Math.min(stopIndex1 + 1, numSegments); \n        const t_local \u003d segmentProgress - stopIndex1;\n        const hex1 \u003d gradientStops[stopIndex1];\n        const hex2 \u003d gradientStops[stopIndex2];\n        palette.push(linearInterpolateColor(hex1, hex2, t_local));\n      }\n      return palette;\n    }\n    function generateMonochromaticScale(primaryHex, colorIds) {\n      const numSteps \u003d colorIds.length;\n      if (numSteps \u003d\u003d\u003d 0) return [];\n      const rgb \u003d hexToRgb(primaryHex);\n      if (!rgb) return [];\n      const [h, s, l_mid_original] \u003d rgbToHsl(rgb.r, rgb.g, rgb.b);\n      const gradientDarken \u003d 7;\n      const L_MAX \u003d 80; \n      const L_MIN \u003d 45; \n      const l_step_amount \u003d numSteps \u003e 1 ? (L_MAX - L_MIN) / (numSteps - 1) : 0;\n      const l_steps_calc \u003d [];\n      for (let i \u003d 0; i \u003c numSteps; i++) {\n        const l_val \u003d L_MAX - (i * l_step_amount);\n        l_steps_calc.push(l_val);\n      }\n      const l_steps_light \u003d [];\n      const l_steps_dark \u003d [];\n      const mid_index \u003d Math.ceil(numSteps / 2);\n      for (let i \u003d 0; i \u003c mid_index; i++) {\n        l_steps_light.push(l_steps_calc[i]);\n      }\n      for (let i \u003d mid_index; i \u003c numSteps; i++) {\n        l_steps_dark.push(l_steps_calc[i]);\n      }\n      const l_steps_start \u003d [];\n      for (let i \u003d 0; i \u003c numSteps; i++) {\n        if (i % 2 \u003d\u003d\u003d 0) {\n          l_steps_start.push(l_steps_light[i / 2]);\n        } else {\n          l_steps_start.push(l_steps_dark[(i - 1) / 2]);\n        }\n      }\n      const colors \u003d [];\n      for (let i \u003d 0; i \u003c numSteps; i++) {\n        const l_start_step \u003d l_steps_start[i];\n        let l_start \u003d Math.max(0, Math.min(100, l_start_step));\n        let l_end \u003d Math.max(0, Math.min(100, l_start - gradientDarken));\n        let s_adjusted \u003d s;\n        if (l_start \u003e 85) s_adjusted \u003d s * (1 - (l_start - 85) / 15);\n        if (l_start \u003c 20) s_adjusted \u003d s * (l_start / 20);\n        s_adjusted \u003d Math.max(0, Math.min(100, s_adjusted));\n        const rgb_start \u003d hslToRgb(h, s_adjusted, l_start);\n        const hex_start \u003d rgbToHex(rgb_start[0], rgb_start[1], rgb_start[2]);\n        const rgb_end \u003d hslToRgb(h, s_adjusted, l_end);\n        const hex_end \u003d rgbToHex(rgb_end[0], rgb_end[1], rgb_end[2]);\n        colors.push({\n          id: colorIds[i],\n          start: hex_start,\n          end: hex_end\n        });\n      }\n      return colors;\n    }\n    function buildChart(config) {\n      const animProgress \u003d (config.animation \u003d\u003d null) \n        ? 1.0 \n        : Math.max(0, Math.min(1, Number(config.animation)));\n      const total \u003d config.items.reduce((sum, item) \u003d\u003e sum + item.value, 0);\n      if (total \u003d\u003d\u003d 0) return;\n      const layout \u003d {\n        centerY: 260,\n        outerRadius: 150,\n        innerRadius: 75,\n        legendItemHeight: 30,\n        legendColorBoxSize: 12,\n        legendTextOffsetX: 18\n      };\n      const svgElement \u003d document.getElementById(\u0027donut-chart-svg\u0027);\n      const defs \u003d svgElement.querySelector(\u0027defs\u0027);\n      const existingGrads \u003d defs.querySelectorAll(\u0027linearGradient\u0027);\n      existingGrads.forEach(grad \u003d\u003e grad.remove());\n      config.colors.forEach(color \u003d\u003e {\n        const gradId \u003d \u0027grad\u0027 + color.id;\n        let gradient \u003d document.getElementById(gradId);\n        if(gradient) gradient.parentNode.removeChild(gradient);\n        gradient \u003d createSVGElement(\u0027linearGradient\u0027, { id: gradId, x1:\"0\", x2:\"0\", y1:\"0\", y2:\"1\" });\n        gradient.appendChild(createSVGElement(\u0027stop\u0027, { offset: \u00270%\u0027, \u0027stop-color\u0027: color.start }));\n        gradient.appendChild(createSVGElement(\u0027stop\u0027, { offset: \u0027100%\u0027, \u0027stop-color\u0027: color.end }));\n        defs.appendChild(gradient);\n      });\n      const groups \u003d {\n        title: document.getElementById(\u0027title-group\u0027),\n        donut: document.getElementById(\u0027donut-group\u0027),\n        legend: document.getElementById(\u0027legend-group\u0027),\n        source: document.getElementById(\u0027source-group\u0027)\n      };\n      for (const key in groups) {\n        while (groups[key].firstChild) groups[key].removeChild(groups[key].firstChild);\n      }\n      const viewBoxWidth \u003d svgElement.viewBox.baseVal.width;\n      const centerX \u003d viewBoxWidth / 4;\n      const legendX \u003d viewBoxWidth / 2 + 30;\n      config.items.forEach((item, index) \u003d\u003e {\n        const percentage \u003d ((item.value / total) * 100).toFixed(0);\n        const legendItemGroup \u003d createSVGElement(\u0027g\u0027, {\n          class: \u0027legend-item-group\u0027,\n          transform: \u0027translate(0, \u0027 + (index * layout.legendItemHeight) + \u0027)\u0027\n        });\n        const colorData \u003d config.colors.find(c \u003d\u003e c.id \u003d\u003d\u003d item.id);\n        if (!colorData) {\n            console.error(\"Color not found for ID:\", item.id);\n            return; \n        }\n        const color \u003d colorData.end;\n        legendItemGroup.appendChild(createSVGElement(\u0027rect\u0027, { \n          x: 0, y: 0, \n          width: layout.legendColorBoxSize, height: layout.legendColorBoxSize, \n          rx: 2, fill: color, filter: \u0027url(#shadow)\u0027 \n        }));\n        const textEl \u003d createSVGElement(\u0027text\u0027, { \n          x: layout.legendTextOffsetX, \n          y: layout.legendColorBoxSize / 2, \n          class: \u0027legend-item\u0027 \n        });\n        textEl.textContent \u003d item.label + \u0027 (\u0027;\n        const percentageSpan \u003d createSVGElement(\u0027tspan\u0027, { class: \u0027legend-percentage\u0027 }, percentage + \u0027%\u0027);\n        textEl.appendChild(percentageSpan);\n        textEl.appendChild(document.createTextNode(\u0027)\u0027));\n        legendItemGroup.appendChild(textEl);\n        groups.legend.appendChild(legendItemGroup);\n      });\n      const legendHeight \u003d config.items.length * layout.legendItemHeight;\n      const legendY \u003d layout.centerY - (legendHeight / 2);\n      groups.legend.setAttribute(\u0027transform\u0027, \u0027translate(\u0027 + legendX + \u0027, \u0027 + legendY + \u0027)\u0027);\n      const titleX \u003d viewBoxWidth / 2;\n      groups.title.appendChild(createSVGElement(\u0027text\u0027, { x: titleX, y: 50, class: \u0027title\u0027 }, config.title));\n      groups.title.appendChild(createSVGElement(\u0027text\u0027, { x: titleX, y: 75, class: \u0027subtitle\u0027 }, config.subtitle));\n      groups.source.appendChild(createSVGElement(\u0027text\u0027, { x: viewBoxWidth - 10, y: 440, class: \u0027source\u0027 }, config.source));\n    let finalStartAngle \u003d 0;\n    const finalAngles \u003d config.items.map(item \u003d\u003e {\n        const sweep \u003d (item.value / total) * 360;\n        const start \u003d finalStartAngle;\n        finalStartAngle +\u003d sweep;\n        return { start: start, end: finalStartAngle };\n    });\n    const numItems \u003d config.items.length;\n    const equalSweep \u003d 360 / numItems;\n    const equalAngles \u003d config.items.map((item, i) \u003d\u003e {\n        const start \u003d i * equalSweep;\n        const end \u003d (i + 1) * equalSweep;\n        return { start: start, end: end };\n    });\n      let startAngle \u003d 0;\n      config.items.forEach((item, index) \u003d\u003e {\n    const eqStart \u003d equalAngles[index].start;\n    const eqEnd \u003d equalAngles[index].end;\n    const finStart \u003d finalAngles[index].start;\n    const finEnd \u003d finalAngles[index].end;\n    const animatedStartAngle \u003d eqStart + (finStart - eqStart) * animProgress;\n    const animatedEndAngle \u003d eqEnd + (finEnd - eqEnd) * animProgress;\nconst pathData \u003d createDonutSegmentPath(centerX, layout.centerY, layout.outerRadius, animatedStartAngle, animatedEndAngle);\n    groups.donut.appendChild(createSVGElement(\u0027path\u0027, {\n        d: pathData,\n        fill: \u0027url(#grad\u0027 + item.id + \u0027)\u0027,\nclass: \u0027donut-segment\u0027\n    }));\n});\n      groups.donut.appendChild(createSVGElement(\u0027circle\u0027, { cx: centerX, cy: layout.centerY, r: layout.innerRadius, fill: \u0027white\u0027 }));\n      groups.donut.appendChild(createSVGElement(\u0027text\u0027, { x: centerX, y: layout.centerY - 12, class: \u0027center-total-value\u0027 }, total));\n      groups.donut.appendChild(createSVGElement(\u0027text\u0027, { x: centerX, y: layout.centerY + 15, class: \u0027center-total-label\u0027 }, config.centerLabel));\n    }\n    try {\n      const configJson \u003d document.getElementById(\u0027chart-json-data\u0027).textContent;\n      if (!configJson || configJson.trim() \u003d\u003d\u003d \u0027\u0027) {\n        throw new Error(\"JSON data is empty.\");\n      }\n      let fullConfig;\n      try {\n        fullConfig \u003d JSON.parse(configJson);\n      } catch (parseError) {\n        throw new Error(\u0027JSON parsing error: \u0027 + parseError.message);\n      }\n      if (!fullConfig || typeof fullConfig !\u003d\u003d \u0027object\u0027 || !fullConfig.data) {\n        throw new Error(\"Invalid JSON structure: Missing \u0027data\u0027 key.\");\n      }\n      const config \u003d fullConfig.data;\n      if (config.colors \u0026\u0026 typeof config.colors \u003d\u003d\u003d \u0027string\u0027) {\n        if (!config.items || !Array.isArray(config.items)) {\n            throw new Error(\"Invalid JSON: \u0027items\u0027 array is required to generate colors.\");\n        }\n        const colorIds \u003d config.items.map(item \u003d\u003e item.id);\n        const numColors \u003d colorIds.length;\n        if (numColors \u003d\u003d\u003d 0) {\n             throw new Error(\"Invalid JSON: \u0027items\u0027 array is empty.\");\n        }\n        let generatedColors;\n        const colorKeyword \u003d config.colors.toLowerCase();\n        const geminiGradientDarken \u003d 15;\n        if (colorKeyword \u003d\u003d\u003d \u0027#gemini\u0027) {\n          const GEMINI_STOPS \u003d [\u0027#E68A9C\u0027, \u0027#9F63D0\u0027, \u0027#616AD8\u0027];\n          const hexPalette \u003d generateGradientScale(GEMINI_STOPS, numColors);\n          generatedColors \u003d [];\n          for (let i \u003d 0; i \u003c numColors; i++) {\n            const hex_start \u003d hexPalette[i];\n            const rgb_start \u003d hexToRgb(hex_start);\n            const [h, s, l] \u003d rgbToHsl(rgb_start.r, rgb_start.g, rgb_start.b);\n            const l_end \u003d Math.max(0, Math.min(100, l - geminiGradientDarken));\n            const rgb_end \u003d hslToRgb(h, s, l_end);\n            const hex_end \u003d rgbToHex(rgb_end[0], rgb_end[1], rgb_end[2]);\n            generatedColors.push({\n              id: colorIds[i],\n              start: hex_start,\n              end: hex_end\n            });\n          }\n        } else if (colorKeyword \u003d\u003d\u003d \u0027#night\u0027) {\n          const NIGHT_COLORS \u003d [\n            { start: \u0027#8d58d3\u0027, end: \u0027#704ca4\u0027 },\n            { start: \u0027#8f83d6\u0027, end: \u0027#7469a8\u0027 },\n            { start: \u0027#7891dd\u0027, end: \u0027#5c6fbb\u0027 },\n            { start: \u0027#50a89d\u0027, end: \u0027#258a7f\u0027 },\n            { start: \u0027#54c5d5\u0027, end: \u0027#34a0b0\u0027 }\n          ];\n          generatedColors \u003d [];\n          for (let i \u003d 0; i \u003c numColors; i++) {\n            const colorPair \u003d NIGHT_COLORS[i] || NIGHT_COLORS[NIGHT_COLORS.length - 1];\n            generatedColors.push({\n              id: colorIds[i],\n              start: colorPair.start,\n              end: colorPair.end\n            });\n          }\n        } else {\n          const primaryColor \u003d config.colors;\n          generatedColors \u003d generateMonochromaticScale(primaryColor, colorIds);\n          if (generatedColors.length \u003d\u003d\u003d 0) {\n              throw new Error(\"Invalid HEX color string in \u0027colors\u0027: \" + primaryColor);\n          }\n        }\n        if (generatedColors \u0026\u0026 generatedColors.length \u003e 0) {\n          config.colors \u003d generatedColors;\n        } else {\n            throw new Error(\"Failed to generate colors from keyword: \" + config.colors);\n        }\n      } else if (!config.colors || !Array.isArray(config.colors)) {\n          throw new Error(\"\u0027colors\u0027 must be an array of color objects or a single primary color string.\");\n      }\n      if (!config || typeof config !\u003d\u003d \u0027object\u0027 || !config.items || !Array.isArray(config.items)) {\n        throw new Error(\"Invalid JSON structure: Missing required fields like \u0027items\u0027 inside \u0027data\u0027.\");\n      }\n      buildChart(config);\n    } catch (e) {\n      console.error(\"Chart Error:\", e);\n      const svgRoot \u003d document.getElementById(\u0027donut-chart-svg\u0027);\n      const textEl \u003d createSVGElement(\u0027text\u0027, { x: 300, y: 230, \u0027text-anchor\u0027: \u0027middle\u0027, fill: \u0027red\u0027 });\n      textEl.textContent \u003d e.message.includes(\u0027JSON\u0027) ? \u0027JSONデータにエラーがあります。\u0027 : \u0027グラフ描画エラーが発生しました。\u0027;\n      if (e.message.includes(\u0027JSON parsing error\u0027)) {\n        textEl.textContent +\u003d \u0027 (\u0027 + e.message.split(\u0027: \u0027)[1] + \u0027)\u0027;\n      }\n      svgRoot.appendChild(textEl);\n    }\n  \u003c/script\u003e\n\u003c/svg\u003e\n  `;\nfunction mt_getHistoryList() {\n  const props \u003d PropertiesService.getUserProperties();\n  const json \u003d props.getProperty(\u0027MT_HISTORY_LOG\u0027);\n  if (json) {\n    return JSON.parse(json);\n  }\n  return [];\n}\nfunction mt_createSlideFromImages(imagesData, fileName, pdfWidth, pdfHeight, isBackgroundMode) {\n  const ID_16_9 \u003d \u002718bU3NhEPujxFv2yLDGW5yk_ygCy25KxKxa6PK0ONGMM\u0027;\n  const ID_A4_LANDSCAPE \u003d \u00271I-74QmjDrDpCG29JXOX9II7OWHGJDQ60h4Ro15aBFLU\u0027;\n  const ID_A4_PORTRAIT \u003d \u00271aAQvzeaj6vOvcXpQ3Q6GGsBwZj_wMTWy9Afi_co_d2c\u0027;\n  try {\n    const ratio \u003d pdfWidth / pdfHeight;\n    let selectedTemplateId \u003d \"\";\n    let isStretchMode \u003d false;\n    if (pdfWidth \u003e pdfHeight) {\n      if (Math.abs(ratio - 1.778) \u003c 0.15) {\n        selectedTemplateId \u003d ID_16_9;\n        isStretchMode \u003d true; \n      } else {\n        selectedTemplateId \u003d ID_A4_LANDSCAPE;\n        isStretchMode \u003d false;\n      }\n    } else {\n      selectedTemplateId \u003d ID_A4_PORTRAIT;\n      isStretchMode \u003d false;\n    }\n    const templateFile \u003d DriveApp.getFileById(selectedTemplateId);\n    const newFile \u003d templateFile.makeCopy(fileName || \"Converted Presentation\", DriveApp.getRootFolder());\n    const deck \u003d SlidesApp.openById(newFile.getId());\n    const originalSlides \u003d deck.getSlides();\n    const layouts \u003d deck.getLayouts();\n    const START_LAYOUT_INDEX \u003d 11; \n    imagesData.forEach((base64Str, index) \u003d\u003e {\n      const contentType \u003d base64Str.match(/data:(.*);base64/)[1];\n      const data \u003d base64Str.replace(/^data:image\\/.*;base64,/, \"\");\n      const decodedBlob \u003d Utilities.newBlob(Utilities.base64Decode(data), contentType, \"image\" + index + \".jpg\");\n      let targetPage;\n      if (isBackgroundMode) {\n        const layoutIndex \u003d (START_LAYOUT_INDEX + index) % layouts.length;\n        const targetLayout \u003d layouts[layoutIndex];\n        const slide \u003d deck.appendSlide(targetLayout);\n        slide.getPageElements().forEach(e \u003d\u003e e.remove());\n        targetPage \u003d targetLayout; \n      } else {\n        const slide \u003d deck.appendSlide(SlidesApp.PredefinedLayout.BLANK);\n        slide.getPageElements().forEach(e \u003d\u003e e.remove());\n        targetPage \u003d slide;\n      }\n      const image \u003d targetPage.insertImage(decodedBlob);\n      if (isBackgroundMode) {\n        image.sendToBack();\n      }\n      if (isStretchMode) {\n        image.setLeft(0);\n        image.setTop(0);\n        image.setWidth(deck.getPageWidth());\n        image.setHeight(deck.getPageHeight());\n      } else {\n        mt_alignImageToSlide(deck, image);\n      }\n    });\n    originalSlides.forEach(slide \u003d\u003e slide.remove());\n    const fileUrl \u003d deck.getUrl();\n    mt_updateHistory(newFile.getName(), fileUrl);\n    return fileUrl;\n  } catch (e) {\n    throw new Error(\"スライド作成エラー: \" + e.message);\n  }\n}\nfunction mt_updateHistory(name, url) {\n  const props \u003d PropertiesService.getUserProperties();\n  let history \u003d [];\n  const json \u003d props.getProperty(\u0027MT_HISTORY_LOG\u0027);\n  if (json) {\n    try {\n      history \u003d JSON.parse(json);\n    } catch (e) {\n      history \u003d [];\n    }\n  }\n  const newItem \u003d {\n    name: name,\n    url: url,\n    timestamp: new Date().toLocaleString(\u0027ja-JP\u0027, { timeZone: \u0027Asia/Tokyo\u0027 })\n  };\n  history.unshift(newItem);\n  if (history.length \u003e 10) {\n    history \u003d history.slice(0, 10);\n  }\n  props.setProperty(\u0027MT_HISTORY_LOG\u0027, JSON.stringify(history));\n}\nfunction mt_alignImageToSlide(presentation, image) {\n  const slideWidth \u003d presentation.getPageWidth();\n  const slideHeight \u003d presentation.getPageHeight();\n  const imgWidth \u003d image.getWidth();\n  const imgHeight \u003d image.getHeight();\n  const ratio \u003d Math.min(slideWidth / imgWidth, slideHeight / imgHeight);\n  image.setWidth(imgWidth * ratio);\n  image.setHeight(imgHeight * ratio);\n  image.setLeft((slideWidth - (imgWidth * ratio)) / 2);\n  image.setTop((slideHeight - (imgHeight * ratio)) / 2);\n}"},{"id":"7871d6f1-76db-45b4-aa73-455404e8056b","name":"無題","type":"html","source":"\u003c!--\n@license\nCopyright 2025 majin (https://note.com/majin_108)\n\n【まじん式 ご利用条件 (メンバー・法人版)】\n\n本ファイル (HTML, CSS, クライアントサイドJavaScript) は、以下の「まじん式 ご利用条件」に基づき提供されます。\n利用条件の詳細は、noteの記事 ( https://note.com/majin_108 ) にある\n「まじん式 v4」関連記事の最新版をご確認ください。\n\n1. コードの商用利用: 【不可】\n    コードの全部または一部を有償無償にかかわらずサービスに組み込むなどの商用利用は一切禁止です。\n\n2. コードの改変: 【可】\n    ご自身の利用のためのカスタマイズは可能です。\n\n3. 改変後の配布: 【法人ライセンスで社内のみ可】\n    法人ライセンスでは、ライセンスを購入した社内でのみ改変後の配布が可能です。\n    メンバーシップライセンスでは改変後の配布はできません。\n\n【サードパーティライセンス】\n本UIは、以下のサードパーティ製リソースに依存しています。\nこれらは、本利用条件とは別に、それぞれのオリジナルライセンスに基づき提供されます。\n\n    - Google Fonts (Inter, Noto Sans JP, Roboto): Apache License 2.0 / SIL Open Font License\n    - pako.js (via CDN): MIT License\n    - UPNG.js (via CDN): MIT License\n\n【免責事項】\n本ソフトウェアを使用したことによって生じたいかなる損害についても、作者は一切の責任を負いません。\n--\u003e\n\n\u003c!DOCTYPE html\u003e\n\u003chtml lang\u003d\"ja\"\u003e\n\u003chead\u003e\n  \u003cmeta charset\u003d\"utf-8\"\u003e\n  \u003cmeta name\u003d\"viewport\" content\u003d\"width\u003ddevice-width, initial-scale\u003d1.0\"\u003e\n  \u003ctitle\u003eGoogle Slide Generator\u003c/title\u003e\n  \u003cbase target\u003d\"_top\"\u003e\n  \u003clink rel\u003d\"preconnect\" href\u003d\"https://fonts.googleapis.com\"\u003e\n  \u003clink rel\u003d\"preconnect\" href\u003d\"https://fonts.gstatic.com\" crossorigin\u003e\n  \u003clink href\u003d\"https://fonts.googleapis.com/css2?family\u003dInter:wght@400;500;600;700\u0026family\u003dNoto+Sans+JP:wght@400;500;700\u0026family\u003dRoboto:wght@900\u0026display\u003dswap\" rel\u003d\"stylesheet\"\u003e\n  \u003cscript src\u003d\"https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js\"\u003e\u003c/script\u003e\n  \u003cscript src\u003d\"https://cdn.jsdelivr.net/npm/upng-js@2.1.0/UPNG.min.js\"\u003e\u003c/script\u003e\n  \u003cscript src\u003d\"https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js\"\u003e\u003c/script\u003e\n  \u003cscript\u003e\n    pdfjsLib.GlobalWorkerOptions.workerSrc \u003d \u0027https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js\u0027;\n  \u003c/script\u003e\n  \u003clink href\u003d\"https://fonts.googleapis.com/icon?family\u003dMaterial+Icons+Outlined\" rel\u003d\"stylesheet\"\u003e\n  \u003cstyle\u003e\n@keyframes revealSlide {\n  0% {\n    backdrop-filter: blur(20px) grayscale(100%);\n    -webkit-backdrop-filter: blur(20px) grayscale(100%);\nbackground-color: rgba(50, 50, 50, 0.3);\n    opacity: 1; \n}\n96.7% {\n    backdrop-filter: blur(0px) grayscale(0%);\n    -webkit-backdrop-filter: blur(0px) grayscale(0%);\nbackground-color: rgba(200, 200, 200, 0.1);\n    opacity: 1; \n}\n100% {\n    backdrop-filter: blur(0px) grayscale(0%);\n    -webkit-backdrop-filter: blur(0px) grayscale(0%);\nbackground-color: rgba(200, 200, 200, 0);\n    opacity: 0; \n}\n}\n#previewOverlay {\n  display: none; \nposition: absolute;\n  top: 0;\n  left: 0;\nwidth: 100%;\n  height: 100%;\n  z-index: 20;\ncursor: wait;\n  backdrop-filter: blur(20px) grayscale(100%);\n  -webkit-backdrop-filter: blur(20px) grayscale(100%);\n  background-color: rgba(50, 50, 50, 0.3);\n  opacity: 0;\ntransition: opacity 3s ease-out; \n  animation: none;\n}\n#previewOverlay.loading {\n  display: block !important; \n  opacity: 1;\n  animation: revealSlide 90s linear 1 forwards; \n}\n    :root {\n      --primary-color: #4285F4; \n      --primary-color-dark: #3871CF; \n      --secondary-color: #6B7280;\n      --secondary-color-dark: #4B5563;\n      --danger-color: #EF4444;\n      --danger-color-dark: #B91C1C;\n      --success-color: #10B981;\n      --text-large-font: #333333; \n      --text-small-font: #1F2937;\n      --text-secondary: #4B5563;\n      --text-light: #9CA3AF;\n      --text-on-primary: #FFFFFF;\n      --card-header-bg: #F9FAFB;\n      --bg-body: #F9FAFB;\n      --bg-surface: #FFFFFF;\n      --border-color: #D1D5DB;\n      --border-focus-color: var(--primary-color); \n      --toast-success-bg: #F0FDF4; --toast-success-text: #15803D; --toast-success-border: #A7F3D0;\n      --toast-error-bg: #FEF2F2; --toast-error-text: #B91C1C; \n      --toast-error-border: #FECACA;\n      --font-family-base: \u0027Inter\u0027, \u0027Noto Sans JP\u0027, sans-serif;\n      --font-family-code: \u0027Fira Code\u0027, \u0027Consolas\u0027, monospace;\n      --radius-sm: 4px;\n      --radius-md: 8px;\n      --radius-lg: 12px; \n      --shadow-sm: 0 1px 2px rgba(0, 0, 0, 0.05);\n      --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06); \n    }\n    *, *::before, *::after { box-sizing: border-box; \n    }\n    body {\n      font-family: var(--font-family-base);\n      margin: 0; \n      padding: 0;\n      background-color: var(--bg-body);\n      color: var(--text-small-font);\n      -webkit-font-smoothing: antialiased;\n      -moz-osx-font-smoothing: grayscale; \n      display: flex;\n      flex-direction: column;\n      height: 100vh;\n      overflow: hidden; \n    }\n    .container {\n      width: 100%; \n      margin: 0 auto;\n      padding: 1.5rem; \n      flex-grow: 1; \n    }\n    .main-grid {\n      display: grid; \n      grid-template-columns: 1.5fr 1fr;\n      gap: 2rem;\n      align-items: start;\n    }\n    .left-column {\n      display: flex; \n      flex-direction: column;\n      gap: 2rem;\n    }\n    .card {\n      background: var(--bg-surface); \n      border-radius: var(--radius-lg);\n      box-shadow: var(--shadow-md);\n      overflow: hidden;\n      border: 1px solid var(--border-color); \n    }\n    .card-header {\n      font-size: 1.25rem;\n      font-weight: 600;\n      padding: 1rem 1.5rem;\n      background-color: var(--card-header-bg); \n      color: var(--text-large-font);\n      border-bottom: 1px solid var(--border-color);\n      margin: 0;\n      border-radius: var(--radius-lg) var(--radius-lg) 0 0; \n    }\n    .card-body {\n      padding: 1.5rem; \n    }\n    textarea#slideDataInput {\n      width: 100%;\n      height: 250px;\n      visibility: hidden;\n      transition: visibility 0.1s ease-in;\n      font-family: var(--font-family-code);\n      font-size: 0.875rem;\n      line-height: 1.6; \n      border: 1px solid var(--border-color);\n      border-radius: var(--radius-md);\n      padding: 1rem;\n      background-color: var(--bg-surface); \n      transition: border-color 0.2s, box-shadow 0.2s;\n      resize: vertical;\n    }\n    textarea#slideDataInput:focus {\n      outline: none; \n      border-color: var(--border-focus-color);\n      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2); \n    }\n    .form-grid {\n      display: grid;\n      grid-template-columns: 1fr 1fr; \n      gap: 1.25rem;\n      align-items: end;\n    }\n    .grid-col-full {\n        grid-column: 1 / -1; \n    }\n    .form-group label {\n      display: block;\n      font-weight: 500; \n      font-size: 0.875rem;\n      color: var(--text-secondary);\n      margin-bottom: 0.5rem;\n    }\n    .form-control {\n      width: 100%; \n      padding: 0.75rem 1rem;\n      border: 1px solid var(--border-color);\n      border-radius: var(--radius-md);\n      font-size: 0.875rem;\n      transition: all 0.2s ease;\n      background: var(--bg-surface); \n    }\n    .form-control:focus {\n      outline: none;\n      border-color: var(--border-focus-color); \n      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2);\n    }\n    .input-group {\n      display: flex; \n      gap: 0.5rem;\n      align-items: center;\n    }\n    .input-group .form-control {\n      flex: 1; \n    }\n    input[type\u003d\"color\"] {\n      -webkit-appearance: none;\n      -moz-appearance: none; \n      appearance: none;\n      width: 44px;\n      height: 44px;\n      padding: 0;\n      border: 1px solid var(--border-color);\n      border-radius: var(--radius-md);\n      cursor: pointer; \n    }\n    input[type\u003d\"color\"]::-webkit-color-swatch-wrapper { padding: 0; }\n    input[type\u003d\"color\"]::-webkit-color-swatch { border: none; border-radius: var(--radius-md); \n    }\n    .checkbox-wrapper {\n      display: flex;\n      align-items: center;\n      gap: 0.75rem;\n      padding: 0.5rem 0; \n    }\n    .checkbox-wrapper label {\n      margin-bottom: 0;\n      color: var(--text-primary);\n      font-weight: 400; \n    }\n    input[type\u003d\"checkbox\"] {\n      width: 18px;\n      height: 18px;\n      accent-color: var(--primary-color); \n    }\n    .btn {\n      display: inline-flex; \n      align-items: center;\n      justify-content: center;\n      width: 100%;\n      padding: 0.875rem 1rem;\n      font-size: 1rem;\n      font-weight: 600;\n      border: none;\n      border-radius: var(--radius-md);\n      cursor: pointer; \n      transition: all 0.2s ease;\n      text-transform: none;\n      letter-spacing: 0.025em;\n    }\n    .btn:focus, .btn:focus-visible {\n      outline: none; \n      box-shadow: 0 0 0 3px rgba(59, 130, 246, 0.2); \n    }\n    a.btn {\n      text-decoration: none; \n    }\n    .btn:disabled {\n      opacity: 0.6;\n      cursor: not-allowed; \n    }\n    .btn-primary {\n      background-color: var(--primary-color);\n      color: var(--text-on-primary);\n      box-shadow: var(--shadow-sm); \n    }\n    .btn-primary:hover:not(:disabled) {\n      background-color: var(--primary-color-dark);\n      transform: translateY(-1px); \n    }\n    .btn-preset {\n      display: inline-flex;\n      align-items: center;\n      justify-content: center;\n      border: none; \n      cursor: pointer;\n      transition: all 0.2s ease;\n      font-weight: 600;\n      letter-spacing: 0.025em; \n      text-transform: none;\n      padding: 0.5rem 1rem;\n      font-size: 0.875rem;\n      background-color: var(--primary-color);\n      color: var(--text-on-primary);\n      border-radius: var(--radius-sm);\n      white-space: nowrap; \n    }\n    .btn-preset:hover:not(:disabled) { background-color: var(--primary-color-dark); }\n    .btn-secondary {\n      display: inline-flex; \n      align-items: center;\n      justify-content: center;\n      border: none; \n      cursor: pointer; \n      transition: all 0.2s ease;\n      font-weight: 600;\n      letter-spacing: 0.025em;\n      text-transform: none;\n      padding: 0.5rem 0.75rem;\n      font-size: 0.75rem;\n      background-color: var(--secondary-color);\n      color: var(--text-on-primary); \n      border-radius: var(--radius-sm);\n      white-space: nowrap;\n    }\n    .btn-secondary:hover:not(:disabled) { background-color: var(--secondary-color-dark); \n    }\n    .button-group {\n      margin-top: 1.5rem;\n      display: flex;\n      gap: 1rem;\n      flex-wrap: wrap; \n      align-items: center;\n    }\n    .collapsible-section { margin: 1.25rem 0; \n    }\n    .collapsible-header {\n      background: var(--bg-surface);\n      color: var(--text-secondary);\n      padding: 0.75rem 1rem;\n      border-radius: var(--radius-md); \n      cursor: pointer;\n      font-weight: 600;\n      font-size: 1rem;\n      border: 1px solid var(--border-color);\n      transition: all 0.2s ease;\n      display: flex;\n      justify-content: space-between;\n      align-items: center; \n    }\n    .collapsible-header:hover, .collapsible-header.active {\n      background: #EFF6FF;\n      color: var(--primary-color); \n    }\n    .collapsible-content {\n      display: none;\n      padding: 1.25rem;\n      background: var(--bg-surface); \n      border: 1px solid var(--border-color);\n      border-top: none;\n      border-radius: 0 0 var(--radius-md) var(--radius-md);\n    }\n    .collapsible-content.active { display: block; \n    }\n    .collapsible-icon { transition: transform 0.2s ease; }\n    .collapsible-header.active .collapsible-icon { transform: rotate(180deg); \n    }\n    .note {\n        margin-bottom: 1rem; \n        padding: 0.75rem 1rem;\n        border-radius: var(--radius-md);\n        font-size: 0.875rem;\n        line-height: 1.5;\n        border: 1px solid transparent; \n    }\n    .note-info { background-color: #EFF6FF; border-color: #BFDBFE; color: #1E3A8A; }\n    .note-warning { background-color: #FFFBEB; \n      border-color: #FDE68A; color: #92400E; display: none; margin-top: 0.5rem; }\n    .preset-management {\n      margin-bottom: 1.5rem; \n      padding: 1rem;\n      background: #F9FAFB;\n      border-radius: var(--radius-md);\n      border: 1px solid var(--border-color); \n    }\n    .preset-controls label {\n      font-weight: 600;\n      margin-bottom: 0.5rem;\n      color: var(--text-small-font);\n      font-size: 0.875rem; \n    }\n    .preset-control-row { display: flex; gap: 0.5rem; align-items: center; \n    }\n    .preset-select {\n      flex: 1;\n      padding: 0.5rem 0.75rem;\n      border: 1px solid var(--border-color); \n      border-radius: var(--radius-sm);\n      font-size: 0.875rem;\n      background: var(--bg-surface);\n    }\n    #gradient-options { display: none; \n      border-top: 1px solid var(--border-color); margin-top: 1.25rem; padding-top: 1.25rem; }\n    .gradient-preview-section { margin-top: 1.25rem; \n    }\n    .gradient-preview-box {\n      height: 50px;\n      border-radius: var(--radius-md);\n      display: flex;\n      align-items: center; \n      justify-content: center;\n      color: white;\n      font-weight: 600;\n      margin-top: 0.5rem;\n      border: 1px solid var(--border-color);\n      transition: all 0.3s ease; \n    }\n    .json-validation {\n      margin-bottom: 1rem; \n      padding: 1rem;\n      border-radius: var(--radius-md);\n      background: #F9FAFB;\n      border: 1px solid var(--border-color); \n    }\n    .validation-status {\n      display: flex;\n      align-items: center;\n      gap: 0.5rem;\n      font-size: 0.875rem; \n      font-weight: 500;\n      justify-content: flex-start;\n      width: 100%;\n    }\n    .validation-details {\n      margin-top: 0.75rem; \n      font-size: 0.8125rem;\n      line-height: 1.4;\n      padding: 0.5rem 0.75rem;\n      border-radius: var(--radius-sm);\n      display: none;\n    }\n    .validation-error { background: #FEF2F2; \n      border: 1px solid #FECACA; color: #B91C1C; }\n    .validation-warning { background: #FFFBEB; border: 1px solid #FDE68A; color: #92400E; \n    }\n    .toast-container {\n      position: fixed; \n      bottom: 1.5rem;\n      right: 1.5rem;\n      z-index: 9999;\n      display: flex;\n      flex-direction: column;\n      gap: 0.75rem;\n      align-items: flex-end; \n    }\n    .toast {\n      padding: 1rem 1.5rem;\n      border-radius: var(--radius-md);\n      box-shadow: var(--shadow-md);\n      font-weight: 500; \n      border: 1px solid;\n      opacity: 0;\n      animation: toast-in 0.3s ease-out forwards, toast-out 0.5s ease-in 3.5s forwards; \n    }\n    .toast-success { background-color: var(--toast-success-bg); color: var(--toast-success-text); border-color: var(--toast-success-border); \n    }\n    .toast-error   { background-color: var(--toast-error-bg); color: var(--toast-error-text); border-color: var(--toast-error-border); \n    }\n    @keyframes toast-in {\n      from { transform: translateX(100%); \n      opacity: 0; }\n      to { transform: translateX(0); opacity: 1; \n      }\n    }\n    @keyframes toast-out {\n      from { opacity: 1; \n      }\n      to { opacity: 0; \n      }\n    }\n    .modal-overlay {\n      position: fixed; \n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      background-color: rgba(0, 0, 0, 0.6);\n      display: flex;\n      justify-content: center;\n      align-items: center; \n      z-index: 1000;\n    }\n    .modal-content {\n      width: 90%;\n      max-width: 90vh;\n      max-height: 90vh; \n      overflow-y: auto;\n    }\n    .drop-zone {\n      border: 2px dashed var(--border-color);\n      border-radius: var(--radius-md); \n      padding: 2rem;\n      text-align: center;\n      color: var(--text-light);\n      cursor: pointer;\n      transition: background-color 0.2s, border-color 0.2s;\n      position: relative; \n    }\n    .drop-zone.drag-over {\n      background-color: #EFF6FF;\n      border-color: var(--primary-color); \n    }\n    .image-preview {\n      max-width: 100%;\n      max-height: 200px;\n      margin: 0 auto 1rem; \n      display: block;\n    }\n    @keyframes waveMotion {\n      0% {\n        background-position: -200px 0; \n      }\n      100% {\n        background-position: calc(100% + 200px) 0; \n      }\n    }\n    button#generateBtn:disabled,\n    button#updatePageBtn:disabled { \n      justify-content: center !important; \n      background-image: linear-gradient(\n        90deg, \n        transparent 0%,\n        rgba(255, 255, 255, 0.3) 50%, \n        transparent 100%\n      ); \n      background-size: 200px 100%; \n      background-repeat: no-repeat; \n      animation: waveMotion 1.5s infinite linear; \n    }\n    @media (max-width: 768px) {\n      .container { padding: 1.5rem 1rem; \n      }\n      .card-body, .card-header { padding: 1.25rem; \n      }\n    }\n    @media (max-width: 576px) {\n      .toast-container {\n        left: 1rem; \n        right: 1rem;\n        bottom: 1rem;\n        align-items: stretch;\n      }\n    }\n    #splitter {\n      transition: background-color 0.2s ease; \n    }\n    #splitter:hover, #splitter.dragging {\n      background: var(--secondary-color) !important; \n    }\n    #left-pane.vertical-layout .main-grid {\n      grid-template-columns: 1fr !important;\n    }\n    #left-pane.narrow-layout .main-grid {\n      grid-template-columns: 1fr !important; \n    }\n    #left-pane.narrow-layout .card {\n      background: transparent; \n      box-shadow: none;        \n      border: none;            \n    }\n    #left-pane.narrow-layout .card-header {\n      display: none !important; \n    }\n    #left-pane.narrow-layout .left-column {\n      gap: 0.5rem; \n    }\n    #left-pane.narrow-layout .card-body {\n      padding: 0.75rem 0; \n    }\n    #left-pane.narrow-layout .card-header + .card-body {\n      padding-top: 0.25rem;\n      padding-bottom: 0.25rem;\n    }\n    #left-pane.narrow-layout .editor-section .card-body {\n       padding-top: 0.5rem;\n       padding-bottom: 0rem; \n    }\n    #left-pane.narrow-layout .json-validation {\n       margin-bottom: 0.75rem; \n       padding: 0.75rem;       \n    }\n    #left-pane.narrow-layout .settings-section .card-body {\n      padding-top: 0.25rem; \n      padding-bottom: 0;\n    }\n    #left-pane.narrow-layout .preset-management {\n      margin-bottom: 0.75rem; \n      padding: 0.75rem;       \n    }\n    #left-pane.narrow-layout .form-grid {\n      gap: 0.75rem; \n    }\n    #left-pane.narrow-layout .collapsible-section {\n      margin: 0.75rem 0; \n    }\n    #left-pane.narrow-layout .collapsible-header {\n      padding: 0.5rem 0.75rem; \n    }\n    #left-pane.narrow-layout .collapsible-content {\n      padding: 0.75rem; \n    }\n    #left-pane.narrow-layout .note {\n      padding: 0.5rem 0.75rem; \n      margin-bottom: 0.75rem; \n    }\n    #left-pane.narrow-layout .button-group {\n      margin-top: 1rem; \n    }\n    #left-pane.narrow-layout .preset-management {\n      background: transparent;\n      border: none;\n      padding: 0 0 0.75rem 0; \n    }\n    #left-pane.narrow-layout .json-validation {\n      background: transparent;\n      border: none;\n      padding: 0 0 0.75rem 0; \n    }\n    #left-pane.narrow-layout #editorFormArea .form-group-grid {\n      flex-direction: column !important; \n      align-items: stretch !important; \n      gap: 0.25rem !important; \n      padding: 0.5rem 0 !important; \n    }\n    #left-pane.narrow-layout #editorFormArea .editor-form-label {\n      width: auto !important; \n      text-align: left !important; \n      margin-top: 0 !important; \n      padding-right: 0 !important; \n      white-space: normal !important; \n      margin-bottom: 0.25rem; \n    }\n    #left-pane.narrow-layout #editorFormArea .field-wrapper {\n      gap: 0.75rem !important; \n    }\n    .slide-suffix {\n      display: inline; \n    }\n    #left-pane.narrow-layout .validation-status .slide-suffix {\n      display: none; \n    }\n    .nav-text-short {\n      display: none;\n    }\n    .nav-text-full {\n      display: inline;\n    }\n    #left-pane.narrow-layout .nav-text-short {\n      display: inline;\n    }\n    #left-pane.narrow-layout .nav-text-full {\n      display: none;\n    }\n    #left-pane.narrow-layout .settings-section .collapsible-section {\n      margin: 1.5rem 0 0.75rem 0; \n    }\n    textarea#slideDataInput.height-adjusted {\n      visibility: visible;\n    }\n    #left-pane.narrow-layout .container {\n      padding-left: 0.75rem !important;  \n      padding-right: 0.75rem !important; \n      padding-top: 0.75rem !important;\n      padding-bottom: 0.75rem !important;\n    }\n    .panel-close-btn {\n      position: absolute;\n      top: 0.25rem; \n      right: 0.25rem; \n      width: 24px; \n      height: 24px; \n      background-color: transparent;\n      border: none;\n      border-radius: 50%; \n      color: var(--text-light); \n      font-size: 1.2rem; \n      font-weight: 400; \n      line-height: 22px; \n      text-align: center;\n      cursor: pointer;\n      z-index: 20;\n      transition: all 0.2s ease;\n      user-select: none;\n      display: none;\n    }\n    .panel-close-btn:hover {\n      background-color: rgba(107, 114, 128, 0.1); \n      color: var(--text-secondary); \n    }\n    .preview-header {\n      background-color: var(--primary-color-dark); \n      color: var(--text-on-primary, #FFFFFF);\n      padding: 0.25rem 3rem 0.25rem 1rem; \n      font-size: 0.875rem;\n      font-weight: 500;\n      text-align: center;\n      position: relative;\n      transition: background-color 0.2s ease;\n      flex-shrink: 0; \n      user-select: none;\n    }\n    .preview-header:hover {\n      background-color: var(--primary-color);\n    }\n    .preview-header-close {\n      position: absolute;\n      top: 50%;\n      right: 0.5rem;\n      transform: translateY(-50%);\n      background: none;\n      border: none;\n      color: var(--text-on-primary, #FFFFFF);\n      font-size: 1.5rem;\n      font-weight: 400;\n      line-height: 1;\n      padding: 0.25rem 0.5rem;\n      cursor: pointer;\n      opacity: 0.7;\n      transition: opacity 0.2s ease;\n    }\n    .preview-header-close:hover {\n      opacity: 1;\n    }\n    #left-pane.narrow-layout {\n      overflow-x: hidden !important; \n      overflow-y: scroll !important; \n      scrollbar-width: none; \n    }\n    #left-pane.narrow-layout::-webkit-scrollbar {\n      display: none; \n    }\n    #toggleFullscreenBtn,\n    #showPreviewBtnLeft {\n      width: 30px;\n      height: 30px;\n      border-radius: 50%; \n      border: none; \n      background-color: rgba(var(--primary-color-rgb, 66, 133, 244), 0.8); \n      color: var(--text-on-primary, #FFFFFF); \n      box-shadow: var(--shadow-md); \n      backdrop-filter: blur(4px); \n      -webkit-backdrop-filter: blur(4px);\n      font-size: 1.2em;\n      display: flex;\n      align-items: center;\n      justify-content: center;\n      cursor: pointer;\n      transition: background-color 0.2s ease, color 0.2s ease;\n    }\n    #toggleFullscreenBtn:hover,\n    #showPreviewBtnLeft:hover {\n      background-color: rgba(var(--primary-color-rgb, 66, 133, 244), 1.0) !important; \n      color: var(--text-on-primary) !important;\n    }\n    #left-pane.narrow-layout #closeSettingsBtn {\n      display: none !important;\n    }\n    #left-pane.narrow-layout #showLastSlideBtn {\n      display: none !important;\n    }\n    #left-pane.narrow-layout #buttonGroup {\n      display: flex !important;\n      flex-direction: row !important; \n      gap: 0.5rem !important; \n    }\n    #left-pane.narrow-layout #buttonGroup .btn {\n      width: auto !important; \n      flex-grow: 1; \n      padding-left: 0.5rem; \n      padding-right: 0.5rem;\n    }\n    #left-pane.narrow-layout textarea#slideDataInput {\n      overflow-y: scroll !important; \n      scrollbar-width: none; \n    }\n    #left-pane.narrow-layout textarea#slideDataInput::-webkit-scrollbar {\n      display: none; \n    }\n.purchase-select-wrapper {\n  position: relative;\n  flex-grow: 0;\n  width: auto; \n}\n.purchase-select {\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  appearance: none;\n  text-align-last: center;\n  border: none; \n  cursor: pointer; \n  transition: all 0.2s ease;\n  font-weight: 600;\n  letter-spacing: 0.025em;\n  text-transform: none; \n  padding: 0.5rem 0.5rem;\n  font-size: 0.8rem;\n  background-color: var(--secondary-color);\n  color: var(--text-on-primary); \n  border-radius: var(--radius-sm);\n  white-space: nowrap;\n}\n.purchase-select:hover:not(:disabled) { \n  background-color: var(--secondary-color-dark);\n}\n.purchase-select-wrapper::after {\n  display: none; \n}\n#svgEditorCanvas svg {\n  background-color: #ffffff;\n  box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);\n  max-width: 100%;\n  max-height: 100%;\n  cursor: pointer;\n}\n.svg-editor-selected {\n  cursor: move;\n}\n#svgEditorCanvas svg *:hover:not(svg) {\n  outline: 1px solid rgba(66, 133, 244, 0.5);\n}\n#selectionRect {\n  fill: rgba(66, 133, 244, 0.1);\n  stroke: rgba(66, 133, 244, 0.5);\n  stroke-width: 1;\n  stroke-dasharray: 3 3;\n  pointer-events: none; \n  display: none;\n}\n#svgEditorCanvas {\n  user-select: none;          \n  -webkit-user-select: none;  \n  -moz-user-select: none;     \n}\n.history-item {\n  padding: 0.75rem 1rem;\n  border-bottom: 1px solid var(--border-color);\n  cursor: pointer;\n  transition: background-color 0.2s;\n  background: #fff;\n}\n.history-item:last-child {\n  border-bottom: none;\n}\n.history-item:hover {\n  background-color: #EFF6FF; \n}\n.history-item-title {\n  font-weight: 600;\n  font-size: 0.9rem;\n  color: var(--text-primary);\n  margin-bottom: 0.25rem;\n  white-space: nowrap;\n  overflow: hidden;\n  text-overflow: ellipsis;\n}\n.history-item-meta {\n  font-size: 0.75rem;\n  color: var(--text-secondary);\n  display: flex;\n  justify-content: space-between;\n  align-items: center;\n}\n.history-tag {\n  display: inline-block;\n  padding: 2px 6px;\n  border-radius: 4px;\n  font-size: 0.7rem;\n  background: #eee;\n  color: #555;\n  margin-right: 0.5rem;\n}\n    #buttonGroup {\n      display: flex !important;\n      flex-direction: row !important;   \n      flex-wrap: nowrap !important;     \n      gap: 0.5rem !important;           \n      width: 100%;                      \n      align-items: center;\n    }\n    #buttonGroup .btn {\n      width: auto !important;           \n      flex: 1 1 0;                      \n      white-space: nowrap;              \n      padding-left: 0.25rem !important; \n      padding-right: 0.25rem !important;\n      margin: 0 !important;\n      min-width: 0;                     \n      justify-content: center;          \n    }\n    #buttonGroup .btn .btn-text {\n      overflow: hidden;\n      text-overflow: ellipsis;\n    }\n    #appSwitcherBtn {\n      position: fixed;\n      bottom: 1.5rem;\n      left: 1.5rem;\n      z-index: 9999; \n      display: inline-flex;\n      align-items: center;\n      justify-content: center;\n      background-color: #333; \n      color: #fff;\n      border: 1px solid rgba(255,255,255,0.2);\n      border-radius: 30px;\n      padding: 0.5rem 1.2rem;\n      font-family: var(--font-family-base);\n      font-size: 0.85rem;\n      font-weight: 600;\n      cursor: pointer;\n      box-shadow: 0 4px 6px rgba(0,0,0,0.2);\n      transition: all 0.3s ease;\n    }\n    #appSwitcherBtn:hover {\n      transform: translateY(-2px);\n      box-shadow: 0 6px 12px rgba(0,0,0,0.3);\n    }\n    #appSwitcherBtn.active-mode {\n      background-color: var(--primary-color); \n      border-color: transparent;\n    }\n    #majinToolsContainer {\n      display: none; \n      position: fixed;\n      top: 0;\n      left: 0;\n      width: 100%;\n      height: 100%;\n      background-color: #f8f9fa; \n      z-index: 9000; \n      overflow-y: auto;\n      padding: 40px 20px;\n      --mt-primary: #1a73e8;\n      --mt-text: #202124;\n      --mt-border: #dadce0;\n    }\n    #majinToolsContainer .mt-app-card {\n      background: white;\n      width: 100%;\n      max-width: 580px;\n      border-radius: 8px;\n      box-shadow: 0 1px 2px 0 rgba(60,64,67,0.3), 0 1px 3px 1px rgba(60,64,67,0.15);\n      padding: 30px 40px;\n      text-align: center;\n      margin: 0 auto 24px auto;\n    }\n    #majinToolsContainer h1 { font-size: 24px; font-weight: 400; margin-bottom: 30px; color: var(--mt-text); margin-top: 0; }\n    #majinToolsContainer .drop-zone {\n      border: 2px dashed var(--mt-border);\n      border-radius: 12px;\n      padding: 40px 20px;\n      background-color: #fff;\n      cursor: default;\n      transition: all 0.2s ease;\n      position: relative;\n      outline: none;\n    }\n    #majinToolsContainer .drop-zone:hover, \n    #majinToolsContainer .drop-zone.dragover {\n      background-color: #f8fbff;\n      border-color: var(--mt-primary);\n    }\n    #majinToolsContainer .drop-zone .icon { font-size: 48px; color: #5f6368; margin-bottom: 10px; display: block;}\n    #majinToolsContainer .drop-zone p { margin: 0; color: #5f6368; font-size: 16px; }\n    #majinToolsContainer .browse-btn {\n      color: var(--mt-primary); font-weight: 500; cursor: pointer; padding: 4px 8px; border-radius: 4px;\n    }\n    #majinToolsContainer .browse-btn:hover { background-color: #e8f0fe; text-decoration: underline; }\n    #majinToolsContainer .file-display {\n      display: none; align-items: center; background: #e8f0fe; color: var(--mt-primary);\n      padding: 10px 15px; border-radius: 18px; font-weight: 500; margin-top: 20px;\n      font-size: 14px; justify-content: center; gap: 8px;\n    }\n    #majinToolsContainer .options-area { margin-top: 30px; display: flex; justify-content: center; color: var(--mt-text); }\n    #majinToolsContainer .toggle-switch { display: flex; align-items: center; cursor: pointer; gap: 12px; }\n    #majinToolsContainer .toggle-label { font-size: 14px; }\n    #majinToolsContainer .switch { position: relative; display: inline-block; width: 36px; height: 20px; }\n    #majinToolsContainer .switch input { opacity: 0; width: 0; height: 0; }\n    #majinToolsContainer .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #bdc1c6; transition: .4s; border-radius: 34px; }\n    #majinToolsContainer .slider:before { position: absolute; content: \"\"; height: 16px; width: 16px; left: 2px; bottom: 2px; background-color: white; transition: .4s; border-radius: 50%; box-shadow: 0 1px 3px rgba(0,0,0,0.4); }\n    #majinToolsContainer input:checked + .slider { background-color: var(--mt-primary); }\n    #majinToolsContainer input:checked + .slider:before { transform: translateX(16px); }\n    #majinToolsContainer .mt-action-btn {\n      background-color: var(--mt-primary); color: white; border: none; border-radius: 4px;\n      padding: 10px 24px; font-size: 14px; font-weight: 500; margin-top: 30px;\n      cursor: pointer; width: 100%; height: 40px; transition: box-shadow 0.2s;\n      font-feature-settings: \"tnum\"; font-variant-numeric: tabular-nums; background-image: none;\n    }\n    #majinToolsContainer .mt-action-btn:hover { background-color: #1765cc; box-shadow: 0 1px 2px rgba(60,64,67,0.3); }\n    #majinToolsContainer .mt-action-btn:disabled { cursor: default; box-shadow: none; opacity: 1; }\n    @keyframes mt-wave-seamless-ltr { 0% { background-position: 200% 50%; } 100% { background-position: 0% 50%; } }\n    #majinToolsContainer .mt-action-btn.processing {\n      background-image: linear-gradient(90deg, #1a73e8 0%, #6ab7ff 50%, #1a73e8 100%);\n      background-size: 200% 100%; animation: mt-wave-seamless-ltr 1.5s linear infinite;\n      cursor: wait; background-color: transparent;\n    }\n    #majinToolsContainer .mt-action-btn.completed { background-image: none; background-color: #1a73e8; cursor: pointer; }\n    #majinToolsContainer .status-text { margin-top: 15px; font-size: 13px; color: #5f6368; min-height: 20px; }\n    #majinToolsContainer .success-msg { color: #137333 !important; font-weight: 500; }\n    #majinToolsContainer .error-msg { color: #d93025 !important; }\n    #majinToolsContainer .history-section { width: 100%; max-width: 580px; margin: 10px auto; }\n    #majinToolsContainer .history-header { font-size: 14px; color: #5f6368; margin-bottom: 10px; font-weight: 500; padding-left: 5px; }\n    #majinToolsContainer .history-item { display: flex; justify-content: space-between; align-items: center; background: white; padding: 12px 20px; margin-bottom: 8px; border-radius: 8px; transition: background-color 0.2s; text-decoration: none; color: #5f6368; box-shadow: 0 1px 2px 0 rgba(60,64,67,0.1); }\n    #majinToolsContainer .history-item:hover { background-color: white; border-color: #dadce0; box-shadow: 0 1px 3px 1px rgba(60,64,67,0.15); }\n    #majinToolsContainer .history-name { font-size: 14px; color: var(--mt-primary); font-weight: 500; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; max-width: 70%; display: flex; align-items: center; gap: 8px; }\n    #majinToolsContainer .history-time { font-size: 12px; color: #5f6368; }\n\u003c/style\u003e\n\u003c/head\u003e\n\u003cbody style\u003d\"display: flex; flex-direction: column; height: 100vh; overflow: hidden;\"\u003e\n  \u003cdiv id\u003d\"previewHeader\" class\u003d\"preview-header\" style\u003d\"display: none;\"\u003e\n    \u003cspan id\u003d\"previewHeaderContent\" style\u003d\"cursor: pointer;\"\u003e\n      このライセンスは 一般提供クレジット表示版 です。クリックして利用条件をご確認ください。\n    \u003c/span\u003e\n    \u003cbutton id\u003d\"closePreviewHeaderBtn\" class\u003d\"preview-header-close\" title\u003d\"閉じる\"\u003e\u0026times;\u003c/button\u003e\n  \u003c/div\u003e\n  \u003cdiv id\u003d\"app-layout\" style\u003d\"display: grid; grid-template-columns: 1fr; height: 100%; width: 100%; overflow: hidden;\"\u003e\n    \u003cdiv id\u003d\"slidePreviewContainer\" style\u003d\"display: none; height: 100%; background: var(--bg-surface); position: relative;\"\u003e\u003cdiv id\u003d\"closePreviewBtn\" class\u003d\"panel-close-btn\" title\u003d\"設定画面を最大化\"\u003e×\u003c/div\u003e\n    \u003cdiv id\u003d\"previewOverlay\" style\u003d\"\n        display: none; \n        position: absolute; \n        top: 0; \n        left: 0; \n        width: 100%; \n        height: 100%; \n        background: rgba(200, 200, 200, 0.2); \n        z-index: 20; \n        cursor: wait; \n    \"\u003e\u003c/div\u003e\n    \u003ca id\u003d\"openSlideNewTabBtn\" \n         href\u003d\"#\" \n         target\u003d\"_blank\" \n         rel\u003d\"noopener noreferrer\" \n         style\u003d\"\n            display: none; \n            position: absolute;\n            top: 1rem; \n            left: 50%; \n            transform: translateX(-50%); \n            z-index: 10; \n            padding: 0.5rem 1.25rem; \n            font-size: 0.875rem;\n            font-weight: 600;\n            color: var(--text-on-primary, #FFFFFF); \n            background-color: rgba(var(--primary-color-rgb, 66, 133, 244), 0.8); \n            backdrop-filter: blur(4px); \n            -webkit-backdrop-filter: blur(4px);\n            border: none;\n            border-radius: 9999px; \n            box-shadow: var(--shadow-md); \n            text-decoration: none;\n            transition: all 0.2s ease;\n            white-space: nowrap;\n         \"\n         onmouseover\u003d\"this.style.backgroundColor\u003d\u0027rgba(var(--primary-color-rgb, 66, 133, 244), 1.0)\u0027\"\n         onmouseout\u003d\"this.style.backgroundColor\u003d\u0027rgba(var(--primary-color-rgb, 66, 133, 244), 0.8)\u0027\"\n      \u003e\n        スライドを別タブで表示\n      \u003c/a\u003e\n    \u003ciframe id\u003d\"slidePreviewFrame\" src\u003d\"about:blank\" style\u003d\"width: 100%; height: 100%; border: none;\"\u003e\u003c/iframe\u003e\n    \u003cdiv id\u003d\"fullscreenToggleContainer\" style\u003d\"position: absolute; bottom: 1.5rem; right: 1.5rem; z-index: 10; display: none;\"\u003e\n      \u003cbutton id\u003d\"toggleFullscreenBtn\" class\u003d\"primary-color\" title\u003d\"全画面プレビューの切り替え\"\u003e\n        \u003cspan id\u003d\"fullscreenIcon\"\u003e\u003e\u003c/span\u003e\n      \u003c/button\u003e\n    \u003c/div\u003e\n    \u003c/div\u003e\n    \u003cdiv id\u003d\"splitter\" style\u003d\"display: none; width: 5px; cursor: col-resize; background: #F3F4F6;\"\u003e\u003c/div\u003e\n    \u003cdiv id\u003d\"left-pane\" style\u003d\"display: flex; flex-direction: column; height: 100%;\noverflow-y: auto; position: relative;\"\u003e\u003cdiv id\u003d\"closeSettingsBtn\" class\u003d\"panel-close-btn\" title\u003d\"プレビューを最大化\"\u003e×\u003c/div\u003e\n      \u003cdiv class\u003d\"container\" style\u003d\"padding: 1.5rem; max-width: 100%; flex-grow: 1;\"\u003e\n        \u003cdiv class\u003d\"main-grid\"\u003e\n          \u003cdiv class\u003d\"left-column\"\u003e\n            \u003cdiv class\u003d\"card\"\u003e\n              \u003ch2 class\u003d\"card-header\"\u003eGeminiでスライド構成データの作成\u003c/h2\u003e\n              \u003cdiv class\u003d\"card-body\"\u003e\n                \u003ca id\u003d\"geminiGemButton\" href\u003d\"#\" target\u003d\"_blank\" rel\u003d\"noopener noreferrer\" class\u003d\"btn btn-primary\"\u003e\n                  Geminiを開く\n                \u003c/a\u003e\n                \u003c/div\u003e\n            \u003c/div\u003e\n            \u003cdiv class\u003d\"card editor-section\"\u003e\n              \u003ch2 class\u003d\"card-header\" style\u003d\"display: flex; justify-content: space-between; align-items: center;\"\u003e\n  \u003cspan\u003eスライド構成データの入力\u003c/span\u003e\n  \u003cspan id\u003d\"historyRestoreBtn\" title\u003d\"スライドIDから設定とデータを読み込み\" style\u003d\"cursor: pointer; font-size: 1.2rem; opacity: 0.7; transition: opacity 0.2s;\"\u003e\n    🕒\n  \u003c/span\u003e\n\u003c/h2\u003e\n              \u003cdiv class\u003d\"card-body\"\u003e\n                \u003cdiv id\u003d\"jsonValidation\" class\u003d\"json-validation\" style\u003d\"display: none;\"\u003e\n                  \u003cdiv class\u003d\"validation-status\" id\u003d\"validationStatus\"\u003e\n                    \u003cspan class\u003d\"validation-icon\"\u003e⏳\u003c/span\u003e\n                    \u003cspan class\u003d\"validation-text\"\u003eスライド構成データの貼付け待機中...\u003c/span\u003e\n                  \u003c/div\u003e\n                  \u003cdiv class\u003d\"validation-details\" id\u003d\"validationDetails\"\u003e\u003c/div\u003e\n                \u003c/div\u003e\n                \u003ctextarea id\u003d\"slideDataInput\" placeholder\u003d\u0027ここにGeminiで生成したスライド構成データを貼付け\u0026#13;\u0026#10;（ダブルクリックで貼付けも可能）\u0027\u003e\u003c/textarea\u003e\n                \u003cdiv class\u003d\"button-group\" id\u003d\"buttonGroup\"\u003e\n                    \u003cbutton id\u003d\"showLastSlideBtn\" type\u003d\"button\" class\u003d\"btn btn-primary\" style\u003d\"display: none;\"\u003e\n                      スライドを表示\n                    \u003c/button\u003e\n                    \u003cbutton id\u003d\"updatePageBtn\" type\u003d\"button\" class\u003d\"btn btn-secondary\" style\u003d\"display: none;\"\u003e\n                      \u003cspan class\u003d\"btn-text\"\u003eこのページを更新\u003c/span\u003e\n                      \u003cspan class\u003d\"btn-timer\" style\u003d\"display: none;\nmargin-left: 0.5rem; font-weight: 400; font-size: 0.9em;\"\u003e\u003c/span\u003e\n                    \u003c/button\u003e\n                    \u003cbutton id\u003d\"generateBtn\" type\u003d\"button\" class\u003d\"btn btn-primary\" style\u003d\"display: none;\"\u003e\n                      \u003cspan class\u003d\"btn-text\"\u003eプレゼンテーションを生成\u003c/span\u003e\n                      \u003cspan class\u003d\"btn-timer\" style\u003d\"display: none;\nmargin-left: 0.5rem; font-weight: 400; font-size: 0.9em;\"\u003e\u003c/span\u003e\n                    \u003c/button\u003e\n                \u003c/div\u003e\n              \u003c/div\u003e\n            \u003c/div\u003e\n          \u003c/div\u003e \u003cdiv style\u003d\"display: flex; flex-direction: column;\"\u003e\n            \u003cdiv class\u003d\"card settings-section\"\u003e\n              \u003ch2 class\u003d\"card-header\"\u003eオプション設定\u003c/h2\u003e\n              \u003cdiv class\u003d\"card-body\"\u003e\n                \u003cdiv class\u003d\"preset-management\"\u003e\n                  \u003cdiv class\u003d\"preset-controls\"\u003e\n                    \u003clabel for\u003d\"presetSelect\"\u003e設定プリセット\u003c/label\u003e\n                    \u003cdiv class\u003d\"preset-control-row\"\u003e\n                      \u003cselect id\u003d\"presetSelect\" class\u003d\"preset-select\"\u003e\n                        \u003coption value\u003d\"\"\u003eプリセットを選択...\u003c/option\u003e\n                      \u003c/select\u003e\n                      \u003cbutton id\u003d\"savePreset\" type\u003d\"button\" class\u003d\"btn-preset\"\u003e保存\u003c/button\u003e\n                      \u003cbutton id\u003d\"deletePreset\" type\u003d\"button\" class\u003d\"btn-secondary\" disabled\u003e削除\u003c/button\u003e\n                    \u003c/div\u003e\n                  \u003c/div\u003e\n                \u003c/div\u003e\n                \u003cdiv class\u003d\"form-grid\"\u003e\n                    \u003cdiv class\u003d\"form-group\"\u003e\n                        \u003clabel for\u003d\"primaryColor\"\u003eプライマリカラー\u003c/label\u003e\n                        \u003cdiv class\u003d\"input-group\"\u003e\n                            \u003cinput type\u003d\"color\" id\u003d\"primaryColor\" value\u003d\"#4285F4\"\u003e\n                            \u003cinput type\u003d\"text\" id\u003d\"primaryColorText\" class\u003d\"form-control\" value\u003d\"#4285F4\"\u003e\n                        \u003c/div\u003e\n                    \u003c/div\u003e\n                    \u003cdiv class\u003d\"form-group\"\u003e\n                      \u003clabel for\u003d\"graphColorTheme\"\u003eグラフカラー\u003c/label\u003e\n                      \u003cselect id\u003d\"graphColorTheme\" class\u003d\"form-control\"\u003e\n                        \u003coption value\u003d\"original\"\u003eオリジナル\u003c/option\u003e\n                        \u003coption value\u003d\"primary\" selected\u003eプライマリ\u003c/option\u003e\n                        \u003coption value\u003d\"gemini\"\u003eGemini\u003c/option\u003e\n                      \u003c/select\u003e\n                    \u003c/div\u003e\n                    \u003cdiv class\u003d\"form-group\"\u003e\n                        \u003clabel for\u003d\"footerText\"\u003eフッターテキスト\u003c/label\u003e\n                        \u003cinput type\u003d\"text\" id\u003d\"footerText\" class\u003d\"form-control\" value\u003d\"© Google Inc.\"\u003e\n                    \u003c/div\u003e\n                    \u003cdiv class\u003d\"form-group\" style\u003d\"display: flex; flex-direction: column; justify-content: flex-end;\"\u003e\n                        \u003cdiv class\u003d\"checkbox-wrapper\" style\u003d\"padding-top: 0; padding-bottom: 0; height: 44px; align-items: center;\"\u003e\n                            \u003cinput type\u003d\"checkbox\" id\u003d\"showPageNumber\" checked\u003e\n                            \u003clabel for\u003d\"showPageNumber\"\u003eページ番号を表示\u003c/label\u003e\n                        \u003c/div\u003e\n                    \u003c/div\u003e\n                    \u003cdiv class\u003d\"form-group grid-col-full\"\u003e\n                        \u003clabel for\u003d\"driveFolderUrl\"\u003e保存先ドライブフォルダURL\u003c/label\u003e\n                        \u003cdiv class\u003d\"input-group\"\u003e\n                            \u003cinput type\u003d\"text\" id\u003d\"driveFolderUrl\" class\u003d\"form-control\" value\u003d\"https://drive.google.com/drive/my-drive\"\u003e\n                            \u003cbutton id\u003d\"openFolderBtn\" type\u003d\"button\" class\u003d\"btn-secondary\"\u003e開く\u003c/button\u003e\n                        \u003c/div\u003e\n                    \u003c/div\u003e\n                \u003c/div\u003e\n                \u003cdiv class\u003d\"collapsible-section\"\u003e\n                  \u003cdiv class\u003d\"collapsible-header\"\u003e\n                    \u003cspan\u003e表示設定\u003c/span\u003e\n                    \u003cspan class\u003d\"collapsible-icon\"\u003e▼\u003c/span\u003e\n                  \u003c/div\u003e\n                  \u003cdiv class\u003d\"collapsible-content\"\u003e\n                      \u003clabel for\u003d\"fontFamily\"\u003eフォント\u003c/label\u003e\n                      \u003cselect id\u003d\"fontFamily\" class\u003d\"form-control\"\u003e\n                        \u003coption value\u003d\"Noto Sans JP\" selected\u003eNoto Sans JP\u003c/option\u003e\n                        \u003coption value\u003d\"Arial\"\u003eArial\u003c/option\u003e\n                        \u003coption value\u003d\"M PLUS 1p\"\u003eM PLUS 1p\u003c/option\u003e\n                        \u003coption value\u003d\"Noto Serif JP\"\u003eNoto Serif JP\u003c/option\u003e\n                      \u003c/select\u003e\n                      \u003cdiv class\u003d\"form-grid\" style\u003d\"margin-top: 1rem;\"\u003e\n                          \u003cdiv class\u003d\"form-group\"\u003e\n                            \u003clabel for\u003d\"largeFontColor\"\u003e大フォント\u003c/label\u003e \n                            \u003cdiv class\u003d\"input-group\"\u003e\n                              \u003cinput type\u003d\"color\" id\u003d\"largeFontColor\" value\u003d\"#333333\"\u003e\n                              \u003cinput type\u003d\"text\" id\u003d\"largeFontColorText\" class\u003d\"form-control\" value\u003d\"#333333\"\u003e\n                            \u003c/div\u003e\n                          \u003c/div\u003e\n                          \u003cdiv class\u003d\"form-group\"\u003e\n                            \u003clabel for\u003d\"smallFontColor\"\u003e小フォント\u003c/label\u003e\n                            \u003cdiv class\u003d\"input-group\"\u003e\n                              \u003cinput type\u003d\"color\" id\u003d\"smallFontColor\" value\u003d\"#1F2937\"\u003e\n                              \u003cinput type\u003d\"text\" id\u003d\"smallFontColorText\" class\u003d\"form-control\" value\u003d\"#1F2937\"\u003e\n                            \u003c/div\u003e\n                          \u003c/div\u003e\n                        \u003c/div\u003e\n                      \u003cdiv class\u003d\"checkbox-wrapper\" style\u003d\"border-top: 1px solid var(--border-color); margin-top: 1rem; padding-top: 1rem;\"\u003e\n                        \u003cinput type\u003d\"checkbox\" id\u003d\"showTitleUnderline\" checked\u003e\n                        \u003clabel for\u003d\"showTitleUnderline\"\u003eタイトル下にアンダーラインを表示\u003c/label\u003e\n                      \u003c/div\u003e\n                      \u003cdiv class\u003d\"checkbox-wrapper\"\u003e\n                        \u003cinput type\u003d\"checkbox\" id\u003d\"showBottomBar\" checked\u003e\n                        \u003clabel for\u003d\"showBottomBar\"\u003eスライド下部にフッターバーを表示\u003c/label\u003e\n                      \u003c/div\u003e\n                      \u003cdiv class\u003d\"checkbox-wrapper\"\u003e\n                        \u003cinput type\u003d\"checkbox\" id\u003d\"showDateColumn\" checked\u003e\n                        \u003clabel for\u003d\"showDateColumn\"\u003eタイトルスライドに日付を表示\u003c/label\u003e\n                      \u003c/div\u003e\n                      \u003cdiv class\u003d\"checkbox-wrapper\" style\u003d\"border-top: 1px solid var(--border-color); margin-top: 1rem; padding-top: 1rem;\"\u003e\n                        \u003cinput type\u003d\"checkbox\" id\u003d\"enableGradient\"\u003e\n                        \u003clabel for\u003d\"enableGradient\"\u003eグラデーションを適用\u003c/label\u003e\n                      \u003c/div\u003e\n                      \u003cdiv class\u003d\"checkbox-wrapper\"\u003e\n                        \u003cinput type\u003d\"checkbox\" id\u003d\"enableGraphAnimation\"\u003e\n                        \u003clabel for\u003d\"enableGraphAnimation\"\u003eアニメーショングラフ\u003c/label\u003e\n                      \u003c/div\u003e\n                      \u003cdiv id\u003d\"gradient-options\"\u003e\n                        \u003cdiv class\u003d\"form-grid\"\u003e\n                          \u003cdiv class\u003d\"form-group\"\u003e\n                            \u003clabel for\u003d\"gradientStart\"\u003e開始色\u003c/label\u003e\n                            \u003cdiv class\u003d\"input-group\"\u003e\n                              \u003cinput type\u003d\"color\" id\u003d\"gradientStart\" value\u003d\"#4285F4\"\u003e\n                              \u003cinput type\u003d\"text\" id\u003d\"gradientStartText\" class\u003d\"form-control\" value\u003d\"#4285F4\"\u003e\n                            \u003c/div\u003e\n                          \u003c/div\u003e\n                          \u003cdiv class\u003d\"form-group\"\u003e\n                            \u003clabel for\u003d\"gradientEnd\"\u003e終了色\u003c/label\u003e\n                            \u003cdiv class\u003d\"input-group\"\u003e\n                              \u003cinput type\u003d\"color\" id\u003d\"gradientEnd\" value\u003d\"#ff52df\"\u003e\n                              \u003cinput type\u003d\"text\" id\u003d\"gradientEndText\" class\u003d\"form-control\" value\u003d\"#ff52df\"\u003e\n                            \u003c/div\u003e\n                          \u003c/div\u003e\n                        \u003c/div\u003e\n                        \u003cdiv class\u003d\"gradient-preview-section\"\u003e\n                          \u003clabel\u003eグラデーションプレビュー\u003c/label\u003e\n                          \u003cdiv id\u003d\"gradientPreview\" class\u003d\"gradient-preview-box\"\u003e\n                            \u003cspan\u003eグラデーション見本\u003c/span\u003e\n                          \u003c/div\u003e\n                        \u003c/div\u003e\n                      \u003c/div\u003e\n                  \u003c/div\u003e\n                \u003c/div\u003e\n                \u003cdiv class\u003d\"collapsible-section\"\u003e\n                  \u003cdiv class\u003d\"collapsible-header\"\u003e\n                    \u003cspan\u003eロゴ設定\u003c/span\u003e\n                    \u003cspan class\u003d\"collapsible-icon\"\u003e▼\u003c/span\u003e\n                  \u003c/div\u003e\n                  \u003cdiv class\u003d\"collapsible-content\"\u003e\n                    \u003cdiv class\u003d\"note note-info\"\u003e画像URLまたはGoogleドライブの共有リンクを入力してください。\u003c/div\u003e\n                    \u003cdiv class\u003d\"form-grid\"\u003e\n                      \u003cdiv class\u003d\"form-group\"\u003e\n                        \u003clabel for\u003d\"headerLogoUrl\"\u003eヘッダーロゴ\u003c/label\u003e\n                        \u003cdiv class\u003d\"input-group\"\u003e\n                          \u003cinput type\u003d\"text\" id\u003d\"headerLogoUrl\" class\u003d\"form-control\" value\u003d\"https://upload.wikimedia.org/wikipedia/commons/thumb/8/8a/Google_Gemini_logo.svg/2560px-Google_Gemini_logo.svg.png\"\u003e\n                          \u003cbutton type\u003d\"button\" class\u003d\"btn-secondary\"\u003e開く\u003c/button\u003e\n                        \u003c/div\u003e\n                      \u003c/div\u003e\n                      \u003cdiv class\u003d\"form-group\"\u003e\n                        \u003clabel for\u003d\"closingLogoUrl\"\u003eクロージングロゴ\u003c/label\u003e\n                        \u003cdiv class\u003d\"input-group\"\u003e\n                          \u003cinput type\u003d\"text\" id\u003d\"closingLogoUrl\" class\u003d\"form-control\" value\u003d\"https://upload.wikimedia.org/wikipedia/commons/thumb/8/8a/Google_Gemini_logo.svg/2560px-Google_Gemini_logo.svg.png\"\u003e\n                          \u003cbutton type\u003d\"button\" class\u003d\"btn-secondary\"\u003e開く\u003c/button\u003e\n                        \u003c/div\u003e\n                      \u003c/div\u003e\n                    \u003c/div\u003e\n                  \u003c/div\u003e\n                \u003c/div\u003e\n                \u003cdiv class\u003d\"collapsible-section\"\u003e\n                  \u003cdiv class\u003d\"collapsible-header\"\u003e\n                    \u003cspan\u003e背景設定\u003c/span\u003e\n                    \u003cspan class\u003d\"collapsible-icon\"\u003e▼\u003c/span\u003e\n                  \u003c/div\u003e\n                  \u003cdiv class\u003d\"collapsible-content\"\u003e\n                    \u003cdiv class\u003d\"note note-info\"\u003e画像URLまたはGoogleドライブの共有リンクを入力してください。\u003c/div\u003e\n                    \u003cdiv class\u003d\"form-grid\"\u003e\n                      \u003cdiv class\u003d\"form-group\"\u003e\n                        \u003clabel for\u003d\"titleBgUrl\"\u003eタイトル背景\u003c/label\u003e\n                        \u003cdiv class\u003d\"input-group\"\u003e\n                          \u003cinput type\u003d\"text\" id\u003d\"titleBgUrl\" class\u003d\"form-control\" value\u003d\"\"\u003e\n                          \u003cbutton type\u003d\"button\" class\u003d\"btn-secondary\"\u003e開く\u003c/button\u003e\n                        \u003c/div\u003e\n                      \u003c/div\u003e\n                      \u003cdiv class\u003d\"form-group\"\u003e\n                        \u003clabel for\u003d\"sectionBgUrl\"\u003eセクション背景\u003c/label\u003e\n                        \u003cdiv class\u003d\"input-group\"\u003e\n                          \u003cinput type\u003d\"text\" id\u003d\"sectionBgUrl\" class\u003d\"form-control\" value\u003d\"\"\u003e\n                          \u003cbutton type\u003d\"button\" class\u003d\"btn-secondary\"\u003e開く\u003c/button\u003e\n                        \u003c/div\u003e\n                      \u003c/div\u003e\n                      \u003cdiv class\u003d\"form-group\"\u003e\n                        \u003clabel for\u003d\"mainBgUrl\"\u003eメイン背景\u003c/label\u003e\n                        \u003cdiv class\u003d\"input-group\"\u003e\n                          \u003cinput type\u003d\"text\" id\u003d\"mainBgUrl\" class\u003d\"form-control\" value\u003d\"\"\u003e\n                          \u003cbutton type\u003d\"button\" class\u003d\"btn-secondary\"\u003e開く\u003c/button\u003e\n                        \u003c/div\u003e\n                      \u003c/div\u003e\n                      \u003cdiv class\u003d\"form-group\"\u003e\n                        \u003clabel for\u003d\"closingBgUrl\"\u003eクロージング背景\u003c/label\u003e\n                        \u003cdiv class\u003d\"input-group\"\u003e\n                          \u003cinput type\u003d\"text\" id\u003d\"closingBgUrl\" class\u003d\"form-control\" value\u003d\"\"\u003e\n                          \u003cbutton type\u003d\"button\" class\u003d\"btn-secondary\"\u003e開く\u003c/button\u003e\n                        \u003c/div\u003e\n                      \u003c/div\u003e\n                      \u003cdiv class\u003d\"form-group\"\u003e\n                        \u003clabel for\u003d\"backgroundColor\"\u003e背景カラー (全体)\u003c/label\u003e\n                        \u003cdiv class\u003d\"input-group\"\u003e\n                          \u003cinput type\u003d\"color\" id\u003d\"backgroundColor\" value\u003d\"#FFFFFF\"\u003e\n                          \u003cinput type\u003d\"text\" id\u003d\"backgroundColorText\" class\u003d\"form-control\" value\u003d\"#FFFFFF\"\u003e\n                        \u003c/div\u003e\n                      \u003c/div\u003e\n                    \u003c/div\u003e\n                  \u003c/div\u003e\n                \u003c/div\u003e\n                \u003c/div\u003e\n            \u003c/div\u003e\n            \u003cfooter style\u003d\"text-align: right; padding: 0.5rem 0.5rem 0.5rem 0.5rem; font-size: 0.8rem; color: #9CA3AF;\"\u003e\n              \u003ca href\u003d\"https://note.com/majin_108\" target\u003d\"_blank\" style\u003d\"color: inherit; text-decoration: none;\"\u003e\n              Developed by majin \u003c?\u003d appVersion ?\u003e\u003c/a\u003e\n            \u003cdiv id\u003d\"showPreviewBtnLeftContainer\" style\u003d\"\n                position: fixed; \n                bottom: 1rem; \n                left: 1.5rem; \n                z-index: 10; \n                display: none; \n            \"\u003e\n              \u003cbutton id\u003d\"showPreviewBtnLeft\" class\u003d\"primary-color\" title\u003d\"プレビューを表示\"\u003e\n                \u003cspan id\u003d\"showPreviewIcon\"\u003e\u003e\u003c/span\u003e \u003c/button\u003e\n            \u003c/div\u003e\n            \u003c/footer\u003e\n          \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \u003c/div\u003e \n    \u003c/div\u003e \u003cdiv id\u003d\"toastContainer\" class\u003d\"toast-container\"\u003e\u003c/div\u003e\n  \u003cdiv id\u003d\"imagePromptModal\" class\u003d\"modal-overlay\" style\u003d\"display: none;\"\u003e\n    \u003cdiv class\u003d\"modal-content card\"\u003e\n      \u003ch3 class\u003d\"card-header\"\u003e画像の指定\u003c/h3\u003e\n      \u003cdiv class\u003d\"card-body\"\u003e\n        \u003cp id\u003d\"imagePromptText\" style\u003d\"margin-bottom: 1rem;\"\u003e\u003c/p\u003e\n        \u003cdiv id\u003d\"imageDropZone\" class\u003d\"drop-zone\"\u003e\n          \u003cimg id\u003d\"imagePreview\" src\u003d\"#\" alt\u003d\"Image Preview\" class\u003d\"image-preview\" style\u003d\"display:none;\"\u003e\n          \u003cspan id\u003d\"dropZoneText\" style\u003d\"cursor: default;\"\u003eここに画像をドラッグ＆ドロップ、\u003cbr\u003e \u003ca href\u003d\"#\" id\u003d\"fileSelectLink\" style\u003d\"color: var(--primary-color); text-decoration: underline;\"\u003eクリックしてファイルを選択\u003c/a\u003e\u003cbr\u003eまたは画像をペーストしてください。\n          \u003c/span\u003e\n        \u003c/div\u003e\n        \u003cdiv class\u003d\"button-group\" style\u003d\"display: flex; gap: 1rem; margin-top: 1.5rem;\"\u003e\n          \u003cbutton id\u003d\"confirmImageBtn\" class\u003d\"btn btn-primary\" disabled\u003e確定\u003c/button\u003e\n          \u003cbutton id\u003d\"cancelGenerationBtn\" class\u003d\"btn btn-secondary\" style\u003d\"background-color: var(--secondary-color);\"\u003e画像なしで続行\u003c/button\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n  \u003cdiv id\u003d\"gemUrlModal\" class\u003d\"modal-overlay\" style\u003d\"display: none;\"\u003e\n    \u003cdiv class\u003d\"modal-content card\" style\u003d\"max-width: 600px; max-height: 90vh;\"\u003e\n      \u003ch3 class\u003d\"card-header\"\u003e初回設定: GeminiでGemを作成してください\u003c/h3\u003e\n      \u003cdiv class\u003d\"card-body\"\u003e\n        \u003cdiv id\u003d\"gemHelpArea\" style\u003d\"display: block; padding-top: 0.25rem; font-size: 0.875rem; line-height: 1.6;\"\u003e \n          \u003cp style\u003d\"font-weight: 600; margin-top: 0;\"\u003e① 以下のプロンプトをコピーする\u003c/p\u003e\n          \u003cdiv style\u003d\"display: flex; gap: 0.5rem; margin-bottom: 1rem;\"\u003e\n            \u003ctextarea id\u003d\"gemPromptTextarea\" class\u003d\"form-control\" rows\u003d\"5\" readonly style\u003d\"font-family: var(--font-family-code); font-size: 0.8125rem; background: #f9f9f9; resize: none;\"\u003e読み込み中...\u003c/textarea\u003e\n            \u003cbutton id\u003d\"copyGemPromptBtn\" type\u003d\"button\" class\u003d\"btn-preset\" style\u003d\"flex-shrink: 0;\"\u003eコピー\u003c/button\u003e\n          \u003c/div\u003e\n          \u003cp style\u003d\"font-weight: 600;\"\u003e② Geminiを開く\u003c/p\u003e\n          \u003ca href\u003d\"https://gemini.google.com/gems/create\" target\u003d\"_blank\" rel\u003d\"noopener noreferrer\" class\u003d\"btn btn-primary\" style\u003d\"width: auto; padding: 0.5rem 1rem; text-transform: none; margin-bottom: 1rem;\"\u003e\n            Gem作成画面を開く\n          \u003c/a\u003e\n          \u003cp style\u003d\"font-weight: 600;\"\u003e③ Gemの名前を入力し、「カスタム指示」にコピーしたプロンプトを貼り付けて保存します。\u003c/p\u003e\n          \u003cp style\u003d\"font-weight: 600;\"\u003e④ 「共有」ボタンをクリックし、共有するユーザー（例: あなた、特定のユーザー）を設定し、「リンクをコピー」をクリックします。\u003c/p\u003e\n          \u003cp style\u003d\"font-weight: 600;\"\u003e⑤ コピーしたURLを下の入力欄に貼り付けて「保存して開始」をクリックします。\u003c/p\u003e\n        \u003c/div\u003e\n        \u003cdiv class\u003d\"form-group\" style\u003d\"margin-top: 1.5rem;\"\u003e \n          \u003clabel for\u003d\"gemUrlInput\"\u003eGemini Gem URL\u003c/label\u003e\n          \u003cinput type\u003d\"text\" id\u003d\"gemUrlInput\" class\u003d\"form-control\" placeholder\u003d\"https://gemini.google.com/gem/...\"\u003e\n          \u003csmall id\u003d\"gemUrlError\" style\u003d\"color: var(--danger-color); display: none; margin-top: 0.5rem;\"\u003e\u003c/small\u003e\n        \u003c/div\u003e\n        \u003cdiv class\u003d\"button-group\" style\u003d\"margin-top: 1.5rem; display: flex; flex-direction: column; gap: 0.75rem;\"\u003e\n          \u003cbutton id\u003d\"saveGemUrlBtn\" class\u003d\"btn btn-primary\"\u003e保存して開始\u003c/button\u003e \n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n  \u003cdiv id\u003d\"imageUpdateOptionModal\" class\u003d\"modal-overlay\" style\u003d\"display: none;\"\u003e\n    \u003cdiv class\u003d\"modal-content card\" style\u003d\"max-width: 450px;\"\u003e\n      \u003ch3 class\u003d\"card-header\"\u003e画像オプションの選択\u003c/h3\u003e\n      \u003cdiv class\u003d\"card-body\"\u003e\n        \u003cp style\u003d\"margin-bottom: 1.5rem;\"\u003eスライド内の画像をどのように更新しますか？\u003c/p\u003e\n        \u003cdiv class\u003d\"button-group\" style\u003d\"display: flex; flex-direction: column; gap: 1rem;\"\u003e\n          \u003cbutton id\u003d\"imageOptionUpdateBtn\" class\u003d\"btn btn-primary\"\u003e画像も更新する\u003c/button\u003e\n          \u003cbutton id\u003d\"imageOptionKeepBtn\" class\u003d\"btn btn-secondary\" style\u003d\"background-color: var(--secondary-color);\"\u003e画像をそのまま使う\u003c/button\u003e\n          \u003cbutton id\u003d\"imageOptionCancelBtn\" class\u003d\"btn\" style\u003d\"background-color: #f3f4f6; color: var(--text-secondary); margin-top: 1rem;\"\u003eキャンセル\u003c/button\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n  \u003cdiv id\u003d\"videoPromptModal\" class\u003d\"modal-overlay\" style\u003d\"display: none;\"\u003e\n    \u003cdiv class\u003d\"modal-content card\" style\u003d\"max-width: 500px;\"\u003e\n      \u003ch3 class\u003d\"card-header\"\u003e動画ファイルの選択\u003c/h3\u003e\n      \u003cdiv class\u003d\"card-body\"\u003e\n        \u003cp id\u003d\"videoPromptText\" style\u003d\"margin-bottom: 1rem;\"\u003eスライドで使用する動画ファイルを選択してください。\u003c/p\u003e\n        \u003cdiv id\u003d\"videoDropZone\" class\u003d\"drop-zone\"\u003e\n          \u003cvideo id\u003d\"videoPreview\" controls class\u003d\"image-preview\" style\u003d\"display:none; max-height: 250px;\"\u003e\u003c/video\u003e\n          \u003cspan id\u003d\"videoDropZoneText\"\u003eここに動画ファイルをドラッグ＆ドロップ、\u003cbr\u003e\n            \u003ca href\u003d\"#\" id\u003d\"fileSelectLinkVideo\" style\u003d\"color: var(--primary-color); text-decoration: underline;\"\u003eクリックしてファイルを選択\u003c/a\u003e\u003cbr\u003e\n            または動画ファイルをペーストしてください。\n          \u003c/span\u003e\n          \u003cdiv id\u003d\"videoQualityContainer\" style\u003d\"margin-top: 1rem; text-align: left; display: none;\"\u003e\n             \u003clabel for\u003d\"videoQualitySelect\" style\u003d\"font-weight: 500; font-size: 0.875rem; color: var(--text-secondary);\"\u003eアニメーション画質 (短辺)\u003c/label\u003e\n             \u003cselect id\u003d\"videoQualitySelect\" class\u003d\"form-control\" style\u003d\"margin-top: 0.25rem;\"\u003e\n               \u003coption value\u003d\"240\"\u003e最小 (240px)\u003c/option\u003e\n               \u003coption value\u003d\"360\"\u003e軽量 (360px)\u003c/option\u003e\n               \u003coption value\u003d\"480\" selected\u003e標準 (480px)\u003c/option\u003e\n               \u003coption value\u003d\"720\"\u003e最高 (720px)\u003c/option\u003e\n               \u003c/select\u003e\n          \u003c/div\u003e\n        \u003c/div\u003e\n        \u003cdiv class\u003d\"button-group\" style\u003d\"display: flex; gap: 1rem; margin-top: 1.5rem;\"\u003e\n          \u003cbutton id\u003d\"confirmVideoBtn\" class\u003d\"btn btn-primary\" disabled\u003e確定\u003c/button\u003e\n          \u003cbutton id\u003d\"cancelVideoBtn\" class\u003d\"btn btn-secondary\" style\u003d\"background-color: var(--secondary-color);\"\u003e動画なしで続行\u003c/button\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n  \u003cinput type\u003d\"file\" id\u003d\"imageUpload\" accept\u003d\"image/*\" style\u003d\"display: none;\"\u003e\n  \u003cinput type\u003d\"file\" id\u003d\"videoUpload\" style\u003d\"display: none;\" accept\u003d\"video/*\"\u003e\n  \u003cdiv id\u003d\"previewInfoModal\" class\u003d\"modal-overlay\" style\u003d\"display: none;\"\u003e\n    \u003cdiv class\u003d\"modal-content card\" style\u003d\"max-width: 500px;\"\u003e\n      \u003ch3 class\u003d\"card-header\"\u003eプレビュー版について\u003c/h3\u003e\n      \u003cdiv class\u003d\"card-body\"\u003e\n        \u003cp\u003eこれは現在開発中のプレビュー版です。以下の点にご注意ください：\u003c/p\u003e\n        \u003cul style\u003d\"padding-left: 20px; margin-top: 1rem; margin-bottom: 1rem; font-size: 0.9rem; line-height: 1.6;\"\u003e\n          \u003cli\u003e機能が予期せず変更・停止される場合があります。\u003c/li\u003e\n          \u003cli\u003eデータが失われる可能性があるため、重要なデータは別途バックアップしてください。\u003c/li\u003e\n          \u003cli\u003e不具合やフィードバックがあれば、開発者までご連絡ください。\u003c/li\u003e\n          \u003cli style\u003d\"color: var(--danger-color, #EF4444); font-weight: 500; margin-top: 0.5rem;\"\u003e\n            プレビュー版のコードの改変・流用・第三者への共有は禁止させていただきます。\n          \u003c/li\u003e\n          \u003c/ul\u003e\n        \u003cdiv id\u003d\"previewInfoModal_FirstTimeMessage\" style\u003d\"display: none; margin-top: 1.5rem; padding-top: 1rem; border-top: 1px solid var(--border-color);\"\u003e\n          \u003c/div\u003e\n        \u003cdiv class\u003d\"button-group\" style\u003d\"margin-top: 1.5rem;\"\u003e\n          \u003cbutton id\u003d\"closePreviewInfoModalBtn\" class\u003d\"btn btn-primary\"\u003e閉じる\u003c/button\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n  \u003cdiv id\u003d\"historyRestoreModal\" class\u003d\"modal-overlay\" style\u003d\"display: none; z-index: 10020;\"\u003e\n  \u003cdiv class\u003d\"modal-content card\" style\u003d\"max-width: 600px; height: auto; max-height: 90vh; display: flex; flex-direction: column;\"\u003e\n    \u003ch3 class\u003d\"card-header\"\u003eスライドデータの読み込み\u003c/h3\u003e\n    \u003cdiv class\u003d\"card-body\" style\u003d\"overflow-y: auto; padding: 1.5rem;\"\u003e\n      \u003cdiv style\u003d\"margin-bottom: 1.5rem; padding-bottom: 1.5rem; border-bottom: 1px solid var(--border-color);\"\u003e\n        \u003clabel style\u003d\"font-weight: 600; display: block; margin-bottom: 0.5rem;\"\u003eスライドID または URL\u003c/label\u003e\n        \u003cdiv style\u003d\"display: flex; gap: 0.5rem;\"\u003e\n          \u003cinput type\u003d\"text\" id\u003d\"historyInputId\" class\u003d\"form-control\" placeholder\u003d\"https://docs.google.com/presentation/d/...\" style\u003d\"flex-grow: 1;\"\u003e\n          \u003cbutton id\u003d\"historyLoadBtn\" class\u003d\"btn btn-primary\" style\u003d\"width: auto; white-space: nowrap;\"\u003e読み込む\u003c/button\u003e\n        \u003c/div\u003e\n        \u003cp style\u003d\"font-size: 0.8rem; color: var(--text-secondary); margin-top: 0.5rem;\"\u003e\n          URLを貼り付けると自動的にIDが抽出されます。\n        \u003c/p\u003e\n      \u003c/div\u003e\n      \u003cdiv\u003e\n        \u003clabel style\u003d\"font-weight: 600; display: block; margin-bottom: 0.5rem;\"\u003e最近使用したスライド\u003c/label\u003e\n        \u003cdiv id\u003d\"historyListContainer\" style\u003d\"border: 1px solid var(--border-color); border-radius: var(--radius-md); max-height: 300px; overflow-y: auto; background: #F9FAFB;\"\u003e\n          \u003cdiv style\u003d\"padding: 2rem; text-align: center; color: var(--text-light);\"\u003e履歴を読み込み中...\u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n    \u003cdiv class\u003d\"card-body\" style\u003d\"padding: 1rem; border-top: 1px solid var(--border-color); flex-shrink: 0; display: flex; justify-content: flex-end;\"\u003e\n      \u003cbutton id\u003d\"historyCloseBtn\" class\u003d\"btn btn-secondary\" style\u003d\"width: auto;\"\u003e閉じる\u003c/button\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n  \u003cscript\u003e\n    // \n    const ENABLE_CREDIT_IMAGE \u003d false;\n    const CREDIT_TEXT_OPTIONS \u003d [\n      \u0027Change the world. majin\u0027,\n      \u0027Accessible AI for All. majin\u0027,\n      \u0027Automate \u0026 Focus. majin\u0027,\n      \u0027Work Creatively. majin\u0027,\n      \u0027AI boosts Creativity. majin\u0027,\n      \u0027Reimagine Your Work. majin\u0027\n    ];\n    // \n    var isPreviewVisible \u003d false;\n    var hasShownFirstTimePreviewModal \u003d localStorage.getItem(\u0027hasShownPreviewModal_v1\u0027) \u003d\u003d\u003d \u0027true\u0027; // \n    var lastSplitRatio \u003d \u00271fr 5px 1fr\u0027; // \n    var isSlideFullscreen \u003d false;\n    var loadedSettings \u003d {};\n    var lastGeneratedSlideUrl \u003d null;\n    try { loadedSettings \u003d \u003c?!\u003d JSON.stringify(loadSettings()) ?\u003e || {}; } catch (e) {}\n    var enableUiColorSync \u003d false; // \n    var timerInterval \u003d null;\n    var timerStartTime \u003d 0;\n    var isTimerPaused \u003d false; // \n    var lastElapsedSeconds \u003d 0.0; // \n    var cachedHistoryList \u003d null;\n    function $(id){ return document.getElementById(id); }\n    // \n    function showPreviewPane() {\n      const appLayout \u003d $(\u0027app-layout\u0027);\n      const previewView \u003d $(\u0027slidePreviewContainer\u0027);\n      const splitter \u003d $(\u0027splitter\u0027);\n      const iframe \u003d $(\u0027slidePreviewFrame\u0027);\n      const showBtn \u003d $(\u0027showLastSlideBtn\u0027);\n      const fullscreenBtnContainer \u003d $(\u0027fullscreenToggleContainer\u0027); // \n      const fullscreenIcon \u003d $(\u0027fullscreenIcon\u0027); // \n      const newTabBtn \u003d $(\u0027openSlideNewTabBtn\u0027);\n      if (isPreviewVisible \u0026\u0026 !isSlideFullscreen) return; // \n      if (lastGeneratedSlideUrl) {\n        let embedUrl \u003d lastGeneratedSlideUrl.replace(\"/edit\", \"/embed\");\n        if (iframe.src !\u003d\u003d embedUrl) { // \n          iframe.src \u003d embedUrl;\n        }\n        if (newTabBtn) {\n          newTabBtn.href \u003d lastGeneratedSlideUrl; // \n          newTabBtn.style.display \u003d \u0027inline-flex\u0027; // \n        }\n      } else {\n        showStatus(\u0027エラー: 表示するスライドがありません。\u0027, \u0027error\u0027);\n        return;\n      }\n      $(\u0027closePreviewBtn\u0027).style.display \u003d \u0027block\u0027; \n      $(\u0027closeSettingsBtn\u0027).style.display \u003d \u0027block\u0027; \n      previewView.style.display \u003d \u0027block\u0027;\n      splitter.style.display \u003d \u0027block\u0027;\n      fullscreenBtnContainer.style.display \u003d \u0027block\u0027; // \n      appLayout.style.gridTemplateColumns \u003d lastSplitRatio; // \n      // \n      isSlideFullscreen \u003d false;\n      fullscreenIcon.textContent \u003d \u0027\u003e\u0027;\n      $(\u0027left-pane\u0027).style.display \u003d \u0027flex\u0027; // \n      isPreviewVisible \u003d true;\n      // \n      const showPreviewBtnLeftContainer \u003d $(\u0027showPreviewBtnLeftContainer\u0027);\n      if (showPreviewBtnLeftContainer) {\n        showPreviewBtnLeftContainer.style.display \u003d \u0027none\u0027;\n      }\n    }\n    // \n    function hidePreviewPane() {\n      const appLayout \u003d $(\u0027app-layout\u0027);\n      const previewView \u003d $(\u0027slidePreviewContainer\u0027);\n      const splitter \u003d $(\u0027splitter\u0027);\n      const iframe \u003d $(\u0027slidePreviewFrame\u0027);\n      const showBtn \u003d $(\u0027showLastSlideBtn\u0027);\n      const fullscreenBtnContainer \u003d $(\u0027fullscreenToggleContainer\u0027);\n      const newTabBtn \u003d $(\u0027openSlideNewTabBtn\u0027);\n      if (!isPreviewVisible) return; // \n      if (newTabBtn) {\n        newTabBtn.style.display \u003d \u0027none\u0027; // \n      }\n      lastSplitRatio \u003d appLayout.style.gridTemplateColumns; // \n      previewView.style.display \u003d \u0027none\u0027;\n      splitter.style.display \u003d \u0027none\u0027;\n      $(\u0027closePreviewBtn\u0027).style.display \u003d \u0027none\u0027;\n      $(\u0027closeSettingsBtn\u0027).style.display \u003d \u0027none\u0027;\n      fullscreenBtnContainer.style.display \u003d \u0027none\u0027;\n      iframe.src \u003d \u0027about:blank\u0027; // \n      // \n      appLayout.style.gridTemplateColumns \u003d \u00271fr\u0027;\n      // \n      isSlideFullscreen \u003d false; // \n      isPreviewVisible \u003d false;  // \n      // \n      if (SlideEditor \u0026\u0026 SlideEditor.isEditorActive()) {\n        // \n        SlideEditor.updatePreviewButtonForEditor(true);\n      } else {\n        // \n        if (showBtn) {\n          showBtn.textContent \u003d \u0027スライドを表示\u0027;\n          showBtn.classList.add(\u0027btn-primary\u0027);\n          showBtn.classList.remove(\u0027btn-secondary\u0027);\n          showBtn.style.backgroundColor \u003d \u0027\u0027;\n        }\n      }\n      // \n    }\n// \n    // \n    function toggleFullscreenPreview() {\n      const appLayout \u003d $(\u0027app-layout\u0027);\n      const leftPane \u003d $(\u0027left-pane\u0027);\n      const splitter \u003d $(\u0027splitter\u0027);\n      const fullscreenIcon \u003d $(\u0027fullscreenIcon\u0027);\n      const showBtn \u003d $(\u0027showLastSlideBtn\u0027); // \n      const toastContainer \u003d $(\u0027toastContainer\u0027); // \n      isSlideFullscreen \u003d !isSlideFullscreen; // \n      if (isSlideFullscreen) {\n        // \n        // \n        lastSplitRatio \u003d appLayout.style.gridTemplateColumns;\n        // \n        appLayout.style.gridTemplateColumns \u003d \u00271fr\u0027;\n        leftPane.style.display \u003d \u0027none\u0027;\n        splitter.style.display \u003d \u0027none\u0027;\n        $(\u0027closePreviewBtn\u0027).style.display \u003d \u0027none\u0027; \n        $(\u0027closeSettingsBtn\u0027).style.display \u003d \u0027none\u0027; \n        // \n        fullscreenIcon.textContent \u003d \u0027\u003c\u0027;\n        // \n        if (showBtn) {\n          showBtn.style.display \u003d \u0027none\u0027;\n        }\n        // \n        if (toastContainer) {\n          toastContainer.style.display \u003d \u0027none\u0027;\n        }\n      } else {\n        // \n        // \n        appLayout.style.gridTemplateColumns \u003d lastSplitRatio;\n        leftPane.style.display \u003d \u0027flex\u0027; // \n        splitter.style.display \u003d \u0027block\u0027;\n        $(\u0027closePreviewBtn\u0027).style.display \u003d \u0027block\u0027; \n        $(\u0027closeSettingsBtn\u0027).style.display \u003d \u0027block\u0027; \n        // \n        fullscreenIcon.textContent \u003d \u0027\u003e\u0027;\n        // \n        if (toastContainer) {\n          toastContainer.style.display \u003d \u0027flex\u0027; // \n        }\n        // \n        if (showBtn) {\n          // \n          setTimeout(() \u003d\u003e {\n            if (showBtn) {\n              showBtn.style.display \u003d \u0027inline-flex\u0027;\n              showBtn.style.zIndex \u003d \u0027100\u0027; \n              if (SlideEditor \u0026\u0026 SlideEditor.isEditorActive()) {\n                // \n                SlideEditor.updatePreviewButtonForEditor(true);\n              } else {\n                // \n                showBtn.onclick \u003d function() { \n                  if (isPreviewVisible) hidePreviewPane(); else showPreviewPane();\n                };\n              }\n            }\n          }, 50); // \n        }\n      }\n    }\n      // \n      const toggleFullscreenBtn \u003d $(\u0027toggleFullscreenBtn\u0027);\n      if (toggleFullscreenBtn) {\n        toggleFullscreenBtn.addEventListener(\u0027click\u0027, toggleFullscreenPreview);\n      }\n      // \n    function adjustTextAreaHeight() {\n      const textArea \u003d $(\u0027slideDataInput\u0027);\n      if (!textArea) return;\n      try {\n        const leftPane \u003d $(\u0027left-pane\u0027);\n        // \n        const isNarrow \u003d (leftPane \u0026\u0026 leftPane.classList.contains(\u0027narrow-layout\u0027)) || (window.innerWidth \u003c 650);\n        if (isNarrow) {\n          // \n          textArea.style.height \u003d \u0027150px\u0027;\n        } else {\n          // \n          const settingsCard \u003d document.querySelector(\u0027.settings-section\u0027);\n          const leftColumn \u003d document.querySelector(\u0027.left-column\u0027);\n          if (!settingsCard || !leftColumn) { \n            // \n            return; \n          }\n          const targetHeight \u003d settingsCard.offsetHeight;\n          const currentEditorHeight \u003d leftColumn.offsetHeight;\n          const heightDifference \u003d targetHeight - currentEditorHeight;\n          const currentTextAreaHeight \u003d textArea.offsetHeight; // \n          const newTextAreaHeight \u003d currentTextAreaHeight + heightDifference;\n          if (newTextAreaHeight \u003e 50) {\n            textArea.style.height \u003d newTextAreaHeight + \u0027px\u0027;\n          }\n        }\n      } catch (e) {\n        console.error(\"Error during adjustTextAreaHeight:\", e);\n      } finally {\n        // \n        textArea.classList.add(\u0027height-adjusted\u0027);\n        // \n      }\n    }\n    function hexToRgb(hex) {\n      // \n      let result \u003d /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})$/i.exec(hex);\n      return result ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16)\n      } : null;\n    }\n    function darkenColor(color, amount) {\n      const rgb \u003d hexToRgb(color);\n      if (!rgb) return color; // \n      const darken \u003d (c) \u003d\u003e Math.max(0, Math.round(c * (1 - amount))); // \n      const newR \u003d darken(rgb.r);\n      const newG \u003d darken(rgb.g);\n      const newB \u003d darken(rgb.b);\n      // \n      return `#${newR.toString(16).padStart(2, \u00270\u0027)}${newG.toString(16).padStart(2, \u00270\u0027)}${newB.toString(16).padStart(2, \u00270\u0027)}`;\n    }\n    function updatePrimaryColor(newColor) {\n      if (!/^#([0-9A-F]{3}){1,2}$/i.test(newColor)) return;\n      $(\u0027primaryColor\u0027).value \u003d newColor;\n      $(\u0027primaryColorText\u0027).value \u003d newColor;\n      // \n      document.documentElement.style.setProperty(\u0027--primary-color\u0027, newColor);\n      try {\n        // \n        const rgb \u003d hexToRgb(newColor); // \n        if (rgb) {\n          // \n          document.documentElement.style.setProperty(\u0027--primary-color-rgb\u0027, `${rgb.r}, ${rgb.g}, ${rgb.b}`);\n          // \n          // \n          const r \u003d Math.floor(rgb.r * 0.85);\n          const g \u003d Math.floor(rgb.g * 0.85);\n          const b \u003d Math.floor(rgb.b * 0.85);\n          const darkColor \u003d \"#\" + ((1 \u003c\u003c 24) + (r \u003c\u003c 16) + (g \u003c\u003c 8) + b).toString(16).slice(1).toUpperCase();\n          document.documentElement.style.setProperty(\u0027--primary-color-dark\u0027, darkColor);\n        } else {\n           throw new Error(\u0027hexToRgb failed\u0027);\n        }\n      } catch (e) {\n        // \n        document.documentElement.style.setProperty(\u0027--primary-color-dark\u0027, newColor);\n        // \n        document.documentElement.style.setProperty(\u0027--primary-color-rgb\u0027, \u002766, 133, 244\u0027); // \n      }\n    }\n    // \n    function showStatus(message, type \u003d \u0027info\u0027, duration \u003d 4000){\n      const container \u003d $(\u0027toastContainer\u0027);\n      if(!container) return null; // \n      const toast \u003d document.createElement(\u0027div\u0027);\n      const toastId \u003d \u0027toast-\u0027 + Date.now() + Math.random(); // \n      toast.id \u003d toastId; // \n      toast.className \u003d `toast toast-${type}`;\n      toast.innerHTML \u003d message;\n      if (type \u003d\u003d\u003d \u0027info\u0027) {\n        const primaryColor \u003d $(\u0027primaryColorText\u0027).value;\n        const rgb \u003d hexToRgb(primaryColor);\n        if (rgb) {\n          toast.style.backgroundColor \u003d `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.1)`;\n          toast.style.color \u003d `rgb(${Math.floor(rgb.r*0.4)}, ${Math.floor(rgb.g*0.4)}, ${Math.floor(rgb.b*0.4)})`;\n          toast.style.borderColor \u003d `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, 0.3)`;\n        }\n      }\n      container.appendChild(toast);\n      setTimeout(() \u003d\u003e {\n        // \n        const elementToRemove \u003d $(toastId);\n        if (elementToRemove) {\n          elementToRemove.remove();\n        }\n      }, duration);\n      return toastId; // \n    }\n    function filterEmptyStringsInArrays(data) {\n        function deepFilter(obj) {\n            if (Array.isArray(obj)) {\n                // \n                return obj\n                    .map(item \u003d\u003e deepFilter(item)) \n                    .filter(item \u003d\u003e item !\u003d\u003d \"\"); \n            } \n            else if (typeof obj \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026 obj !\u003d\u003d null) {\n                // \n                const newObj \u003d {};\n                for (const key in obj) {\n                    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n                        newObj[key] \u003d deepFilter(obj[key]);\n                    }\n                }\n                return newObj;\n            }\n            // \n            return obj;\n        }\n        // \n        if (Array.isArray(data)) {\n            // \n            return data.map(slide \u003d\u003e deepFilter(slide));\n        } else if (typeof data \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026 data !\u003d\u003d null) {\n            // \n            return deepFilter(data);\n        }\n        return data; // \n    }\n    function startButtonTimer(buttonElement) {\n      if (timerInterval) {\n        clearInterval(timerInterval); // \n      }\n      const timerSpan \u003d buttonElement.querySelector(\u0027.btn-timer\u0027);\n      const textSpan \u003d buttonElement.querySelector(\u0027.btn-text\u0027);\n      if (!timerSpan || !textSpan) return;\n      timerStartTime \u003d Date.now();\n      lastElapsedSeconds \u003d 0.0; // \n      isTimerPaused \u003d false; // \n      timerSpan.style.display \u003d \u0027inline\u0027; // \n      timerSpan.textContent \u003d \u00270.0s\u0027;\n      // \n      buttonElement.style.justifyContent \u003d \u0027center\u0027; \n      timerInterval \u003d setInterval(() \u003d\u003e {\n        // \n        if (isTimerPaused) {\n            return; // \n        }\n        // \n        const elapsed \u003d (Date.now() - timerStartTime) / 1000;\n        lastElapsedSeconds \u003d elapsed; // \n        timerSpan.textContent \u003d `${elapsed.toFixed(1)}s`;\n      }, 100);\n    }\n    function stopButtonTimer(buttonElement, defaultText) {\n      if (timerInterval) {\n        clearInterval(timerInterval);\n        timerInterval \u003d null;\n      }\n      isTimerPaused \u003d false; // \n      lastElapsedSeconds \u003d 0.0; // \n      const timerSpan \u003d buttonElement.querySelector(\u0027.btn-timer\u0027);\n      const textSpan \u003d buttonElement.querySelector(\u0027.btn-text\u0027);\n      if (timerSpan) timerSpan.style.display \u003d \u0027none\u0027; // \n      if (textSpan \u0026\u0026 defaultText) textSpan.textContent \u003d defaultText; // \n      // \n      buttonElement.style.justifyContent \u003d \u0027center\u0027;\n    }\n    function pauseTimer() {\n        if (timerInterval \u0026\u0026 !isTimerPaused) {\n            isTimerPaused \u003d true;\n        }\n    }\n    function resumeTimer() {\n        if (timerInterval \u0026\u0026 isTimerPaused) {\n            // \n            timerStartTime \u003d Date.now() - (lastElapsedSeconds * 1000);\n            isTimerPaused \u003d false;\n        }\n    }\n    (function wrapModalFunctionsForTimer() {\n        // \n        const modalFunctions \u003d {\n            \u0027promptForImage\u0027: \u0027cleanup\u0027,\n            \u0027promptForVideo\u0027: \u0027cleanup\u0027,\n            \u0027promptForFrameSelection\u0027: \u0027cleanup\u0027,\n            \u0027promptImageUpdateOption\u0027: \u0027cleanup\u0027,\n            \u0027showJsonErrorModal\u0027: \u0027closeJsonErrorModal\u0027,\n            \u0027showClearConfirmModal\u0027: \u0027closeClearConfirmModal\u0027,\n            \u0027showPreviewInfoModal\u0027: \u0027hidePreviewInfoModal\u0027\n        };\n        // \n        for (const funcName in modalFunctions) {\n            if (typeof window[funcName] \u003d\u003d\u003d \u0027function\u0027) {\n                const originalFunc \u003d window[funcName];\n                // \n                window[funcName] \u003d function() {\n                    pauseTimer(); // \n                    const result \u003d originalFunc.apply(this, arguments);\n                    // \n                    if (result \u0026\u0026 typeof result.then \u003d\u003d\u003d \u0027function\u0027) {\n                        // \n                        return result.then(\n                            (value) \u003d\u003e {\n                                resumeTimer(); // \n                                return value;\n                            },\n                            (error) \u003d\u003e {\n                                resumeTimer(); // \n                                throw error;\n                            }\n                        );\n                    }\n                    return result;\n                };\n                // \n                const closeFuncName \u003d modalFunctions[funcName];\n                if (closeFuncName \u0026\u0026 typeof window[closeFuncName] \u003d\u003d\u003d \u0027function\u0027 \u0026\u0026 closeFuncName !\u003d\u003d \u0027cleanup\u0027) {\n                     const originalCloseFunc \u003d window[closeFuncName];\n                     window[closeFuncName] \u003d function() {\n                         originalCloseFunc.apply(this, arguments);\n                         resumeTimer(); // \n                     };\n                }\n            }\n        }\n        // \n        document.addEventListener(\u0027DOMContentLoaded\u0027, () \u003d\u003e {\n            const saveBtn \u003d $(\u0027saveGemUrlBtn\u0027);\n            const modal \u003d $(\u0027gemUrlModal\u0027);\n            // \n            if (modal \u0026\u0026 modal.style.display \u003d\u003d\u003d \u0027flex\u0027) {\n                pauseTimer();\n            }\n            if (saveBtn) {\n                // \n                const originalSaveHandler \u003d saveBtn.onclick;\n                if (typeof originalSaveHandler \u003d\u003d\u003d \u0027function\u0027) {\n                    saveBtn.onclick \u003d function() {\n                        // \n                        originalSaveHandler.apply(this, arguments);\n                    };\n                }\n                // \n                const input \u003d $(\u0027gemUrlInput\u0027);\n                const errorEl \u003d $(\u0027gemUrlError\u0027);\n                saveBtn.addEventListener(\u0027click\u0027, function() {\n                    const url \u003d input.value.trim();\n                    // \n                    const originalRun \u003d google.script.run;\n                    google.script.run \u003d new Proxy(originalRun, {\n                        get(target, prop) {\n                            const originalMethod \u003d target[prop];\n                            if (prop \u003d\u003d\u003d \u0027withSuccessHandler\u0027 || prop \u003d\u003d\u003d \u0027withFailureHandler\u0027) {\n                                return function(callback) {\n                                    const wrappedCallback \u003d function() {\n                                        resumeTimer(); // \n                                        return callback.apply(this, arguments);\n                                    };\n                                    return originalMethod.call(target, wrappedCallback);\n                                };\n                            }\n                            return originalMethod;\n                        }\n                    });\n                    // \n                    google.script.run \u003d originalRun; \n                });\n            }\n        });\n    })();\n    function updateLargeFontColor(newColor) {\n      if (!/^#([0-9A-F]{3}){1,2}$/i.test(newColor)) return;\n      $(\u0027largeFontColor\u0027).value \u003d newColor; // \n      $(\u0027largeFontColorText\u0027).value \u003d newColor; // \n      if (!enableUiColorSync) return;\n      document.documentElement.style.setProperty(\u0027--text-large-font\u0027, newColor); // \n    }\n    function updateSmallFontColor(newColor) {\n      if (!/^#([0-9A-F]{3}){1,2}$/i.test(newColor)) return;\n      $(\u0027smallFontColor\u0027).value \u003d newColor; // \n      $(\u0027smallFontColorText\u0027).value \u003d newColor; // \n      if (!enableUiColorSync) return;\n      document.documentElement.style.setProperty(\u0027--text-small-font\u0027, newColor); // \n    }\n      function updateBackgroundColor(newColor) {\n          // \n          if (!/^#([0-9A-F]{3}){1,2}$/i.test(newColor)) return;\n          // \n          $(\u0027backgroundColor\u0027).value \u003d newColor;\n          $(\u0027backgroundColorText\u0027).value \u003d newColor;\n          if (!enableUiColorSync) return;\n          // \n          const leftPane \u003d $(\u0027left-pane\u0027);\n          const isNarrow \u003d leftPane \u0026\u0026 leftPane.classList.contains(\u0027narrow-layout\u0027);\n          // \n          if (isNarrow) {\n              return;\n          }\n          // \n          let bodyBgValue;\n          let headerBgValue;\n          if (newColor.toUpperCase() \u003d\u003d\u003d \u0027#FFFFFF\u0027) {\n              bodyBgValue \u003d \u0027#F9FAFB\u0027;\n              headerBgValue \u003d \u0027#F9FAFB\u0027;\n          } else {\n              bodyBgValue \u003d newColor;\n              headerBgValue \u003d darkenColor(newColor, 0.05);\n          }\n          document.documentElement.style.setProperty(\u0027--bg-body\u0027, bodyBgValue);\n          document.documentElement.style.setProperty(\u0027--card-header-bg\u0027, headerBgValue);\n          // \n    }\n    function getCurrentSettings() {\n      return {\n        primaryColor: $(\u0027primaryColorText\u0027).value,\n        largeFontColor: $(\u0027largeFontColorText\u0027).value,\n        smallFontColor: $(\u0027smallFontColorText\u0027).value,\n        backgroundColor: $(\u0027backgroundColorText\u0027).value,\n        graphColorTheme: $(\u0027graphColorTheme\u0027).value,\n        fontFamily: $(\u0027fontFamily\u0027).value,\n        showTitleUnderline: $(\u0027showTitleUnderline\u0027).checked,\n        showBottomBar: $(\u0027showBottomBar\u0027).checked,\n        showDateColumn: $(\u0027showDateColumn\u0027).checked,\n        enableGradient: $(\u0027enableGradient\u0027).checked,\n        gradientStart: $(\u0027gradientStartText\u0027).value,\n        gradientEnd: $(\u0027gradientEndText\u0027).value,\n        enableGraphAnimation: $(\u0027enableGraphAnimation\u0027).checked,\n        footerText: $(\u0027footerText\u0027).value.trim(),\n        headerLogoUrl: $(\u0027headerLogoUrl\u0027).value.trim(),\n        closingLogoUrl: $(\u0027closingLogoUrl\u0027).value.trim(),\n        titleBgUrl: $(\u0027titleBgUrl\u0027).value.trim(),\n        sectionBgUrl: $(\u0027sectionBgUrl\u0027).value.trim(),\n        mainBgUrl: $(\u0027mainBgUrl\u0027).value.trim(),\n        closingBgUrl: $(\u0027closingBgUrl\u0027).value.trim(),\n        driveFolderUrl: $(\u0027driveFolderUrl\u0027).value.trim(),\n        showPageNumber: $(\u0027showPageNumber\u0027).checked\n        // \n      };\n    }\nfunction applyMonochromeFilter(canvas, colorHex) {\n  const ctx \u003d canvas.getContext(\u00272d\u0027);\n  const width \u003d canvas.width;\n  const height \u003d canvas.height;\n  // \n  const imageData \u003d ctx.getImageData(0, 0, width, height);\n  const data \u003d imageData.data;\n  // \n  const targetRgb \u003d hexToRgb(colorHex);\n  if (!targetRgb) return;\n  // \n  const targetHsl \u003d rgbToHsl_Client(targetRgb.r, targetRgb.g, targetRgb.b);\n  for (let i \u003d 0; i \u003c data.length; i +\u003d 4) {\n    const r \u003d data[i];\n    const g \u003d data[i + 1];\n    const b \u003d data[i + 2];\n    const a \u003d data[i + 3];\n    // \n    if (a \u003d\u003d\u003d 0) continue;\n    // \n    const originalHsl \u003d rgbToHsl_Client(r, g, b);\n    // \n    const newRgb \u003d hslToRgb_Client(targetHsl.h, targetHsl.s, originalHsl.l);\n    data[i] \u003d newRgb.r;\n    data[i + 1] \u003d newRgb.g;\n    data[i + 2] \u003d newRgb.b;\n    // \n  }\n  // \n  ctx.putImageData(imageData, 0, 0);\n}\n// \n// \nfunction rgbToHsl_Client(r, g, b) {\n  r /\u003d 255; g /\u003d 255; b /\u003d 255;\n  const max \u003d Math.max(r, g, b), min \u003d Math.min(r, g, b);\n  let h, s, l \u003d (max + min) / 2;\n  if (max \u003d\u003d\u003d min) {\n    h \u003d s \u003d 0; \n  } else {\n    const d \u003d max - min;\n    s \u003d l \u003e 0.5 ? d / (2 - max - min) : d / (max + min);\n    switch (max) {\n      case r: h \u003d (g - b) / d + (g \u003c b ? 6 : 0); break;\n      case g: h \u003d (b - r) / d + 2; break;\n      case b: h \u003d (r - g) / d + 4; break;\n    }\n    h /\u003d 6;\n  }\n  return { h, s, l };\n}\n// \nfunction hslToRgb_Client(h, s, l) {\n  let r, g, b;\n  if (s \u003d\u003d\u003d 0) {\n    r \u003d g \u003d b \u003d l; \n  } else {\n    const hue2rgb \u003d (p, q, t) \u003d\u003e {\n      if (t \u003c 0) t +\u003d 1;\n      if (t \u003e 1) t -\u003d 1;\n      if (t \u003c 1/6) return p + (q - p) * 6 * t;\n      if (t \u003c 1/2) return q;\n      if (t \u003c 2/3) return p + (q - p) * (2/3 - t) * 6;\n      return p;\n    };\n    const q \u003d l \u003c 0.5 ? l * (1 + s) : l + s - l * s;\n    const p \u003d 2 * l - q;\n    r \u003d hue2rgb(p, q, h + 1/3);\n    g \u003d hue2rgb(p, q, h);\n    b \u003d hue2rgb(p, q, h - 1/3);\n  }\n  return { \n    r: Math.round(r * 255), \n    g: Math.round(g * 255), \n    b: Math.round(b * 255) \n  };\n}\nfunction convertSvgToBase64Png(svgString, shouldTrim \u003d false, maxWidth \u003d null, filterColor \u003d null) { // \n  return new Promise((resolve, reject) \u003d\u003e {\n    const image \u003d new Image();\n        const svgBlob \u003d new Blob([svgString], { type: \u0027image/svg+xml;charset\u003dutf-8\u0027 });\n        const url \u003d URL.createObjectURL(svgBlob);\n        image.onload \u003d () \u003d\u003e {\n          const originalCanvas \u003d document.createElement(\u0027canvas\u0027);\n          const originalCtx \u003d originalCanvas.getContext(\u00272d\u0027);\n          // \n          let originalWidth \u003d image.width;\n          let originalHeight \u003d image.height;\n          if (!originalWidth || !originalHeight || originalWidth \u003c\u003d 0 || originalHeight \u003c\u003d 0) {\n            // \n            const viewBoxMatch \u003d svgString.match(/viewBox\u003d\"([\\d\\s\\.-]+)\"/);\n            if (viewBoxMatch \u0026\u0026 viewBoxMatch[1]) {\n              const parts \u003d viewBoxMatch[1].split(\u0027 \u0027);\n              if (parts.length \u003d\u003d\u003d 4) {\n                originalWidth \u003d parseFloat(parts[2]);\n                originalHeight \u003d parseFloat(parts[3]);\n              }\n            }\n            // \n            if (!originalWidth || !originalHeight || originalWidth \u003c\u003d 0 || originalHeight \u003c\u003d 0) {\n              originalWidth \u003d 500;\n              originalHeight \u003d 300;\n            }\n          }\n          // \n          // \n          let targetWidth, targetHeight;\n          if (maxWidth !\u003d\u003d null \u0026\u0026 originalWidth \u003e maxWidth) {\n            // \n            targetWidth \u003d maxWidth;\n            targetHeight \u003d (originalHeight / originalWidth) * maxWidth;\n            // \n          } else {\n            // \n            // \n            const minSideTarget \u003d 1200; \n            const baseScale \u003d 2; // \n            // \n            const currentMinSide \u003d Math.min(originalWidth, originalHeight);\n            // \n            const requiredScale \u003d minSideTarget / currentMinSide;\n            // \n            const finalScale \u003d Math.max(baseScale, requiredScale);\n            targetWidth \u003d originalWidth * finalScale;\n            targetHeight \u003d originalHeight * finalScale;\n          }\n          originalCanvas.width \u003d targetWidth;\n          originalCanvas.height \u003d targetHeight;\n          // \n          originalCtx.drawImage(image, 0, 0, originalCanvas.width, originalCanvas.height);\n          if (filterColor) {\n        // \n        applyMonochromeFilter(originalCanvas, filterColor);\n      }\n          // \n          if (shouldTrim) {\n            // \n            try {\n              const imageData \u003d originalCtx.getImageData(0, 0, originalCanvas.width, originalCanvas.height);\n              const data \u003d imageData.data;\n              let minX \u003d originalCanvas.width, minY \u003d originalCanvas.height, maxX \u003d -1, maxY \u003d -1;\n              const alphaThreshold \u003d 10;\n              // \n              for (let y \u003d 0; y \u003c originalCanvas.height; y++) {\n                for (let x \u003d 0; x \u003c originalCanvas.width; x++) {\n                  const alpha \u003d data[(y * originalCanvas.width + x) * 4 + 3];\n                  if (alpha \u003e alphaThreshold) {\n                    if (x \u003c minX) minX \u003d x;\n                    if (x \u003e maxX) maxX \u003d x;\n                    if (y \u003c minY) minY \u003d y;\n                    if (y \u003e maxY) maxY \u003d y;\n                  }\n                }\n              }\n              // \n              if (minX \u003e maxX || minY \u003e maxY) {\n                console.warn(\u0027トリミング対象の画像が完全に透明です。元の画像を返します。\u0027);\n                URL.revokeObjectURL(url);\n                resolve(originalCanvas.toDataURL(\u0027image/png\u0027));\n                return;\n              }\n              // \n              const trimWidth \u003d maxX - minX + 1;\n              const trimHeight \u003d maxY - minY + 1;\n              // \n              const trimCanvas \u003d document.createElement(\u0027canvas\u0027);\n              trimCanvas.width \u003d trimWidth;\n              trimCanvas.height \u003d trimHeight;\n              const trimCtx \u003d trimCanvas.getContext(\u00272d\u0027);\n              // \n              trimCtx.drawImage(originalCanvas,\n                minX, minY, trimWidth, trimHeight,\n                0, 0, trimWidth, trimHeight\n              );\n              // \n              const trimmedPngDataUrl \u003d trimCanvas.toDataURL(\u0027image/png\u0027);\n              URL.revokeObjectURL(url);\n              resolve(trimmedPngDataUrl); // \n            } catch (trimError) {\n              console.error(\u0027画像のトリミング処理中にエラー:\u0027, trimError);\n              URL.revokeObjectURL(url);\n              resolve(originalCanvas.toDataURL(\u0027image/png\u0027)); // \n            }\n          } else {\n            // \n            URL.revokeObjectURL(url);\n            resolve(originalCanvas.toDataURL(\u0027image/png\u0027)); // \n          }\n          // \n        };\n        image.onerror \u003d (err) \u003d\u003e {\n          URL.revokeObjectURL(url);\n          reject(new Error(\u0027SVG画像の読み込みまたは変換に失敗しました。\u0027));\n        };\n        image.src \u003d url;\n      });\n    }\n    function applyRoundedCorners(base64DataUrl, cornerRadiusPercentage \u003d 3) {\n      return new Promise((resolve, reject) \u003d\u003e {\n        const originalImage \u003d new Image();\n        originalImage.onload \u003d () \u003d\u003e {\n          const w \u003d originalImage.width;\n          const h \u003d originalImage.height;\n          if (w \u003d\u003d\u003d 0 || h \u003d\u003d\u003d 0) {\n            reject(new Error(\u0027画像の幅または高さが0です。\u0027));\n            return;\n          }\n          // \n          const cornerRadius \u003d Math.min(w, h) * (cornerRadiusPercentage / 100);\n          // \n          const svgString \u003d `\n\u003csvg width\u003d\"${w}\" height\u003d\"${h}\" viewBox\u003d\"0 0 ${w} ${h}\" xmlns\u003d\"http://www.w3.org/2000/svg\"\u003e\n  \u003cdefs\u003e\n    \u003cclipPath id\u003d\"roundedCornersClip_gen\"\u003e\n      \u003crect x\u003d\"0\" y\u003d\"0\" width\u003d\"${w}\" height\u003d\"${h}\" rx\u003d\"${cornerRadius}\" ry\u003d\"${cornerRadius}\" /\u003e\n    \u003c/clipPath\u003e\n  \u003c/defs\u003e\n  \u003cimage href\u003d\"${base64DataUrl}\" \n         x\u003d\"0\" y\u003d\"0\" \n         width\u003d\"${w}\" \n         height\u003d\"${h}\" \n         clip-path\u003d\"url(#roundedCornersClip_gen)\" /\u003e\n\u003c/svg\u003e`;\n          // \n          const svgImage \u003d new Image();\n          const svgBlob \u003d new Blob([svgString], { type: \u0027image/svg+xml;charset\u003dutf-8\u0027 });\n          const svgUrl \u003d URL.createObjectURL(svgBlob);\n          svgImage.onload \u003d () \u003d\u003e {\n            const canvas \u003d document.createElement(\u0027canvas\u0027);\n            const ctx \u003d canvas.getContext(\u00272d\u0027);\n            canvas.width \u003d w;\n            canvas.height \u003d h;\n            ctx.clearRect(0, 0, canvas.width, canvas.height); // \n            ctx.drawImage(svgImage, 0, 0, w, h);\n            const pngDataUrl \u003d canvas.toDataURL(\u0027image/png\u0027);\n            URL.revokeObjectURL(svgUrl); // \n            resolve(pngDataUrl); // \n          };\n          svgImage.onerror \u003d (err) \u003d\u003e {\n            URL.revokeObjectURL(svgUrl);\n            reject(new Error(\u0027角丸SVGの画像への読み込みに失敗しました。\u0027));\n          };\n          svgImage.src \u003d svgUrl;\n        };\n        originalImage.onerror \u003d (err) \u003d\u003e {\n          reject(new Error(\u0027角丸加工のための元画像の読み込みに失敗しました。\u0027));\n        };\n        originalImage.src \u003d base64DataUrl;\n      });\n    }\nfunction renderDynamicSvgInIframe(dynamicSvgString, timeout \u003d 10000) {\n  return new Promise((resolve, reject) \u003d\u003e {\n    const iframe \u003d document.createElement(\u0027iframe\u0027);\n    iframe.style.display \u003d \u0027none\u0027;\n    iframe.sandbox \u003d \u0027allow-scripts\u0027;\n    let timeoutId \u003d null;\n    const messageListener \u003d (event) \u003d\u003e {\n      if (event.source \u003d\u003d\u003d iframe.contentWindow) {\n        if (event.data.type \u003d\u003d\u003d \u0027SVG_RENDERED\u0027) {\n          cleanup();\n          resolve(event.data.svg);\n        } else if (event.data.type \u003d\u003d\u003d \u0027SVG_ERROR\u0027) {\n          cleanup();\n          reject(new Error(\u0027iframe内でSVGエラーが発生しました: \u0027 + event.data.error));\n        }\n      }\n    };\n    function cleanup() {\n      if (timeoutId) clearTimeout(timeoutId);\n      window.removeEventListener(\u0027message\u0027, messageListener);\n      if (document.body.contains(iframe)) {\n        document.body.removeChild(iframe);\n      }\n    }\n    window.addEventListener(\u0027message\u0027, messageListener);\n    document.body.appendChild(iframe);\n    const iframeContent \u003d `\n      \u003c!DOCTYPE html\u003e\n      \u003chtml\u003e\n        \u003chead\u003e\u003cmeta charset\u003d\"utf-8\"\u003e\u003c/head\u003e\n        \u003cbody style\u003d\"margin:0; padding:0;\"\u003e\n          ${dynamicSvgString}\n          \u003cscript\u003e\n            setTimeout(() \u003d\u003e {\n               try {\n                const svgElement \u003d document.querySelector(\u0027svg\u0027);\n                if (svgElement) {\n                  window.parent.postMessage({ type: \u0027SVG_RENDERED\u0027, svg: svgElement.outerHTML }, \u0027*\u0027);\n                } else {\n                  window.parent.postMessage({ type: \u0027SVG_ERROR\u0027, error: \u0027SVG element not found\u0027 }, \u0027*\u0027);\n                }\n              } catch (e) {\n                window.parent.postMessage({ type: \u0027SVG_ERROR\u0027, error: e.message }, \u0027*\u0027);\n              }\n            }, 0); \n          \u003c\\/script\u003e\n        \u003c/body\u003e\n      \u003c/html\u003e\n    `;\n    iframe.srcdoc \u003d iframeContent;\n    timeoutId \u003d setTimeout(() \u003d\u003e {\n      cleanup();\n      reject(new Error(`SVGのレンダリングがタイムアウトしました (${timeout}ms)`));\n    }, timeout);\n  });\n}\n    function promptForImage(promptText) {\n      return new Promise((resolve, reject) \u003d\u003e {\n        const modal \u003d $(\u0027imagePromptModal\u0027);\n        const promptElement \u003d $(\u0027imagePromptText\u0027);\n        const dropZone \u003d $(\u0027imageDropZone\u0027);\n        const imageUpload \u003d $(\u0027imageUpload\u0027);\n        const preview \u003d $(\u0027imagePreview\u0027);\n        const dropZoneText \u003d $(\u0027dropZoneText\u0027);\n        const confirmBtn \u003d $(\u0027confirmImageBtn\u0027);\n        const cancelBtn \u003d $(\u0027cancelGenerationBtn\u0027);\n        promptElement.innerHTML \u003d `「\u003cstrong\u003e${promptText}\u003c/strong\u003e」に合致する画像をアップロードまたは貼り付けてください。`;\n        preview.style.display \u003d \u0027none\u0027; preview.src \u003d \u0027#\u0027;\n        dropZoneText.style.display \u003d \u0027block\u0027;\n        confirmBtn.disabled \u003d true;\n        modal.style.display \u003d \u0027flex\u0027;\n        let imageData \u003d null;\n        function handleFile(file) {\n          if (!file || !file.type.startsWith(\u0027image/\u0027)) {\n            showStatus(\u0027エラー: 画像ファイルを選択してください。\u0027, \u0027error\u0027); return;\n          }\n          const reader \u003d new FileReader();\n          reader.onload \u003d (e) \u003d\u003e {\n            imageData \u003d e.target.result;\n            preview.src \u003d imageData;\n            preview.style.display \u003d \u0027block\u0027;\n            dropZoneText.style.display \u003d \u0027none\u0027;\n            confirmBtn.disabled \u003d false;\n          };\n          reader.onerror \u003d () \u003d\u003e reject(new Error(\u0027ファイルの読み込みに失敗しました。\u0027));\n          reader.readAsDataURL(file);\n        }\n        const clickHandler \u003d (e) \u003d\u003e {\n          e.preventDefault(); // \n          imageUpload.click();\n        };\n        const changeHandler \u003d () \u003d\u003e { if (imageUpload.files.length \u003e 0) handleFile(imageUpload.files[0]); };\n        const dragOverHandler \u003d (e) \u003d\u003e { e.preventDefault(); dropZone.classList.add(\u0027drag-over\u0027); };\n        const dragLeaveHandler \u003d () \u003d\u003e dropZone.classList.remove(\u0027drag-over\u0027);\n        const dropHandler \u003d (e) \u003d\u003e {\n          e.preventDefault(); dropZone.classList.remove(\u0027drag-over\u0027);\n          if (e.dataTransfer.files \u0026\u0026 e.dataTransfer.files.length \u003e 0) handleFile(e.dataTransfer.files[0]);\n        };\n        const pasteHandler \u003d (e) \u003d\u003e {\n          const items \u003d (e.clipboardData || window.clipboardData).items;\n          for (const item of items) {\n            if (item.kind \u003d\u003d\u003d \u0027file\u0027 \u0026\u0026 item.type.startsWith(\u0027image/\u0027)) {\n              e.preventDefault(); handleFile(item.getAsFile()); break;\n            }\n          }\n        };\n        const confirmHandler \u003d () \u003d\u003e { cleanup(); resolve(imageData); };\n        const cancelHandler \u003d () \u003d\u003e { cleanup(); reject(new Error(\u0027画像なしで続行\u0027)); };\n        function cleanup() {\n          $(\u0027fileSelectLink\u0027).removeEventListener(\u0027click\u0027, clickHandler); // \n          imageUpload.removeEventListener(\u0027change\u0027, changeHandler);\n          dropZone.removeEventListener(\u0027dragover\u0027, dragOverHandler);\n          dropZone.removeEventListener(\u0027dragleave\u0027, dragLeaveHandler);\n          dropZone.removeEventListener(\u0027drop\u0027, dropHandler);\n          document.removeEventListener(\u0027paste\u0027, pasteHandler);\n          confirmBtn.removeEventListener(\u0027click\u0027, confirmHandler);\n          cancelBtn.removeEventListener(\u0027click\u0027, cancelHandler);\n          modal.style.display \u003d \u0027none\u0027;\n          imageUpload.value \u003d \u0027\u0027;\n        }\n        $(\u0027fileSelectLink\u0027).addEventListener(\u0027click\u0027, clickHandler); // \n        imageUpload.addEventListener(\u0027change\u0027, changeHandler);\n        dropZone.addEventListener(\u0027dragover\u0027, dragOverHandler);\n        dropZone.addEventListener(\u0027dragleave\u0027, dragLeaveHandler);\n        dropZone.addEventListener(\u0027drop\u0027, dropHandler);\n        document.addEventListener(\u0027paste\u0027, pasteHandler);\n        confirmBtn.addEventListener(\u0027click\u0027, confirmHandler);\n        cancelBtn.addEventListener(\u0027click\u0027, cancelHandler);\n      });\n    }\n    function timeStringToSeconds(timeString) {\n        const parts \u003d timeString.split(\u0027:\u0027);\n        const minutes \u003d parseInt(parts[0], 10);\n        const seconds \u003d parseFloat(parts[1]);\n        return minutes * 60 + seconds;\n    }\n    function seekToTime(video, time) {\n        return new Promise((resolve, reject) \u003d\u003e {\n            const onSeeked \u003d () \u003d\u003e {\n                video.removeEventListener(\u0027seeked\u0027, onSeeked);\n                video.removeEventListener(\u0027error\u0027, onError);\n                resolve();\n            };\n            const onError \u003d (e) \u003d\u003e {\n                video.removeEventListener(\u0027seeked\u0027, onSeeked);\n                video.removeEventListener(\u0027error\u0027, onError);\n                reject(new Error(\u0027動画のシーク中にエラーが発生しました。\u0027));\n            };\n            video.addEventListener(\u0027seeked\u0027, onSeeked);\n            video.addEventListener(\u0027error\u0027, onError);\n            video.currentTime \u003d time;\n        });\n    }\n  function secondsToTimeString(totalSeconds) {\n    if (totalSeconds \u003c 0) totalSeconds \u003d 0;\n    const minutes \u003d Math.floor(totalSeconds / 60);\n    const secondsVal \u003d totalSeconds % 60;\n    const minutesStr \u003d String(minutes).padStart(2, \u00270\u0027);\n    // \n    const secondsStr \u003d String(secondsVal.toFixed(1)).padStart(4, \u00270\u0027); \n    return `${minutesStr}:${secondsStr}`;\n  }\n  function addFrameSelectionStyles() {\n    const styleId \u003d \u0027frame-selection-styles\u0027;\n    if (document.getElementById(styleId)) return; // \n    const styles \u003d `\n      .frame-selection-grid {\n        display: grid;\n        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));\n        gap: 0.75rem;\n        max-height: none;\n        overflow-y: auto;\n        border: 1px solid var(--border-color);\n        padding: 0.75rem;\n        border-radius: var(--radius-md);\n      }\n      .frame-candidate {\n        position: relative;\n        cursor: pointer;\n      }\n      .frame-candidate img {\n        width: 100%;\n        height: auto;\n        display: block;\n        border: 3px solid transparent;\n        border-radius: var(--radius-sm);\n        transition: border-color 0.2s;\n      }\n      .frame-candidate input[type\u003d\"checkbox\"] {\n        position: absolute;\n        top: 8px;\n        left: 8px;\n        width: 20px;\n        height: 20px;\n        z-index: 2;\n        cursor: pointer;\n        accent-color: var(--primary-color);\n        filter: drop-shadow(0 0 2px rgba(0,0,0,0.7));\n      }\n      .frame-candidate input[type\u003d\"checkbox\"]:checked + img {\n        border-color: var(--primary-color);\n        box-shadow: 0 0 8px var(--primary-color);\n      }\n      .frame-enlarge-modal-overlay {\n        position: fixed;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        background-color: rgba(0, 0, 0, 0.7);\n        display: flex;\n        justify-content: center;\n        align-items: center;\n        z-index: 2000; \n      }\n      .frame-enlarge-modal-content {\n        position: relative;\n        background: var(--bg-surface);\n        padding: 1rem;\n        border-radius: var(--radius-md);\n        box-shadow: var(--shadow-md);\n        max-width: 90vw;\n        max-height: 90vh;\n        display: flex;\n        flex-direction: column;\n        gap: 1rem;\n      }\n      .frame-enlarge-modal-content img {\n        max-width: 100%;\n        max-height: 75vh;\n        object-fit: contain;\n      }\n      .frame-enlarge-modal-buttons {\n        display: flex;\n        gap: 1rem;\n        justify-content: flex-end;\n      }\n      .frame-candidate.highlighted-range::before {\n        content: \u0027\u0027;\n        position: absolute;\n        top: 0;\n        left: 0;\n        width: 100%;\n        height: 100%;\n        background-color: rgba(var(--primary-color-rgb, 66, 133, 244), 0.25);\n        border: 2px dashed var(--primary-color);\n        border-radius: var(--radius-sm);\n        box-sizing: border-box;\n        z-index: 1; \n      }\n    `;\n    const styleElement \u003d document.createElement(\u0027style\u0027);\n    styleElement.id \u003d styleId;\n    styleElement.type \u003d \u0027text/css\u0027;\n    styleElement.appendChild(document.createTextNode(styles));\n    document.head.appendChild(styleElement);\n  }\n  function promptForFrameSelection(promptText, candidateFrames) {\n      return new Promise((resolve, reject) \u003d\u003e {\n          // \n          addFrameSelectionStyles();\n          const enlargeModal \u003d document.createElement(\u0027div\u0027);\n          enlargeModal.id \u003d \u0027frameEnlargeModal\u0027;\n          enlargeModal.className \u003d \u0027frame-enlarge-modal-overlay\u0027;\n          enlargeModal.style.display \u003d \u0027none\u0027;\n          enlargeModal.innerHTML \u003d `\n            \u003cdiv class\u003d\"frame-enlarge-modal-content\"\u003e\n              \u003cimg id\u003d\"enlargedFrameImg\" src\u003d\"#\" alt\u003d\"Enlarged Frame\"\u003e\n              \u003cdiv class\u003d\"frame-enlarge-modal-buttons\"\u003e\n                 \u003cbutton id\u003d\"enlargeSelectBtn\" class\u003d\"btn btn-primary\"\u003eこの画像を追加\u003c/button\u003e\n                 \u003cbutton id\u003d\"enlargeCloseBtn\" class\u003d\"btn btn-secondary\" style\u003d\"background-color: var(--secondary-color);\"\u003e閉じる\u003c/button\u003e\n              \u003c/div\u003e\n            \u003c/div\u003e\n          `;\n          document.body.appendChild(enlargeModal);\n          const enlargeImg \u003d $(\u0027enlargedFrameImg\u0027);\n          const enlargeSelectBtn \u003d $(\u0027enlargeSelectBtn\u0027);\n          const enlargeCloseBtn \u003d $(\u0027enlargeCloseBtn\u0027);\n          // \n          const modal \u003d $(\u0027imagePromptModal\u0027);\n          const promptElement \u003d $(\u0027imagePromptText\u0027);\n          const modalContent \u003d modal.querySelector(\u0027.modal-content\u0027);\n          const originalModalStyle \u003d {\n              maxWidth: modalContent.style.maxWidth,\n              maxHeight: modalContent.style.maxHeight\n          };\n          modalContent.style.maxWidth \u003d \u002795vw\u0027;\n          modalContent.style.maxHeight \u003d \u002795vh\u0027;\n          const dropZone \u003d $(\u0027imageDropZone\u0027);\n          const preview \u003d $(\u0027imagePreview\u0027);\n          const dropZoneText \u003d $(\u0027dropZoneText\u0027);\n          const confirmBtn \u003d $(\u0027confirmImageBtn\u0027); // \n          const cancelBtn \u003d $(\u0027cancelGenerationBtn\u0027);\n          cancelBtn.style.display \u003d \u0027none\u0027;\n          let slideTitle \u003d \"該当スライド\";\n          const timestampToFind \u003d promptText;\n          try {\n            const slideDataString \u003d $(\u0027slideDataInput\u0027).value;\n            if (slideDataString) {\n                const allSlides \u003d JSON.parse(slideDataString);\n                const matchingSlide \u003d allSlides.find(slide \u003d\u003e slide.image \u003d\u003d\u003d timestampToFind);\n                if (matchingSlide \u0026\u0026 matchingSlide.title) {\n                    slideTitle \u003d matchingSlide.title;\n                } else if (matchingSlide) {\n                    slideTitle \u003d \"タイトルなしスライド\";\n                }\n            }\n          } catch (e) {\n              console.warn(\"タイトル検索のためのJSONパースに失敗:\", e.message);\n          }\n          const displayPrompt \u003d `\u003cstrong\u003e${slideTitle}\u003c/strong\u003e (タイムスタンプ: ${timestampToFind})`;\n          // \n          promptElement.innerHTML \u003d `「${displayPrompt}」に最適なフレームを \u003cstrong\u003e1枚 (静止画)\u003c/strong\u003e または \u003cstrong\u003e2枚 (アニメーション)\u003c/strong\u003e 選択してください。\u003cbr\u003e(画像クリックで拡大)`;\n          // \n          preview.style.display \u003d \u0027none\u0027;\n          dropZoneText.style.display \u003d \u0027none\u0027;\n          // \n          confirmBtn.disabled \u003d true;\n          confirmBtn.textContent \u003d \u0027画像を選択してください\u0027; // \n          // \n          dropZone.innerHTML \u003d \u0027\u0027; // \n          const gridContainer \u003d document.createElement(\u0027div\u0027);\n          gridContainer.className \u003d \u0027frame-selection-grid\u0027;\n          dropZone.appendChild(gridContainer);\n          const originalDropZoneStyle \u003d {\n              border: dropZone.style.border,\n              cursor: dropZone.style.cursor,\n              padding: dropZone.style.padding\n          };\n          dropZone.style.border \u003d \u0027none\u0027; \n          dropZone.style.cursor \u003d \u0027default\u0027;\n          dropZone.style.padding \u003d \u00270\u0027;\n          // \n          let selectedFrames \u003d []; // \n          const allCheckboxes \u003d [];\n          // \n          let currentEnlargeSelectHandler \u003d null;\n          const middleIndex \u003d Math.floor(candidateFrames.length / 2);\n          // \n          candidateFrames.forEach((frame, index) \u003d\u003e {\n              const candidateDiv \u003d document.createElement(\u0027div\u0027);\n              candidateDiv.className \u003d \u0027frame-candidate\u0027;\n              const checkbox \u003d document.createElement(\u0027input\u0027);\n              checkbox.type \u003d \u0027checkbox\u0027;\n              checkbox.id \u003d `frame-check-${index}`;\n              allCheckboxes.push(checkbox);\n              // \n              if (index \u003d\u003d\u003d middleIndex) {\n                checkbox.checked \u003d true;\n                selectedFrames.push({ ...frame, checkbox: checkbox }); // \n                updateConfirmButtonUI(selectedFrames.length); // \n              }\n              // \n              const img \u003d document.createElement(\u0027img\u0027);\n              img.src \u003d frame.data;\n              img.title \u003d `Time: ${secondsToTimeString(frame.timeSec)}`;\n              // \n              // \n              checkbox.onchange \u003d () \u003d\u003e {\n                  if (checkbox.checked) {\n                      // \n                      // \n                      selectedFrames.push({ ...frame, checkbox: checkbox });\n                      // \n                      if (selectedFrames.length \u003e 2) {\n                          // \n                          const oldestSelection \u003d selectedFrames.shift();\n                          if (oldestSelection \u0026\u0026 oldestSelection.checkbox) {\n                              oldestSelection.checkbox.checked \u003d false;\n                          }\n                      }\n                  } else {\n                      // \n                      selectedFrames \u003d selectedFrames.filter(sf \u003d\u003e sf.timeSec !\u003d\u003d frame.timeSec);\n                  }\n                  // \n                  updateConfirmButtonUI(selectedFrames.length);\n                  // \n                  updateRangeHighlighting();\n              };\n              // \n              // \n              img.onclick \u003d () \u003d\u003e {\n                  enlargeImg.src \u003d frame.data;\n                  enlargeModal.style.display \u003d \u0027flex\u0027;\n                  if (currentEnlargeSelectHandler) {\n                      enlargeSelectBtn.removeEventListener(\u0027click\u0027, currentEnlargeSelectHandler);\n                  }\n                  // \n                  currentEnlargeSelectHandler \u003d () \u003d\u003e {\n                      if (!checkbox.checked) { // \n                          checkbox.checked \u003d true;\n                          // \n                          checkbox.dispatchEvent(new Event(\u0027change\u0027));\n                      }\n                      enlargeModal.style.display \u003d \u0027none\u0027;\n                  };\n                  enlargeSelectBtn.addEventListener(\u0027click\u0027, currentEnlargeSelectHandler);\n              };\n              // \n              candidateDiv.appendChild(checkbox);\n              candidateDiv.appendChild(img);\n              gridContainer.appendChild(candidateDiv);\n          });\n          // \n          function updateConfirmButtonUI(count) {\n              if (count \u003d\u003d\u003d 0) {\n                  confirmBtn.disabled \u003d true;\n                  confirmBtn.textContent \u003d \u0027画像を選択してください\u0027;\n              } else if (count \u003d\u003d\u003d 1) {\n                  confirmBtn.disabled \u003d false;\n                  confirmBtn.textContent \u003d \u0027選択した画像を確定\u0027;\n              } else if (count \u003d\u003d\u003d 2) {\n                  confirmBtn.disabled \u003d false;\n                  confirmBtn.textContent \u003d \u0027選択範囲をアニメーションに変換\u0027;\n              }\n          }\n          function updateRangeHighlighting() {\n              const allCandidates \u003d gridContainer.querySelectorAll(\u0027.frame-candidate\u0027);\n              // \n              const selectedIndices \u003d selectedFrames.map(sf \u003d\u003e {\n                  // \n                  return parseInt(sf.checkbox.id.replace(\u0027frame-check-\u0027, \u0027\u0027), 10);\n              });\n              // \n              allCandidates.forEach(c \u003d\u003e c.classList.remove(\u0027highlighted-range\u0027));\n              // \n              if (selectedIndices.length \u003d\u003d\u003d 2) {\n                  const minIndex \u003d Math.min(selectedIndices[0], selectedIndices[1]);\n                  const maxIndex \u003d Math.max(selectedIndices[0], selectedIndices[1]);\n                  // \n                  for (let i \u003d minIndex + 1; i \u003c maxIndex; i++) {\n                      if (allCandidates[i]) {\n                          allCandidates[i].classList.add(\u0027highlighted-range\u0027);\n                      }\n                  }\n              }\n          }\n          // \n          const closeEnlargeModal \u003d () \u003d\u003e {\n              enlargeModal.style.display \u003d \u0027none\u0027;\n              if (currentEnlargeSelectHandler) {\n                  enlargeSelectBtn.removeEventListener(\u0027click\u0027, currentEnlargeSelectHandler);\n                  currentEnlargeSelectHandler \u003d null;\n              }\n          };\n          enlargeCloseBtn.onclick \u003d closeEnlargeModal;\n          enlargeModal.onclick \u003d (e) \u003d\u003e {\n              if (e.target \u003d\u003d\u003d enlargeModal) closeEnlargeModal();\n          };\n          // \n          modal.style.display \u003d \u0027flex\u0027;\n          // \n          const confirmHandler \u003d () \u003d\u003e {\n              cleanup();\n              if (selectedFrames.length \u003d\u003d\u003d 1) {\n                  // \n                  resolve({ \n                    type: \u0027static\u0027, \n                    data: selectedFrames[0].data \n                  });\n              } else if (selectedFrames.length \u003d\u003d\u003d 2) {\n                  // \n                  resolve({ \n                    type: \u0027animation\u0027, \n                    frames: [selectedFrames[0], selectedFrames[1]] // \n                  });\n              } else {\n                  // \n                  reject(new Error(\u0027選択数が不正です。\u0027));\n              }\n          };\n          // \n          const cancelHandler \u003d () \u003d\u003e { cleanup(); reject(new Error(\u0027動画なしで続行\u0027)); };\n          function cleanup() {\n              confirmBtn.removeEventListener(\u0027click\u0027, confirmHandler);\n              cancelBtn.removeEventListener(\u0027click\u0027, cancelHandler);\n              if (document.body.contains(enlargeModal)) {\n                  document.body.removeChild(enlargeModal);\n              }\n              const styleElement \u003d document.getElementById(\u0027frame-selection-styles\u0027);\n              if (styleElement) {\n                  document.head.removeChild(styleElement);\n              }\n              modal.style.display \u003d \u0027none\u0027;\n              dropZone.style.border \u003d originalDropZoneStyle.border || \u0027\u0027;\n              dropZone.style.cursor \u003d originalDropZoneStyle.cursor || \u0027\u0027;\n              dropZone.style.padding \u003d originalDropZoneStyle.padding || \u0027\u0027;\n              dropZone.innerHTML \u003d \u0027\u0027; \n              dropZone.appendChild(preview); \n              dropZone.appendChild(dropZoneText);\n              if (modalContent) {\n                  modalContent.style.maxWidth \u003d originalModalStyle.maxWidth || \u0027\u0027;\n                  modalContent.style.maxHeight \u003d originalModalStyle.maxHeight || \u0027\u0027;\n              }\n              cancelBtn.style.display \u003d \u0027\u0027;\n              confirmBtn.textContent \u003d \u0027確定\u0027;\n          }\n          confirmBtn.addEventListener(\u0027click\u0027, confirmHandler);\n          cancelBtn.addEventListener(\u0027click\u0027, cancelHandler);\n      });\n  }\nasync function createAPNGFromFrames(frames, delays, width, height) {\n    // \n    // \n    const PACO_URL \u003d \u0027https://cdn.jsdelivr.net/npm/pako@2.1.0/dist/pako.min.js\u0027;\n    const UPNG_URL \u003d \u0027https://cdn.jsdelivr.net/npm/upng-js@2.1.0/UPNG.min.js\u0027;\n    let worker \u003d null;\n    let objectUrl \u003d null;\n    try {\n        // \n        const [pakoResponse, upngResponse] \u003d await Promise.all([\n            fetch(PACO_URL),\n            fetch(UPNG_URL)\n        ]);\n        if (!pakoResponse.ok || !upngResponse.ok) {\n            throw new Error(`ライブラリのフェッチに失敗 (Pako: ${pakoResponse.status}, UPNG: ${upngResponse.status})`);\n        }\n        const pakoScript \u003d await pakoResponse.text();\n        const upngScript \u003d await upngResponse.text();\n        // \n        const workerScriptContent \u003d document.getElementById(\u0027apng-worker-script\u0027).textContent;\n        // \n        const fullWorkerScript \u003d `\n            var window \u003d self; \n            ${pakoScript}\n            ${upngScript}\n            ${workerScriptContent}\n        `;\n        // \n        const blob \u003d new Blob([fullWorkerScript], { type: \u0027application/javascript\u0027 });\n        // \n        objectUrl \u003d URL.createObjectURL(blob);\n        // \n        worker \u003d new Worker(objectUrl);\n    } catch (e) {\n        console.error(\u0027[Main] Web Workerの作成に失敗:\u0027, e);\n        // \n        throw new Error(\u0027APNG生成ワーカーの作成に失敗しました: \u0027 + e.message);\n    }\n    // \n    return new Promise((resolve, reject) \u003d\u003e {\n        const cleanup \u003d () \u003d\u003e {\n            // \n            if (worker) {\n                worker.terminate();\n            }\n            if (objectUrl) {\n                URL.revokeObjectURL(objectUrl);\n            }\n        };\n        // \n        worker.onmessage \u003d function(event) {\n            const { status, buffer, message } \u003d event.data;\n            if (status \u003d\u003d\u003d \u0027success\u0027) {\n                // \n                const blob \u003d new Blob([buffer], { type: \u0027image/png\u0027 });\n                const reader \u003d new FileReader();\n                reader.onload \u003d function(e) {\n                    cleanup();\n                    resolve(e.target.result); // \n                };\n                reader.onerror \u003d function(e) {\n                    cleanup();\n                    reject(new Error(\u0027APNGのBase64変換に失敗しました。\u0027));\n                };\n                reader.readAsDataURL(blob);\n            } else {\n                // \n                console.error(\u0027[Main] APNGエンコード失敗 (Workerより):\u0027, message);\n                cleanup();\n                reject(new Error(\u0027APNGの生成に失敗しました: \u0027 + message));\n            }\n        };\n        // \n        worker.onerror \u003d function(error) {\n            console.error(\u0027[Main] Web Worker自体でエラー:\u0027, error);\n            cleanup();\n            reject(new Error(\u0027APNG生成ワーカーの起動に失敗しました: \u0027 + error.message));\n        };\n        // \n        worker.postMessage({ frames, delays, width, height }, frames);\n    });\n}\nfunction generateAnimationJsonFrames(originalJsonString, frameCount) {\n    const frames \u003d [];\n    let originalConfig;\n    try {\n        originalConfig \u003d JSON.parse(originalJsonString);\n    } catch (e) {\n        console.error(\u0027generateAnimationJsonFrames: JSON parse error\u0027, e);\n        return [originalJsonString];\n    }\n    const chartType \u003d originalConfig.chartType;\n    const originalData \u003d originalConfig.data;\n    if (!originalData) {\n        console.warn(\u0027generateAnimationJsonFrames: No \"data\" key found\u0027, originalConfig);\n        return [originalJsonString];\n    }\n    const easeInOutCubic \u003d (t) \u003d\u003e {\n        return t \u003c 0.5 ?\n            4 * t * t * t : 1 - Math.pow(-2 * t + 2, 3) / 2;\n    };\n    // \n    const deepCopy \u003d (obj) \u003d\u003e JSON.parse(JSON.stringify(obj));\n    for (let i \u003d 0; i \u003c frameCount; i++) {\n        // \n        const progress \u003d (frameCount \u003c\u003d 1) ?\n            1.0 : (i / (frameCount - 1));\n        // \n        const easedProgress \u003d easeInOutCubic(progress);\n        // \n        const newConfig \u003d deepCopy(originalConfig);\n        const newData \u003d newConfig.data; // \n        try {\n            if (newData) {\n                // \n                newData.animation \u003d parseFloat(easedProgress.toFixed(6));\n                // \n                frames.push(JSON.stringify(newConfig));\n            } else {\n                // \n                console.warn(`generateAnimationJsonFrames: Frame ${i} has no \"data\" key.`);\n                frames.push(originalJsonString);\n            }\n        } catch (e) {\n            console.warn(`generateAnimationJsonFrames: Error processing frame ${i}`, e);\n            frames.push(originalJsonString); // \n        }\n    }\n    // \n    if (frames.length \u003d\u003d\u003d 0) {\n        frames.push(originalJsonString);\n    }\n    return frames;\n}\n    function base64FramesToArrayBuffers(pngFramesBase64) {\n        return new Promise((resolve, reject) \u003d\u003e {\n            if (!pngFramesBase64 || pngFramesBase64.length \u003d\u003d\u003d 0) {\n                reject(new Error(\u0027base64FramesToArrayBuffers: 入力フレームがありません。\u0027));\n                return;\n            }\n            const canvas \u003d document.createElement(\u0027canvas\u0027);\n            const ctx \u003d canvas.getContext(\u00272d\u0027);\n            const frames \u003d []; // \n            let width \u003d 0;\n            let height \u003d 0;\n            let loadedCount \u003d 0;\n            const images \u003d []; // \n            pngFramesBase64.forEach((base64, index) \u003d\u003e {\n                const img \u003d new Image();\n                images[index] \u003d img; // \n                img.onload \u003d () \u003d\u003e {\n                    loadedCount++;\n                    if (index \u003d\u003d\u003d 0) {\n                        // \n                        width \u003d img.width;\n                        height \u003d img.height;\n                        canvas.width \u003d width;\n                        canvas.height \u003d height;\n                    }\n                    // \n                    if (loadedCount \u003d\u003d\u003d pngFramesBase64.length) {\n                        // \n                        images.forEach(loadedImg \u003d\u003e {\n                            ctx.clearRect(0, 0, width, height); // \n                            ctx.drawImage(loadedImg, 0, 0, width, height);\n                            const imageData \u003d ctx.getImageData(0, 0, width, height);\n                            frames.push(imageData.data.buffer);\n                        });\n                        resolve({ frames: frames, width: width, height: height });\n                    }\n                };\n                img.onerror \u003d () \u003d\u003e {\n                    reject(new Error(`base64FramesToArrayBuffers: フレーム ${index} の画像読み込みに失敗しました。`));\n                };\n                img.src \u003d base64;\n            });\n        });\n    }\n  async function extractFrames(videoFile, timestamps, quality \u003d 480) {\n    const video \u003d document.createElement(\u0027video\u0027);\n    video.muted \u003d true;\n    // \n    const hiResCanvas \u003d document.createElement(\u0027canvas\u0027);\n    const hiResContext \u003d hiResCanvas.getContext(\u00272d\u0027);\n    const extractedImages \u003d [];\n    const videoUrl \u003d URL.createObjectURL(videoFile);\n    video.src \u003d videoUrl;\n    return new Promise((resolve, reject) \u003d\u003e {\n        video.addEventListener(\u0027loadedmetadata\u0027, async () \u003d\u003e {\n            try {\n                // \n                hiResCanvas.width \u003d video.videoWidth;\n                hiResCanvas.height \u003d video.videoHeight;\n                const videoDuration \u003d video.duration;\n                // \n                for (const timestamp of timestamps) {\n                    const centerTimeSec \u003d timeStringToSeconds(timestamp);\n                    const timesToCaptureSec \u003d [];\n                    // \n                    for (let i \u003d -5; i \u003c\u003d 5; i++) {\n                        const captureTimeSec \u003d centerTimeSec + i;\n                        if (captureTimeSec \u003e\u003d 0 \u0026\u0026 captureTimeSec \u003c\u003d videoDuration) {\n                            timesToCaptureSec.push(captureTimeSec);\n                        }\n                    }\n                    const candidateFrames \u003d [];\n                    showStatus(`フレーム候補を抽出中 (${timestamp} 付近)...`, \u0027info\u0027, 10000);\n                    // \n                    for (const timeSec of timesToCaptureSec) {\n                        try {\n                             await seekToTime(video, timeSec);\n                             // \n                             hiResContext.drawImage(video, 0, 0, hiResCanvas.width, hiResCanvas.height);\n                             const dataUrl \u003d hiResCanvas.toDataURL(\u0027image/jpeg\u0027, 0.9);\n                             candidateFrames.push({ timeSec: timeSec, data: dataUrl });\n                        } catch (seekError) {\n                             console.warn(`時間 ${timeSec}秒 のシークまたは描画に失敗しました。`, seekError);\n                        }\n                    }\n                    if (candidateFrames.length \u003d\u003d\u003d 0) {\n                         console.warn(`指定時間 ${timestamp} 付近のフレーム抽出に失敗しました。スキップします。`);\n                         continue;\n                    }\n                    // \n                    showStatus(`「${timestamp}」のフレームを選択してください...`, \u0027info\u0027, 30000);\n                    const selectionResult \u003d await promptForFrameSelection(timestamp, candidateFrames);\n                    if (selectionResult.type \u003d\u003d\u003d \u0027static\u0027) {\n                        // \n                        extractedImages.push({ \n                          timestamp: timestamp, \n                          data: selectionResult.data, // \n                          isAnimation: false \n                        });\n                    } else if (selectionResult.type \u003d\u003d\u003d \u0027animation\u0027) {\n                        // \n                        const frame1 \u003d selectionResult.frames[0];\n                        const frame2 \u003d selectionResult.frames[1];\n                        const startTime \u003d Math.min(frame1.timeSec, frame2.timeSec);\n                        const endTime \u003d Math.max(frame1.timeSec, frame2.timeSec);\n                        // \n                        // \n                          const duration \u003d Math.max(0.1, endTime - startTime); // \n                          const FPS_TARGET \u003d 10; // \n                          const MAX_FRAMES \u003d 100; // \n                          let frameCount;\n                          let delayMs; // \n                          // \n                          const idealFrameCount \u003d Math.max(2, Math.round(duration * FPS_TARGET));\n                          if (idealFrameCount \u003e MAX_FRAMES) {\n                              // \n                              // \n                              frameCount \u003d MAX_FRAMES;\n                              // \n                              delayMs \u003d Math.round((duration * 1000) / frameCount);\n                          } else {\n                              // \n                              // \n                              frameCount \u003d idealFrameCount;\n                              // \n                              delayMs \u003d Math.round(1000 / FPS_TARGET);\n                          }\n                        // const MIN_DIMENSION_TARGET \u003d 720; // \n                        const MIN_DIMENSION_TARGET \u003d quality; // \n                        const originalWidth \u003d video.videoWidth;\n                        const originalHeight \u003d video.videoHeight;\n                        // \n                        const aspectRatio \u003d originalWidth / originalHeight; \n                        let newWidth, newHeight;\n                        if (originalWidth \u003c originalHeight) {\n                            // \n                            newWidth \u003d MIN_DIMENSION_TARGET;\n                            newHeight \u003d newWidth / aspectRatio; // \n                        } else {\n                            // \n                            newHeight \u003d MIN_DIMENSION_TARGET;\n                            newWidth \u003d newHeight * aspectRatio; // \n                        }\n                        const animCanvas \u003d document.createElement(\u0027canvas\u0027);\n                        animCanvas.width \u003d Math.round(newWidth);\n                        animCanvas.height \u003d Math.round(newHeight);\n                        showStatus(`動画からアニメーションを生成中...`, \u0027info\u0027, 20000);\n                        // \n                        const animData \u003d await extractFramesForAnimation(\n                          video, \n                          animCanvas, // \n                          startTime, \n                          endTime, \n                          frameCount, \n                          delayMs\n                        );\n                        if (animData.frames.length \u003d\u003d\u003d 0) {\n                          throw new Error(\u0027アニメーションフレームの抽出に失敗しました。\u0027);\n                        }\n                        //showStatus(\u0027APNGに変換中...\u0027, \u0027info\u0027, 30000);\n                        // \n                        const apngBase64 \u003d await createAPNGFromFrames(\n                          animData.frames, \n                          animData.delays, \n                          animCanvas.width,  // \n                          animCanvas.height  // \n                        );\n                        extractedImages.push({ \n                          timestamp: timestamp, \n                          data: apngBase64,\n                          isAnimation: true\n                        });\n                    }\n                }\n                URL.revokeObjectURL(videoUrl);\n                resolve(extractedImages);\n            } catch (error) {\n                URL.revokeObjectURL(videoUrl);\n                reject(error);\n            }\n        });\n        video.addEventListener(\u0027error\u0027, (e) \u003d\u003e {\n            URL.revokeObjectURL(videoUrl);\n            reject(new Error(\u0027動画ファイルの読み込みに失敗しました。\u0027));\n        });\n    });\n  }\n    async function extractFramesForAnimation(video, canvas, startTimeSec, endTimeSec, frameCount, delayMs) {\n      const context \u003d canvas.getContext(\u00272d\u0027);\n      const frames \u003d []; // \n      const delays \u003d []; // \n      const duration \u003d endTimeSec - startTimeSec;\n      if (duration \u003c 0 || frameCount \u003c 2) {\n        // \n        console.warn(\u0027アニメーションフレーム抽出リクエストが不正です。\u0027, {duration, frameCount});\n        return { frames: [], delays: [] };\n      }\n      for (let i \u003d 0; i \u003c frameCount; i++) {\n        // \n        const progress \u003d (frameCount \u003d\u003d\u003d 1) ? 0 : (i / (frameCount - 1));\n        const timeSec \u003d startTimeSec + (duration * progress);\n        try {\n          // \n          await seekToTime(video, timeSec);\n          // \n          context.drawImage(video, 0, 0, canvas.width, canvas.height);\n          // \n          const imageData \u003d context.getImageData(0, 0, canvas.width, canvas.height);\n          // \n          frames.push(imageData.data.buffer);\n          delays.push(delayMs);\n        } catch (seekError) {\n          console.warn(`アニメーションフレームの時間 ${timeSec.toFixed(2)}s のシークまたは描画に失敗しました。`, seekError);\n          // \n        }\n      }\n      return { frames, delays };\n    }\n    function promptForVideo() {\n      return new Promise((resolve, reject) \u003d\u003e {\n        // \n        const modal \u003d $(\u0027videoPromptModal\u0027);\n        const promptElement \u003d $(\u0027videoPromptText\u0027);\n        const dropZone \u003d $(\u0027videoDropZone\u0027);\n        const videoUpload \u003d $(\u0027videoUpload\u0027); // \n        const preview \u003d $(\u0027videoPreview\u0027); // \n        const dropZoneText \u003d $(\u0027videoDropZoneText\u0027);\n        const qualityContainer \u003d $(\u0027videoQualityContainer\u0027); \n        const qualitySelect \u003d $(\u0027videoQualitySelect\u0027);\n        const fileSelectLink \u003d $(\u0027fileSelectLinkVideo\u0027); // \n        const confirmBtn \u003d $(\u0027confirmVideoBtn\u0027);\n        const cancelBtn \u003d $(\u0027cancelVideoBtn\u0027);\n        // \n        promptElement.innerHTML \u003d `タイムスタンプから画像を切り出すための\u003cstrong\u003e動画ファイル\u003c/strong\u003eを選択してください。`;\n        // \n        preview.style.display \u003d \u0027none\u0027; \n        preview.src \u003d \u0027\u0027; // \n        dropZoneText.style.display \u003d \u0027block\u0027;\n        if(qualityContainer) qualityContainer.style.display \u003d \u0027none\u0027;\n        confirmBtn.disabled \u003d true;\n        modal.style.display \u003d \u0027flex\u0027;\n        let videoFile \u003d null; // \n        // \n        function handleFile(file) {\n          if (!file || !file.type.startsWith(\u0027video/\u0027)) { // \n            showStatus(\u0027エラー: 動画ファイルを選択してください。\u0027, \u0027error\u0027);\n            return;\n          }\n          videoFile \u003d file; // \n          // \n          const reader \u003d new FileReader();\n          reader.onload \u003d (e) \u003d\u003e {\n            preview.src \u003d e.target.result; // \n            preview.style.display \u003d \u0027block\u0027;\n            dropZoneText.style.display \u003d \u0027none\u0027;\n            if(qualityContainer) qualityContainer.style.display \u003d \u0027block\u0027;\n            confirmBtn.disabled \u003d false;\n          };\n          reader.onerror \u003d () \u003d\u003e reject(new Error(\u0027ファイルの読み込みに失敗しました。\u0027));\n          reader.readAsDataURL(file);\n        }\n        // \n        const clickHandler \u003d (e) \u003d\u003e {\n          e.preventDefault(); // \n          videoUpload.click(); // \n        };\n        const changeHandler \u003d () \u003d\u003e { \n          if (videoUpload.files.length \u003e 0) handleFile(videoUpload.files[0]); \n        };\n        const dragOverHandler \u003d (e) \u003d\u003e { e.preventDefault(); dropZone.classList.add(\u0027drag-over\u0027); };\n        const dragLeaveHandler \u003d () \u003d\u003e dropZone.classList.remove(\u0027drag-over\u0027);\n        const dropHandler \u003d (e) \u003d\u003e {\n          e.preventDefault();\n          dropZone.classList.remove(\u0027drag-over\u0027);\n          if (e.dataTransfer.files \u0026\u0026 e.dataTransfer.files.length \u003e 0) handleFile(e.dataTransfer.files[0]);\n        };\n        const pasteHandler \u003d (e) \u003d\u003e {\n          const items \u003d (e.clipboardData || window.clipboardData).items;\n          for (const item of items) {\n            if (item.kind \u003d\u003d\u003d \u0027file\u0027 \u0026\u0026 item.type.startsWith(\u0027video/\u0027)) { // \n              e.preventDefault();\n              handleFile(item.getAsFile()); \n              break;\n            }\n          }\n        };\n        // \n        const confirmHandler \u003d () \u003d\u003e { \n          cleanup();\n          const quality \u003d qualitySelect ? parseInt(qualitySelect.value, 10) : 480;\n          resolve({ file: videoFile, quality: quality });\n        };\n        const cancelHandler \u003d () \u003d\u003e { \n          cleanup(); \n          reject(new Error(\u0027動画なしで続行\u0027)); \n        };\n        function cleanup() {\n          fileSelectLink.removeEventListener(\u0027click\u0027, clickHandler); // \n          videoUpload.removeEventListener(\u0027change\u0027, changeHandler); // \n          dropZone.removeEventListener(\u0027dragover\u0027, dragOverHandler);\n          dropZone.removeEventListener(\u0027dragleave\u0027, dragLeaveHandler);\n          dropZone.removeEventListener(\u0027drop\u0027, dropHandler);\n          document.removeEventListener(\u0027paste\u0027, pasteHandler);\n          confirmBtn.removeEventListener(\u0027click\u0027, confirmHandler);\n          cancelBtn.removeEventListener(\u0027click\u0027, cancelHandler);\n          modal.style.display \u003d \u0027none\u0027;\n          videoUpload.value \u003d \u0027\u0027; // \n          // \n          if (preview.src) {\n             // \n             preview.src \u003d \u0027\u0027;\n          }\n        }\n        fileSelectLink.addEventListener(\u0027click\u0027, clickHandler); // \n        videoUpload.addEventListener(\u0027change\u0027, changeHandler); // \n        dropZone.addEventListener(\u0027dragover\u0027, dragOverHandler);\n        dropZone.addEventListener(\u0027dragleave\u0027, dragLeaveHandler);\n        dropZone.addEventListener(\u0027drop\u0027, dropHandler);\n        document.addEventListener(\u0027paste\u0027, pasteHandler);\n        confirmBtn.addEventListener(\u0027click\u0027, confirmHandler);\n        cancelBtn.addEventListener(\u0027click\u0027, cancelHandler);\n      });\n    }\n// \n  function calculateTextWidthPt(text, fontSizePt, fontFamily, fontWeight \u003d \u0027normal\u0027) {\n    try {\n      const canvas \u003d document.createElement(\u0027canvas\u0027);\n      const context \u003d canvas.getContext(\u00272d\u0027);\n      // \n      const fontSizePx \u003d fontSizePt * (96 / 72);\n      // \n      context.font \u003d `${fontWeight} ${fontSizePx}px \"${fontFamily}\"`;\n      // \n      const metrics \u003d context.measureText(text || \u0027\u0027); // \n      const widthPx \u003d metrics.width;\n      // \n      return widthPx * 0.75;\n    } catch (e) {\n      console.error(\"Text width calculation error:\", e);\n      return null; // \n    }\n  }\n// \nasync function generate() {\n  const generateBtn \u003d $(\u0027generateBtn\u0027);\n  // \n  if (SlideEditor \u0026\u0026 SlideEditor.isEditorActive()) {\n      try {\n          const currentEditorData \u003d SlideEditor.getSlideData();\n          const jsonString \u003d JSON.stringify(currentEditorData, null, 2); // \n          $(\u0027slideDataInput\u0027).value \u003d jsonString;\n      } catch (e) {\n          console.error(\u0027[generate] SlideEditorデータのJSON文字列化に失敗:\u0027, e);\n          showJsonErrorModal(\u0027編集内容のJSON変換に失敗しました: \u0027 + e.message); // \n          return; // \n      }\n  }\n  // \n  const slideDataString \u003d $(\u0027slideDataInput\u0027).value;\n  if (!slideDataString.trim()) {\n    // \n    showStatus(\u0027エラー: スライド構成データが空です。\u0027, \u0027error\u0027); \n    console.error(\u0027[generate] エラー: スライド構成データが空です。\u0027);\n    return;\n  }\n  let slideData;\n  try {\n    slideData \u003d JSON.parse(slideDataString);\n    if (!Array.isArray(slideData)) throw new Error(\u0027slideDataは配列である必要があります\u0027);\n    // \n    slideData \u003d filterEmptyStringsInArrays(slideData);\n    // \n  } catch (e) {\n    showJsonErrorModal(\u0027JSONパースエラー: \u0027 + e.message); \n    console.error(\u0027[generate] JSONパースエラー:\u0027, e.message);\n    return; \n  }\n  const settings \u003d getCurrentSettings();\n  generateBtn.disabled \u003d true;\n  startButtonTimer(generateBtn);\n  try {\n    if (ENABLE_CREDIT_IMAGE \u003d\u003d\u003d true) {\n          const statusId \u003d showStatus(\u0027クレジット画像を生成中...\u0027, \u0027info\u0027, 10000);\n          try {\n            // \n            const creditText \u003d CREDIT_TEXT_OPTIONS[Math.floor(Math.random() * CREDIT_TEXT_OPTIONS.length)];\n            // \n            const creditSvgString \u003d generateCreditSvg(creditText, settings.primaryColor);\n            // \n            const creditPngBase64 \u003d await convertSvgToBase64Png(creditSvgString, true);\n            // \n            settings.creditImageBase64 \u003d creditPngBase64;\n            if (statusId) { const el \u003d $(statusId); if (el) el.remove(); }\n          } catch (e) {\n            console.error(\u0027[generate] クレジット画像の生成に失敗:\u0027, e);\n            showStatus(\u0027警告: クレジット画像の生成に失敗しました。\u0027, \u0027error\u0027, 5000);\n            settings.creditImageBase64 \u003d null; // \n            if (statusId) { const el \u003d $(statusId); if (el) el.remove(); }\n          }\n        } else {\n          settings.creditImageBase64 \u003d null;\n        }\n    let presentationUrl \u003d null;\n    let isNewPresentation \u003d false;\n    // \n    let presentationId \u003d null;\n    if (lastGeneratedSlideUrl) {\n      const match \u003d lastGeneratedSlideUrl.match(/\\/d\\/([a-zA-Z0-9_-]+)|\\?id\u003d([a-zA-Z0-9_-]+)/);\n      if (match \u0026\u0026 (match[1] || match[2])) {\n        presentationId \u003d match[1] || match[2];\n      } else {\n        console.warn(\u0027[generate] URLからIDの抽出に失敗しました。新規作成します。\u0027);\n      }\n    } else {\n    }\n    // \n    let imageUpdateOption \u003d \u0027update\u0027; // \n    if (presentationId) {\n      // \n      // \n    } else {\n      // \n      imageUpdateOption \u003d \u0027update\u0027; // \n    }\n    // \n    if (!presentationId) {\n      isNewPresentation \u003d true;\n      const statusId \u003d showStatus(\u0027Googleスライドファイルを作成しています...\u0027, \u0027info\u0027, 15000);\n      try {\n        // \n        presentationUrl \u003d await new Promise((resolve, reject) \u003d\u003e {\n          google.script.run\n            .withSuccessHandler(resolve)\n            .withFailureHandler(reject)\n            .createBlankPresentation(slideData, settings); // \n        });\n        if (statusId) { const el \u003d $(statusId); if (el) el.remove(); } // \n        lastGeneratedSlideUrl \u003d presentationUrl;\n        // \n        const match \u003d presentationUrl.match(/\\/d\\/([a-zA-Z0-9_-]+)|\\?id\u003d([a-zA-Z0-9_-]+)/);\n        if (match \u0026\u0026 (match[1] || match[2])) {\n          presentationId \u003d match[1] || match[2];\n        } else {\n          throw new Error(\u0027先行作成されたスライドURLからIDを抽出できませんでした。\u0027);\n        }\n        // \n        showPreviewPane();\n        $(\u0027previewOverlay\u0027).classList.add(\u0027loading\u0027);\n        // \n        imageUpdateOption \u003d \u0027update\u0027;\n      } catch (blankCreateError) {\n        if (statusId) { const el \u003d $(statusId); if (el) el.remove(); }\n        console.error(\u0027[generate] 空のスライドの先行作成に失敗:\u0027, blankCreateError);\n        showStatus(\u0027エラー: スライドの先行作成に失敗しました: \u0027 + (blankCreateError.message || blankCreateError), \u0027error\u0027, 8000);\n        // \n        return; // \n      }\n    }\n    // \n    // \n    showStatus(\u0027スライド素材の準備中...\u0027, \u0027info\u0027, 3000);\n    try {\n      let titlesCalculated \u003d 0;\n      slideData.forEach((slide, index) \u003d\u003e {\n        const configSizes \u003d typeof CONFIG !\u003d\u003d \u0027undefined\u0027 ? CONFIG.FONTS.sizes : {};\n        const fontFamily \u003d settings.fontFamily || \u0027Noto Sans JP\u0027;\n        if (slide \u0026\u0026 typeof slide.title \u003d\u003d\u003d \u0027string\u0027 \u0026\u0026 slide.title.trim() !\u003d\u003d \u0027\u0027) {\n          let fontSizePt;\n          let fontWeight \u003d \u0027bold\u0027;\n          if (slide.type \u003d\u003d\u003d \u0027title\u0027) fontSizePt \u003d configSizes.title || 41;\n          else if (slide.type \u003d\u003d\u003d \u0027section\u0027) fontSizePt \u003d configSizes.sectionTitle || 38;\n          else fontSizePt \u003d configSizes.contentTitle || 24;\n          const widthPt \u003d calculateTextWidthPt(slide.title, fontSizePt, fontFamily, fontWeight);\n          if (widthPt !\u003d\u003d null) {\n            slide._title_widthPt \u003d widthPt;\n            titlesCalculated++;\n          } else \n            console.warn(`[generate] スライド ${index + 1}: Title 幅計算失敗`);\n        }\n        if (slide \u0026\u0026 typeof slide.subhead \u003d\u003d\u003d \u0027string\u0027 \u0026\u0026 slide.subhead.trim() !\u003d\u003d \u0027\u0027) {\n          const fontSizePt \u003d configSizes.subhead ||\n            16;\n          const fontWeight \u003d \u0027normal\u0027;\n          const widthPt \u003d calculateTextWidthPt(slide.subhead, fontSizePt, fontFamily, fontWeight);\n          if (widthPt !\u003d\u003d null) {\n            slide._subhead_widthPt \u003d widthPt;\n          } else console.warn(`[generate] スライド ${index + 1}: Subhead 幅計算失敗`);\n        }\n      });\n    } catch (e) {\n      console.error(\u0027[generate] テキスト幅計算中にエラー:\u0027, e);\n      showStatus(\u0027警告: テキスト幅の計算中にエラーが発生しました。処理を続行します。\u0027, \u0027error\u0027, 5000);\n    }\n    // \n    if (imageUpdateOption \u003d\u003d\u003d \u0027update\u0027) {\n      //showStatus(\u0027セクション番号画像を生成中...\u0027, \u0027info\u0027, 5000);\n      try {\n        const ghostSettings \u003d {\n          baseFrequency: 0.01,\n          colorType: \u0027gray\u0027,\n          alphaSlope: 0.50,\n          contrastSlope: 1.0,\n          frontColor: settings.primaryColor,\n          frontAlpha: 0.15\n        };\n        slideData \u003d await generateGhostNumberImages(slideData, ghostSettings);\n      } catch (e) {\n        console.error(\u0027[generate] ゴースト番号画像生成プロセス全体でエラー:\u0027, e);\n        showStatus(\u0027警告: セクション番号の画像生成に失敗。テキストで代替します。\u0027, \u0027error\u0027, 5000);\n      }\n    } else {\n    }\n    // \n    if (imageUpdateOption \u003d\u003d\u003d \u0027update\u0027) {\n      //showStatus(\u0027Triangle用矢印画像を生成中...\u0027, \u0027info\u0027, 10000);\n      let triangleArrowData \u003d {};\n      try {\n        triangleArrowData \u003d await generateTriangleArrowImages(settings);\n        settings.triangleArrows \u003d triangleArrowData;\n      } catch (e) {\n        console.error(\u0027[generate] Triangle矢印画像生成プロセス全体でエラー:\u0027, e);\n        showStatus(\u0027警告: Triangle用矢印画像の生成に失敗。代替描画されます。\u0027, \u0027error\u0027, 5000);\n        settings.triangleArrows \u003d null;\n      }\n    } else {\n      settings.triangleArrows \u003d null;\n    }\n    // \n    const extractedId \u003d ((url) \u003d\u003e {\n      if (!url) return null;\n      const drivePatterns \u003d [\n        /\\/folders\\/([a-zA-Z0-9_-]+)/,\n        /\\?id\u003d([a-zA-Z0-9_-]+)/\n      ];\n      for (const pattern of drivePatterns) {\n        const match \u003d url.match(pattern);\n        if (match \u0026\u0026 match[1]) return match[1];\n      }\n      if (/^[a-zA-Z0-9_-]{25,}$/.test(url)) return url;\n      return null;\n    })(settings.driveFolderUrl);\n    const isMyDriveUrl \u003d settings.driveFolderUrl.includes(\u0027/drive/my-drive\u0027);\n    if (settings.driveFolderUrl \u0026\u0026 !extractedId \u0026\u0026 !isMyDriveUrl) {\n      showStatus(\u0027エラー: 正しいGoogleドライブフォルダURLまたはIDを入力してください。\u0027, \u0027error\u0027);\n      console.error(\u0027[generate] エラー: 不正なドライブフォルダURL:\u0027, settings.driveFolderUrl);\n      generateBtn.disabled \u003d false;\n      return;\n    }\n    settings.driveFolderId \u003d extractedId;\n    // \n    let finalSlideDataString \u003d slideDataString;\n    if (imageUpdateOption \u003d\u003d\u003d \u0027update\u0027) {\n      const urlRegex \u003d /^(https?:\\/\\/|data:image\\/)/;\n      const timestampRegex \u003d /^\\d{2}:\\d{2}(\\.\\S)?.*$/;;\n      const svgRegex \u003d /^\\s*\u003csvg/i;\n      const timestamps \u003d new Set();\n      const textPromptsMap \u003d new Map();\n      const svgCodes \u003d new Set();\n      const chartJsons \u003d new Set();\n      slideData.forEach(slide \u003d\u003e {\n        const imageValue \u003d slide.image;\n        let identifiedType \u003d null;\n        if (typeof imageValue \u003d\u003d\u003d \u0027string\u0027 \u0026\u0026 imageValue.trim() !\u003d\u003d \u0027\u0027) {\n          const trimmedValue \u003d imageValue.trim();\n          if (svgRegex.test(trimmedValue)) identifiedType \u003d \u0027svg\u0027;\n          else if (timestampRegex.test(trimmedValue)) identifiedType \u003d \u0027timestamp\u0027;\n          else if (urlRegex.test(trimmedValue)) identifiedType \u003d \u0027url\u0027;\n          else if (trimmedValue.startsWith(\u0027{\u0027)) {\n            try {\n              const parsedJson \u003d JSON.parse(trimmedValue);\n              identifiedType \u003d (parsedJson \u0026\u0026 typeof parsedJson \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026 parsedJson.chartType) ? \u0027chartJson\u0027 : \u0027prompt\u0027;\n            } catch (e) {\n              identifiedType \u003d \n\u0027prompt\u0027;\n             }\n          } else identifiedType \u003d \u0027prompt\u0027;\n        } else if (typeof imageValue \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026 imageValue !\u003d\u003d null \u0026\u0026 imageValue.chartType) {\n          identifiedType \u003d \u0027chartObject\u0027;\n        }\n        switch (identifiedType) {\n          case \u0027svg\u0027:\n            svgCodes.add(imageValue.replace(/\\u00A0/g, \u0027 \u0027));\n            break;\n          case \u0027timestamp\u0027:\n            timestamps.add(imageValue);\n            break;\n          case \u0027chartJson\u0027:\n            chartJsons.add(imageValue);\n            break;\n          case \u0027chartObject\u0027:\n            try {\n              chartJsons.add(JSON.stringify(imageValue));\n            } catch (e) {\n              console.error(\"chartObjectの文字列化失敗:\", imageValue, e);\n            }\n            break;\n          case \u0027prompt\u0027:\n            const shouldRound \u003d !(slide.type \u003d\u003d\u003d \u0027fullImage\u0027 || slide.isSummary);\n            // \n            if (textPromptsMap.has(imageValue)) {\n                if (!shouldRound) textPromptsMap.set(imageValue, false);\n            } else {\n                textPromptsMap.set(imageValue, shouldRound);\n            }\n            break;\n        }\n      });\n      const timestampsToExtract \u003d Array.from(timestamps);\n      const promptsToProcess \u003d Array.from(textPromptsMap.keys());\n      const svgsToConvert \u003d Array.from(svgCodes);\n      const jsonsToConvert \u003d Array.from(chartJsons);\n      let allImagesToUpload \u003d [];\n      const processedToOriginalJsonMap \u003d new Map();\n      // \n      // \n      if (jsonsToConvert.length \u003e 0) {\n        const graphTheme \u003d settings.graphColorTheme;\n        let processedJsonsForServer \u003d jsonsToConvert;\n        if (graphTheme !\u003d\u003d \u0027original\u0027) {\n          let replacementColor;\n          switch (graphTheme) {\n            case \u0027primary\u0027:\n              replacementColor \u003d settings.primaryColor;\n              break;\n            case \u0027gemini\u0027:\n              replacementColor \u003d \"#gemini\";\n              break;\n            case \u0027night\u0027:\n              replacementColor \u003d \"#night\";\n              break;\n          }\n          processedJsonsForServer \u003d jsonsToConvert.map(originalJsonString \u003d\u003e {\n            try {\n              const chartData \u003d JSON.parse(originalJsonString);\n              if (chartData \u0026\u0026 chartData.data) chartData.data.colors \u003d replacementColor;\n              const processedJsonString \u003d JSON.stringify(chartData);\n              processedToOriginalJsonMap.set(originalJsonString, processedJsonString);\n              return processedJsonString;\n            } catch (e) {\n              console.warn(\u0027グラフJSONの色置換失敗。元データ使用:\u0027, e.message, originalJsonString.substring(0, 50));\n              processedToOriginalJsonMap.set(originalJsonString, \noriginalJsonString);\n              return originalJsonString;\n            }\n           });\n        } else {\n          jsonsToConvert.forEach(originalJsonString \u003d\u003e processedToOriginalJsonMap.set(originalJsonString, originalJsonString));\n        }\n        try {\n          const convertedSvgItems \u003d await new Promise((resolve, reject) \u003d\u003e {\n            google.script.run\n              .withSuccessHandler(resolve)\n              .withFailureHandler(reject)\n              .convertJsonToSvgBatch(processedJsonsForServer);\n          });\n          const animationEnabled \u003d settings.enableGraphAnimation;\n          const MAX_ANIMATION_WIDTH \u003d 440;\n          // \n          // \n          if (animationEnabled) {\n            showStatus(\u0027アニメーショングラフを生成中...\u0027, \u0027info\u0027, 10000);\n          }\n          // \n          const animationFrames \u003d 11;\n          // \n          const animationDurationMs \u003d 1500;\n          // \n          const animationEndDelayMs \u003d 8500;\n          // \n          const frameDelayMs \u003d animationDurationMs / (animationFrames - 1);\n          // \n          const delays \u003d [];\n          for (let i \u003d 0; i \u003c animationFrames - 1; i++) {\n            delays.push(Math.round(frameDelayMs));\n            // \n          }\n          delays.push(animationEndDelayMs);\n          // \n          // \n          const svgMap \u003d new Map();\n          for (const item of convertedSvgItems) {\n            if (item.svg) {\n              svgMap.set(item.key, item.svg);\n              // \n            } else {\n              console.error(`[generate] グラフJSON -\u003e SVG変換エラー (サーバー): ${item.error}`, item.key.substring(0, 50));\n              showStatus(`グラフ変換エラー: ${item.error}`, \u0027error\u0027);\n            }\n          }\n          const chartConversionPromises \u003d jsonsToConvert.map(async (originalJsonString) \u003d\u003e {\n            const processedJsonString \u003d processedToOriginalJsonMap.get(originalJsonString);\n            if (!processedJsonString || !svgMap.has(processedJsonString)) {\n              console.warn(`[generate] svgMapにキーが見つかりません (Key: ${processedJsonString ? processedJsonString.substring(0,50) : originalJsonString.substring(0,50)}...)`);\n              return null;\n            }\n            // \n            const svgString \u003d svgMap.get(processedJsonString);\n            const originalJsonKey \u003d originalJsonString;\n            // \n            if (!animationEnabled) {\n              try {\n                 const staticSvg \u003d await renderDynamicSvgInIframe(svgString); \n                const pngData \u003d await convertSvgToBase64Png(staticSvg);\n                return {\n                  key: originalJsonKey, \n                  data: pngData,\n                  type: \u0027chart\u0027\n                };\n              } catch (pngError) {\n                console.error(`[generate] グラフSVG -\u003e PNG変換エラー (クライアント): ${pngError.message}`, originalJsonString.substring(0, 50));\n                showStatus(`グラフ画像変換エラー: ${pngError.message}`, \u0027error\u0027);\n                return null;\n              }\n            }\n            // \n            // \n            try {\n              // \n              const jsonFramesStrings \u003d generateAnimationJsonFrames(processedJsonString, animationFrames);\n              // \n              const frameSvgItems \u003d await new Promise((resolve, reject) \u003d\u003e {\n                google.script.run\n                  .withSuccessHandler(resolve)\n                  .withFailureHandler(reject)\n                  .convertJsonToSvgBatch(jsonFramesStrings);\n              });\n              // \n              // \n              const animationFramePromises \u003d frameSvgItems.map(item \u003d\u003e {\n                return (async () \u003d\u003e {\n                  if (item.svg) {\n                    try {\n                      const staticSvg \u003d await renderDynamicSvgInIframe(item.svg);\n                      const pngData \u003d await convertSvgToBase64Png(staticSvg, false, MAX_ANIMATION_WIDTH);\n                      return pngData; // \n                    } catch (e) {\n                      console.warn(`[generate] アニメーションフレームSVGの変換に失敗 (並列): ${e.message}`);\n                       return null; // \n                    }\n                  }\n                  return null; // \n                })();\n              });\n              // \n              const allFramePromises \u003d animationFramePromises;\n              // \n              // \n              const pngFramesBase64Raw \u003d await Promise.all(allFramePromises);\n              // \n              const pngFramesBase64 \u003d pngFramesBase64Raw.filter(Boolean);\n              // \n              if (pngFramesBase64.length \u003d\u003d\u003d 0) {\n                throw new Error(\u0027アニメーションフレームが1枚も生成されませんでした。\u0027);\n              }\n              // \n              const {\n                frames,\n                width,\n                height\n              } \u003d await base64FramesToArrayBuffers(pngFramesBase64);\n              // \n              const finalDelays \u003d (frames.length \u003d\u003d\u003d delays.length) ?\n              delays : delays.slice(0, frames.length);\n              if (frames.length \u003c delays.length) {\n                finalDelays[finalDelays.length - 1] \u003d animationEndDelayMs;\n              }\n              const apngBase64 \u003d await createAPNGFromFrames(frames, finalDelays, width, height);\n              // \n              return {\n                key: originalJsonKey, \n                data: apngBase64,\n                type: \u0027animation\u0027\n              };\n            } catch (animError) {\n              console.error(`[generate] アニメーショングラフ生成エラー: ${animError.message}`, originalJsonString.substring(0, 50));\n              showStatus(`アニメーショングラフ生成エラー: ${animError.message}`, \u0027error\u0027);\n              // \n              try {\n                console.warn(\u0027[generate] アニメーション失敗のため、静止画グラフにフォールバックします。\u0027);\n                const staticSvg \u003d await renderDynamicSvgInIframe(svgString); \n                const pngData \u003d await convertSvgToBase64Png(staticSvg);\n                return {\n                  key: originalJsonKey, \n                  data: pngData,\n                  type: \u0027chart\u0027\n                };\n              } catch (fallbackError) {\n                return null;\n              }\n            }\n          });\n          const convertedChartImages \u003d (await Promise.all(chartConversionPromises)).filter(Boolean);\n          allImagesToUpload.push(...convertedChartImages);\n        } catch (e) {\n          console.error(\u0027[generate] グラフJSON -\u003e SVG変換サーバー呼び出しエラー:\u0027, e);\n          throw new Error(\u0027グラフJSONからSVGへの変換中にエラーが発生しました: \u0027 + (e.message || e));\n        }\n      } else {\n      }\n      // \n      if (svgsToConvert.length \u003e 0) {\n        try {\n          const conversionPromises \u003d svgsToConvert.map(async (dynamicSvg) \u003d\u003e {\n            try {\n              const staticSvg \u003d await renderDynamicSvgInIframe(dynamicSvg);\n              // \n        let filterColor \u003d null;\n        // \n        if (settings.graphColorTheme \u003d\u003d\u003d \u0027primary\u0027) {\n           filterColor \u003d settings.primaryColor; \n        }\n        // \n        const pngData \u003d await convertSvgToBase64Png(staticSvg, true, null, filterColor);\n        // \n              return {\n                key: dynamicSvg,\n                data: pngData,\n                type: \u0027svg_code\u0027\n              };\n            } catch (pngError) {\n              console.error(`[generate] SVG -\u003e \nPNG変換エラー: ${pngError.message}`, dynamicSvg.substring(0, 50));\n              showStatus(`SVG画像変換エラー: ${pngError.message}`, \u0027error\u0027);\n              return null;\n            }\n          });\n          const convertedImages \u003d (await Promise.all(conversionPromises)).filter(Boolean);\n          allImagesToUpload.push(...convertedImages);\n        } catch (e) {\n          console.error(\u0027[generate] SVG -\u003e PNG変換プロセス全体のエラー:\u0027, e);\n          throw new Error(\u0027SVGからPNGへの変換中にエラーが発生しました: \u0027 + (e.message || e));\n        }\n      } else {\n      }\n      // \n      if (textPromptsMap.size \u003e 0) {\n        for (const [prompt, shouldRound] of textPromptsMap) {\n          try {\n            showStatus(`「${prompt}」の画像を指定してください...`, \u0027info\u0027, 10000);\n            const originalImageData \u003d await promptForImage(prompt);\n            let finalImageData \u003d originalImageData;\n            if (shouldRound) {\n                //showStatus(`画像を角丸加工中... (${prompt})`, \u0027info\u0027, 3000);\n                finalImageData \u003d await applyRoundedCorners(originalImageData);\n            } else {\n            }\n            allImagesToUpload.push({\n              key: prompt,\n              data: finalImageData,\n              type: \u0027prompt\u0027\n            });\n          } catch (promptError) {\n            // \n            if (promptError.message.includes(\u0027キャンセル\u0027)) { // \n              showStatus(\u0027画像指定がキャンセルされたため、処理を中断します。\u0027, \u0027error\u0027); \n              console.warn(\u0027[generate] 画像プロンプトキャンセル:\u0027, prompt);\n              generateBtn.disabled \u003d false;\n              return;\n            } else if (promptError.message.includes(\u0027なしで続行\u0027)) { // \n              showStatus(`画像処理をスキップしました。`, \u0027info\u0027); // \n              // \n            } else { // \n              console.error(`[generate] プロンプト画像処理エラー (${prompt}):`, promptError);\n              showStatus(`画像処理エラー: ${promptError.message}`, \u0027error\u0027);\n            }\n            // \n          }\n        }\n      } else {\n      }\n      // \n      if (timestampsToExtract.length \u003e 0) {\n        let videoFile \u003d null;\n        let videoQuality \u003d 480;\n        try {\n          showStatus(\u0027画像切り出しのため、動画ファイルを選択してください。\u0027, \u0027info\u0027, 10000);\n          const videoResult \u003d await promptForVideo();\n          if (!videoResult || !videoResult.file) { // \n             // \n          }\n          videoFile \u003d videoResult.file;\n          videoQuality \u003d videoResult.quality;\n          if (!videoFile) {\n            showStatus(\u0027動画選択がキャンセルされたため、処理を中断します。\u0027, \u0027error\u0027);\n            console.warn(\u0027[generate] 動画選択キャンセル\u0027);\n            generateBtn.disabled \u003d false;\n            return;\n          }\n          showStatus(\u0027動画から画像の抽出を開始します...\u0027, \u0027info\u0027, 60000);\n          const extractedFrames \u003d await extractFrames(videoFile, timestampsToExtract, videoQuality);\n          const processingPromises \u003d extractedFrames.map(frame \u003d\u003e {\n            return (async () \u003d\u003e {\n              try {\n                if (frame.isAnimation) {\n                  // \n                  return {\n                    key: frame.timestamp,\n                    data: frame.data,\n                     type: \u0027animation\u0027 // \n                     // \n                  };\n                }\n                // showStatus(`画像を角丸加工中... (${frame.timestamp})`, \u0027info\u0027, 3000);\n                const\n                 roundedImageData \u003d await applyRoundedCorners(frame.data);\n                return {\n                  key: frame.timestamp,\n                  data: roundedImageData,\n                  type: \u0027timestamp\u0027 // \n                };\n              } catch (roundingError) {\n                console.error(`[generate] フレーム角丸加工エラー (${frame.timestamp}):`, roundingError);\n                showStatus(`フレーム加工エラー (${frame.timestamp}): ${roundingError.message}`, \u0027error\u0027);\n                return null;\n              }\n            })();\n          });\n          const processedFrames \u003d (await Promise.all(processingPromises)).filter(Boolean);\n          allImagesToUpload.push(...processedFrames);\n        } catch (videoError) {\n          if (videoError.message.includes(\u0027キャンセル\u0027)) { // \n            console.error(\u0027[generate] 動画処理プロセス全体でエラー:\u0027, videoError);\n            showStatus(`動画処理エラー: ${videoError.message}`, \u0027error\u0027);\n            generateBtn.disabled \u003d false;\n            return;\n          } else if (videoError.message.includes(\u0027なしで続行\u0027)) { // \n            showStatus(\u0027動画処理をスキップしました。\u0027, \u0027info\u0027);\n            console.warn(\u0027[generate] 動画選択がスキップされました。\u0027);\n            // \n          } else { // \n            console.error(\u0027[generate] 動画処理プロセス全体でエラー:\u0027, videoError);\n            showStatus(`動画処理エラー: ${videoError.message}`, \u0027error\u0027);\n            generateBtn.disabled \u003d false;\n            return;\n          }\n        }\n      } else {\n      }\n      // \n      if (allImagesToUpload.length \u003e 0) {\n        const imageMap \u003d new Map();\n        for (const item of allImagesToUpload) imageMap.set(item.key, {\n          data: item.data,\n          type: item.type\n        });\n        slideData.forEach(slide \u003d\u003e {\n          const imageValue \u003d slide.image;\n          let imageKey \u003d null;\n          if (typeof imageValue \u003d\u003d\u003d \u0027string\u0027 \u0026\u0026 imageValue.trim() !\u003d\u003d \u0027\u0027) {\n            const trimmedValue \u003d imageValue.trim();\n            if (svgCodes.has(trimmedValue.replace(/\\u00A0/g, \u0027 \u0027))) imageKey \u003d trimmedValue.replace(/\\u00A0/g, \u0027 \u0027);\n            else if (timestamps.has(trimmedValue)) imageKey \u003d trimmedValue;\n            else if (textPromptsMap.has(trimmedValue)) imageKey \u003d trimmedValue;\n            else if (chartJsons.has(trimmedValue)) imageKey \u003d trimmedValue;\n          } else if (typeof imageValue \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026 imageValue !\u003d\u003d null \u0026\u0026 imageValue.chartType) {\n            try {\n              const jsonStringKey \u003d JSON.stringify(imageValue);\n              if (chartJsons.has(jsonStringKey)) imageKey \u003d\n                jsonStringKey;\n            } catch (e) {  }\n          }\n          if (imageKey \u0026\u0026 imageMap.has(imageKey)) {\n            const imageInfo \u003d imageMap.get(imageKey);\n            slide._originalImage \u003d imageKey;\n            if (imageInfo.type \u003d\u003d\u003d \u0027chart\u0027) {\n              // \n              slide.image \u003d {\n                \"info\": \"chart\",\n                \"data\": imageInfo.data\n              };\n            } else if (imageInfo.type \u003d\u003d\u003d \u0027svg_code\u0027) { // \n              // \n              slide.image \u003d {\n                \"info\": \"svg_code\", // \n                \"data\": imageInfo.data\n              };\n            } else if (imageInfo.type \u003d\u003d\u003d \u0027animation\u0027) {\n              // \n              slide.image \u003d {\n                \"info\": \"animation\",\n                \"data\": imageInfo.data\n              };\n            } else {\n              // \n              slide.image \u003d imageInfo.data;\n            }\n          } else if (imageKey) {\n            console.warn(\"[generate] Base64埋め込み失敗: マップにキーが見つかりません:\", imageKey.substring(0, 50));\n          }\n        });\n      } else {\n      }\n      try {\n        finalSlideDataString \u003d JSON.stringify(slideData);\n      } catch (e) {\n        console.error(\u0027[generate] 最終JSON文字列化エラー:\u0027, e);\n        showStatus(\u0027警告: スライドデータの最終処理で問題が発生したため、元のデータを使用します...\u0027, \u0027error\u0027, 6000);\n        finalSlideDataString \u003d slideDataString;\n      }\n    } else {\n      finalSlideDataString \u003d JSON.stringify(slideData);\n    }\n    /// ▼▼▼ 【ここから置き換え】 サーバー通信と完了処理 (デバッグ版) ▼▼▼\n    const actionVerb \u003d isNewPresentation ? \u0027生成\u0027 : \u0027更新\u0027;\n    const loadingToastId \u003d showStatus(`スライドを${actionVerb}しています...`, \u0027info\u0027, 60000);\n    // \n    const finalPresentationUrl \u003d await new Promise((resolve, reject) \u003d\u003e {\n      google.script.run\n        .withSuccessHandler((response) \u003d\u003e {\n            resolve(response);\n        })\n        .withFailureHandler((e) \u003d\u003e {\n            console.error(`%c[Client Debug] Server Failed!`, \u0027color: red\u0027, e);\n            reject(e);\n        })\n        .generateSlidesFromWebApp(finalSlideDataString, settings, presentationId, imageUpdateOption);\n    });\n    if (loadingToastId) {\n      const loadingToast \u003d $(loadingToastId);\n      if (loadingToast) {\n        loadingToast.remove();\n      }\n    }\n    // \n    showStatus(`スライドの${actionVerb}が完了しました！`, \u0027success\u0027);\n    // \n    if (!isNewPresentation) {\n        lastGeneratedSlideUrl \u003d finalPresentationUrl;\n    }\n    const newTabBtn \u003d $(\u0027openSlideNewTabBtn\u0027);\n    if (newTabBtn) {\n      newTabBtn.href \u003d lastGeneratedSlideUrl; // \n    }\n    const genBtn \u003d $(\u0027generateBtn\u0027);\n    const buttonGroup \u003d $(\u0027buttonGroup\u0027);\n    genBtn.querySelector(\u0027.btn-text\u0027).textContent \u003d \u0027スライドを更新\u0027;\n    let showBtn \u003d $(\u0027showLastSlideBtn\u0027);\n    // \n    buttonGroup.style.display \u003d \u0027flex\u0027;\nbuttonGroup.style.gap \u003d \u00271rem\u0027;\n    // \n    if (!showBtn) {\n      // \n      showBtn \u003d document.createElement(\u0027button\u0027);\n      showBtn.id \u003d \u0027showLastSlideBtn\u0027;\n      showBtn.type \u003d \u0027button\u0027;\n      showBtn.className \u003d \u0027btn btn-primary\u0027;\n      buttonGroup.insertBefore(showBtn, genBtn);\n}\n    // \n    if (!isNewPresentation) {\n        // \n        try {\n            if (!isPreviewVisible) {\n                showPreviewPane(); // \n            } else {\n                // \n                // \n            }\n        } catch (e) {\n            console.error(\"[generate] iFrameプレビュー表示エラー:\", e);\n            showStatus(\u0027エラー: プレビュー表示に失敗しました。\u0027, \u0027error\u0027);\n        }\n    } else {\n        // \n    }\n    // \n    if (SlideEditor \u0026\u0026 SlideEditor.isEditorActive()) {\n        SlideEditor.updatePreviewButtonForEditor(true);\n    } else {\n        // \n        if (showBtn) {\n          showBtn.textContent \u003d \u0027プレビューを閉じる\u0027;\n          showBtn.classList.remove(\u0027btn-primary\u0027);\n          showBtn.classList.add(\u0027btn-secondary\u0027);\n          showBtn.style.backgroundColor \u003d \u0027var(--secondary-color)\u0027;\n          showBtn.onclick \u003d function() { if (isPreviewVisible) hidePreviewPane(); else showPreviewPane(); };\n        }\n    }\n    // \n  } catch (error) {\n    if (!(error \u0026\u0026 error.message \u0026\u0026 error.message.includes(\u0027キャンセル\u0027))) {\n      console.error(\u0027[generate] !!! 全体プロセスエラー !!!:\u0027, error);\n      showStatus(\u0027❌ エラーが発生しました: \u0027 + (error.message || error), \u0027error\u0027, 8000);\n    }\n  } finally {\n    const overlay \u003d $(\u0027previewOverlay\u0027);\n    if (overlay) {\n        // \n        overlay.style.animation \u003d \u0027none\u0027;\n        // \n        overlay.style.opacity \u003d \u00270\u0027;\n        // \nsetTimeout(() \u003d\u003e {\n            if (overlay) {\n                overlay.classList.remove(\u0027loading\u0027); // \n                overlay.style.animation \u003d \u0027\u0027; // \n                overlay.style.opacity \u003d \u0027\u0027;   // \n                // \n            }\n        }, 3000); // \n    }\n    stopButtonTimer(generateBtn, \u0027スライドを更新\u0027);\n    generateBtn.disabled \u003d false;\n    const buttonGroup \u003d $(\u0027buttonGroup\u0027);\n    if (buttonGroup) {\n      buttonGroup.style.display \u003d \u0027flex\u0027;\n      buttonGroup.style.gap \u003d \u00271rem\u0027;\n    }\n    if (SlideEditor \u0026\u0026 typeof SlideEditor.updatePreviewButtonForEditor \u003d\u003d\u003d \u0027function\u0027) {\n        // \n        SlideEditor.updatePreviewButtonForEditor(SlideEditor.isEditorActive());\n}\n  }\n} // \nasync function updateCurrentPage() {\n  // \n  if (!SlideEditor || typeof SlideEditor.getCurrentIndex !\u003d\u003d \u0027function\u0027 || typeof SlideEditor.getSlideData !\u003d\u003d \u0027function\u0027) {\n    showStatus(\u0027エラー: ページ更新機能が初期化されていません。\u0027, \u0027error\u0027);\n    return;\n  }\n  if (!SlideEditor.isEditorActive()) {\n    showStatus(\u0027構成データ編集モード中にのみページ更新が可能です。\u0027, \u0027info\u0027);\n    return;\n  }\n  // \n  const updateBtn \u003d $(\u0027updatePageBtn\u0027); // \n  const originalBtnText \u003d updateBtn.querySelector(\u0027.btn-text\u0027).textContent;\n  updateBtn.disabled \u003d true;\n  //updateBtn.textContent \u003d \u0027更新中...\u0027;\n  let loadingToastId \u003d null;\n  let finalSingleSlideDataString \u003d null; // \n  // \n  try {\n      const currentEditorData \u003d SlideEditor.getSlideData();\n      const jsonString \u003d JSON.stringify(currentEditorData, null, 2); // \n      $(\u0027slideDataInput\u0027).value \u003d jsonString;\n  } catch (e) {\n      console.error(\u0027[updateCurrentPage] SlideEditorデータのJSON文字列化に失敗:\u0027, e);\n      showJsonErrorModal(\u0027編集内容のJSON変換に失敗しました: \u0027 + e.message); // \n      updateBtn.disabled \u003d false; // \n      updateBtn.textContent \u003d originalBtnText;\n      return; // \n  }\n  // \n  const currentIndex \u003d SlideEditor.getCurrentIndex();\n  // \n  let currentSingleSlideData;\n  try {\n    // \n    const fullData \u003d JSON.parse($(\u0027slideDataInput\u0027).value); \n    // \n    currentSingleSlideData \u003d JSON.parse(JSON.stringify(fullData[currentIndex])); \n    // \n    currentSingleSlideData \u003d filterEmptyStringsInArrays(currentSingleSlideData);\n    // \n  } catch (e) {\n     showStatus(\u0027エラー: 更新対象のスライドデータの読み込みに失敗しました。\u0027, \u0027error\u0027); \n     updateBtn.disabled \u003d false; // \n     updateBtn.textContent \u003d originalBtnText;\n     return; \n  }\n  if (currentIndex \u003c 0 || !currentSingleSlideData) {\n    showStatus(\u0027エラー: 更新対象のスライドが見つかりません。\u0027, \u0027error\u0027);\n    updateBtn.disabled \u003d false; // \n    updateBtn.textContent \u003d originalBtnText;\n    return;\n  }\n  // \n  let presentationId \u003d null;\n  if (lastGeneratedSlideUrl) {\n    const match \u003d lastGeneratedSlideUrl.match(/\\/d\\/([a-zA-Z0-9_-]+)|\\?id\u003d([a-zA-Z0-9_-]+)/);\n    if (match \u0026\u0026 (match[1] || match[2])) {\n      presentationId \u003d match[1] || match[2];\n    }\n  }\n  if (!presentationId) {\n    showStatus(\u0027エラー: 更新対象のプレゼンテーションが見つかりません。まず全体を生成してください。\u0027, \u0027error\u0027);\n    updateBtn.disabled \u003d false; // \n    updateBtn.textContent \u003d originalBtnText;\n    return;\n  }\n  // \n  try {\n    // \n    const imageUpdateOption \u003d \u0027update\u0027;\n    // \n    startButtonTimer(updateBtn);\n    // \n    const settings \u003d getCurrentSettings();\n    if (ENABLE_CREDIT_IMAGE \u003d\u003d\u003d true) {\n      // \n      try {\n        const creditText \u003d CREDIT_TEXT_OPTIONS[Math.floor(Math.random() * CREDIT_TEXT_OPTIONS.length)];\n        const creditSvgString \u003d generateCreditSvg(creditText, settings.primaryColor);\n        const creditPngBase64 \u003d await convertSvgToBase64Png(creditSvgString, true);\n        // \n        settings.creditImageBase64 \u003d creditPngBase64;\n      } catch (e) {\n        console.error(\u0027[updateCurrentPage] クレジット画像の生成に失敗:\u0027, e);\n        showStatus(\u0027警告: クレジット画像の生成に失敗しました。\u0027, \u0027error\u0027, 5000);\n        settings.creditImageBase64 \u003d null; // \n      }\n    } else {\n      settings.creditImageBase64 \u003d null;\n    }\n    // \n    // \n    try {\n      const configSizes \u003d typeof CONFIG !\u003d\u003d \u0027undefined\u0027 ?\n      CONFIG.FONTS.sizes : {};\n      const fontFamily \u003d settings.fontFamily || \u0027Noto Sans JP\u0027;\n      // \n      if (currentSingleSlideData \u0026\u0026 typeof currentSingleSlideData.title \u003d\u003d\u003d \u0027string\u0027 \u0026\u0026 currentSingleSlideData.title.trim() !\u003d\u003d \u0027\u0027) {\n        let fontSizePt;\n        let fontWeight \u003d \u0027bold\u0027;\n        if (currentSingleSlideData.type \u003d\u003d\u003d \u0027title\u0027) fontSizePt \u003d configSizes.title || 41;\n        else if (currentSingleSlideData.type \u003d\u003d\u003d \u0027section\u0027) fontSizePt \u003d configSizes.sectionTitle || 38;\n        else fontSizePt \u003d configSizes.contentTitle || 24;\n        const widthPt \u003d calculateTextWidthPt(currentSingleSlideData.title, fontSizePt, fontFamily, fontWeight);\n        if (widthPt !\u003d\u003d null) {\n          currentSingleSlideData._title_widthPt \u003d widthPt;\n        } else {\n          console.warn(`[updateCurrentPage] Title 幅計算失敗`);\n          // \n        }\n      }\n      // \n      if (currentSingleSlideData \u0026\u0026 typeof currentSingleSlideData.subhead \u003d\u003d\u003d \u0027string\u0027 \u0026\u0026 currentSingleSlideData.subhead.trim() !\u003d\u003d \u0027\u0027) {\n        const fontSizePt \u003d configSizes.subhead ||\n        16;\n        const fontWeight \u003d \u0027normal\u0027;\n        const widthPt \u003d calculateTextWidthPt(currentSingleSlideData.subhead, fontSizePt, fontFamily, fontWeight);\n        if (widthPt !\u003d\u003d null) {\n          currentSingleSlideData._subhead_widthPt \u003d widthPt;\n        } else {\n          console.warn(`[updateCurrentPage] Subhead 幅計算失敗`);\n          // \n        }\n      }\n      // \n    } catch (e) {\n      console.error(\u0027[updateCurrentPage] テキスト幅計算中にエラー:\u0027, e);\n      // \n    }\n    // \n    if (imageUpdateOption \u003d\u003d\u003d \u0027update\u0027 \u0026\u0026 currentSingleSlideData.type \u003d\u003d\u003d \u0027section\u0027) {\n        // \n        const sectionNo \u003d currentSingleSlideData.sectionNo;\n        const sectionNoString \u003d String(sectionNo || \u0027\u0027).trim();\n        // \n        if (sectionNo \u003d\u003d\u003d null || sectionNo \u003d\u003d\u003d undefined || sectionNoString \u003d\u003d\u003d \u0027\u0027) {\n            // \n            // \n            currentSingleSlideData.ghostImageBase64 \u003d \u0027data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII\u003d\u0027;\n        } else {\n            // \n            try {\n                const ghostSettings \u003d {\n                    baseFrequency: 0.01,\n                    colorType: \u0027gray\u0027,\n                    alphaSlope: 0.50,\n                    contrastSlope: 1.0,\n                    frontColor: settings.primaryColor,\n                    frontAlpha: 0.15\n                };\n                // \n                const parsedNum \u003d (() \u003d\u003e {\n                    // \n                    if (Number.isFinite(sectionNo)) { return Number(sectionNo); }\n                    // \n                    if (typeof sectionNo \u003d\u003d\u003d \u0027string\u0027 || typeof sectionNo \u003d\u003d\u003d \u0027number\u0027) {\n                        const parsedStringNum \u003d parseFloat(sectionNoString);\n                        if (Number.isFinite(parsedStringNum)) {\n                            return parsedStringNum;\n                        }\n                    }\n                    // \n                    const m \u003d String(currentSingleSlideData.title || \u0027\u0027).match(/^\\s*(\\d+)[\\.．]/);\n                    if (m \u0026\u0026 m[1]) { return Number(m[1]); }\n                    // \n                    return (currentIndex + 1);\n                })();\n                const numberString \u003d String(parsedNum).padStart(2, \u00270\u0027);\n                const svgString \u003d generateGhostNumberSvg(numberString, 400, 250, ghostSettings);\n                const pngBase64 \u003d await convertSvgToBase64Png(svgString);\n                currentSingleSlideData.ghostImageBase64 \u003d pngBase64; // \n            } catch (e) {\n                console.warn(\u0027[updateCurrentPage] ゴースト番号画像生成プロセスでエラー:\u0027, e);\n                showStatus(\u0027警告: セクション番号の画像生成に失敗。テキストで代替します。\u0027, \u0027error\u0027, 5000);\n                // \n                currentSingleSlideData.ghostImageBase64 \u003d null;\n            }\n        }\n        // \n    }\n    // \n    if (imageUpdateOption \u003d\u003d\u003d \u0027update\u0027 \u0026\u0026 currentSingleSlideData.type \u003d\u003d\u003d \u0027triangle\u0027) {\n        // showStatus(\u0027Triangle用矢印画像を生成中...\u0027, \u0027info\u0027, 10000);\n        try {\n            const triangleArrowData \u003d await generateTriangleArrowImages(settings);\n            settings.triangleArrows \u003d triangleArrowData; // \n            // \n        } catch (e) {\n            console.error(\u0027[updateCurrentPage] Triangle矢印画像生成プロセス全体でエラー:\u0027, e);\n            // \n            showStatus(\u0027警告: Triangle用矢印画像の生成に失敗。代替描画されます。\u0027, \u0027error\u0027, 5000);\n            settings.triangleArrows \u003d null;\n        }\n    } else {\n        // \n        settings.triangleArrows \u003d null;\n    }\n    // \n    if (imageUpdateOption \u003d\u003d\u003d \u0027update\u0027) {\n        // \n        const urlRegex \u003d /^(https?:\\/\\/|data:image\\/)/;\n        const timestampRegex \u003d /^\\d{2}:\\d{2}(\\.\\S)?.*$/;\n        const svgRegex \u003d /^\\s*\u003csvg/i;\n        const imageValue \u003d currentSingleSlideData.image;\n        let identifiedType \u003d null;\n        let textKey \u003d null;\n        // \n        // \n        if (typeof imageValue \u003d\u003d\u003d \u0027string\u0027 \u0026\u0026 imageValue.trim() !\u003d\u003d \u0027\u0027) {\n            const trimmedValue \u003d imageValue.trim();\n            textKey \u003d trimmedValue; // \n            if (svgRegex.test(trimmedValue)) identifiedType \u003d \u0027svg\u0027;\n            else if (timestampRegex.test(trimmedValue)) identifiedType \u003d \u0027timestamp\u0027;\n            else if (urlRegex.test(trimmedValue)) identifiedType \u003d \u0027url\u0027;\n            else if (trimmedValue.startsWith(\u0027{\u0027)) {\n                try {\n                    const parsedJson \u003d JSON.parse(trimmedValue);\n                    identifiedType \u003d (parsedJson \u0026\u0026 typeof parsedJson \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026 parsedJson.chartType) ? \u0027chartJson\u0027 : \u0027prompt\u0027;\n                } catch (e) { identifiedType \u003d \u0027prompt\u0027; }\n            } else identifiedType \u003d \u0027prompt\u0027;\n        } else if (typeof imageValue \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026 imageValue !\u003d\u003d null \u0026\u0026 imageValue.chartType) {\n            identifiedType \u003d \u0027chartObject\u0027;\n            try {\n                textKey \u003d JSON.stringify(imageValue);\n                // \n            } catch (e) { console.error(\"[updateCurrentPage] chartObjectの文字列化失敗:\", imageValue, e);\n            } // \n        } else if (typeof imageValue \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026 imageValue !\u003d\u003d null \u0026\u0026 (imageValue.info \u003d\u003d\u003d \u0027chart\u0027 || imageValue.info \u003d\u003d\u003d \u0027animation\u0027)) {\n            // \n            identifiedType \u003d \u0027processed\u0027;\n        }\n        // \n        let processedImageInfo \u003d null;\n        // \n        // \n        // \n        if (identifiedType \u003d\u003d\u003d \u0027chartJson\u0027 || identifiedType \u003d\u003d\u003d \u0027chartObject\u0027) {\n            // \n            const originalJsonString \u003d textKey;\n            const graphTheme \u003d settings.graphColorTheme;\n            let processedJsonString \u003d originalJsonString; // \n            if (graphTheme !\u003d\u003d \u0027original\u0027) {\n                // \n                let replacementColor;\n                switch (graphTheme) {\n                    case \u0027primary\u0027: replacementColor \u003d settings.primaryColor;\n                    break;\n                    case \u0027gemini\u0027: replacementColor \u003d \"#gemini\"; break;\n                    case \u0027night\u0027: replacementColor \u003d \"#night\"; break;\n                }\n                try {\n                    const chartData \u003d JSON.parse(originalJsonString);\n                    if (chartData \u0026\u0026 chartData.data) chartData.data.colors \u003d replacementColor;\n                    processedJsonString \u003d JSON.stringify(chartData);\n                } catch (e) {  }\n            }\n            try {\n                // \n                const animationEnabled \u003d settings.enableGraphAnimation;\n                if (animationEnabled) {\n                    // \n                    showStatus(\u0027アニメーショングラフを生成中...\u0027, \u0027info\u0027, 10000);\n                    const animationFrames \u003d 11;\n                    const animationDurationMs \u003d 1500;\n                    const animationEndDelayMs \u003d 3500;\n                    const frameDelayMs \u003d animationDurationMs / (animationFrames - 1);\n                    const delays \u003d [];\n                    for (let i \u003d 0; i \u003c animationFrames - 1; i++) { delays.push(Math.round(frameDelayMs));\n                    }\n                    delays.push(animationEndDelayMs);\n                    const jsonFramesStrings \u003d generateAnimationJsonFrames(processedJsonString, animationFrames);\n                    const frameSvgItems \u003d await new Promise((resolve, reject) \u003d\u003e {\n                        google.script.run\n                            .withSuccessHandler(resolve)\n                            .withFailureHandler(reject)\n                             .convertJsonToSvgBatch(jsonFramesStrings);\n                    });\n                    const pngFramesBase64 \u003d [];\n                    for (const item of frameSvgItems) {\n                        if (item.svg) {\n                            const staticSvg \u003d await renderDynamicSvgInIframe(item.svg);\n                            const pngData \u003d await convertSvgToBase64Png(staticSvg);\n                            pngFramesBase64.push(pngData);\n                        }\n                    }\n                    if (pngFramesBase64.length \u003d\u003d\u003d 0) throw new Error(\u0027アニメーションフレームが1枚も生成されませんでした。\u0027);\n                    const { frames, width, height } \u003d await base64FramesToArrayBuffers(pngFramesBase64);\n                    const finalDelays \u003d (frames.length \u003d\u003d\u003d delays.length) ? delays : delays.slice(0, frames.length);\n                    if (frames.length \u003c delays.length) {\n                        finalDelays[finalDelays.length - 1] \u003d animationEndDelayMs;\n                    }\n                    const apngBase64 \u003d await createAPNGFromFrames(frames, finalDelays, width, height);\n                    processedImageInfo \u003d { data: apngBase64, type: \u0027animation\u0027 }; // \n                } else {\n                    // \n                    throw new Error(\"Animation disabled, fallback to static.\");\n                }\n            } catch (animError) {\n                console.warn(`[updateCurrentPage] アニメーショングラフ処理エラー (または無効): ${animError.message}。静止画にフォールバックします。`);\n                // \n                try {\n                    // \n                    const staticSvgItems \u003d await new Promise((resolve, reject) \u003d\u003e {\n                        google.script.run\n                             .withSuccessHandler(resolve)\n                            .withFailureHandler(reject)\n                            .convertJsonToSvgBatch([processedJsonString]); // \n                    });\n                    if (!staticSvgItems || staticSvgItems.length \u003d\u003d\u003d 0 || !staticSvgItems[0].svg) {\n                        throw new Error(staticSvgItems[0]?.error || \u0027サーバーでの静止画SVG変換に失敗しました。\u0027);\n                    }\n                    const staticSvgString \u003d staticSvgItems[0].svg;\n                    const staticSvg \u003d await renderDynamicSvgInIframe(staticSvgString);\n                    const pngData \u003d await convertSvgToBase64Png(staticSvg);\n                    processedImageInfo \u003d { data: pngData, type: \u0027chart\u0027 };\n                    // \n                } catch (staticError) {\n                    console.error(`[updateCurrentPage] 静止画グラフのフォールバック処理エラー: ${staticError.message}`);\n                    // \n                    showStatus(`グラフ画像変換エラー: ${staticError.message}`, \u0027error\u0027);\n                }\n            }\n        }\n        // \n        else if (identifiedType \u003d\u003d\u003d \u0027svg\u0027) {\n            // \n            try {\n                const staticSvg \u003d await renderDynamicSvgInIframe(textKey);\n                // \n        let filterColor \u003d null;\n        if (settings.graphColorTheme \u003d\u003d\u003d \u0027primary\u0027) {\n           filterColor \u003d settings.primaryColor;\n        }\n        const pngData \u003d await convertSvgToBase64Png(staticSvg, true, null, filterColor);\n        // \n                processedImageInfo \u003d { data: pngData, type: \u0027svg_code\u0027 };\n            } catch (pngError) {\n                console.error(`[updateCurrentPage] SVG -\u003e PNG変換エラー: ${pngError.message}`);\n                // \n                showStatus(`SVG画像変換エラー: ${pngError.message}`, \u0027error\u0027);\n            }\n        }\n        // \n        else if (identifiedType \u003d\u003d\u003d \u0027prompt\u0027) {\n            // \n            try {\n                showStatus(`「${textKey}」の画像を指定してください...`, \u0027info\u0027, 10000);\n                const originalImageData \u003d await promptForImage(textKey);\n                let finalImageData \u003d originalImageData;\n                // \n                const shouldRound \u003d currentSingleSlideData.type !\u003d\u003d \u0027fullImage\u0027 \u0026\u0026 !currentSingleSlideData.isSummary;\n                if (shouldRound) {\n                    //showStatus(`画像を角丸加工中... (${textKey})`, \u0027info\u0027, 3000);\n                    finalImageData \u003d await applyRoundedCorners(originalImageData);\n                }\n                processedImageInfo \u003d { data: finalImageData, type: \u0027prompt\u0027 };\n            } catch (promptError) {\n              // \n              if (promptError.message.includes(\u0027キャンセル\u0027)) {\n                console.warn(\u0027[updateCurrentPage] 画像プロンプトキャンセル:\u0027, textKey);\n                throw promptError;\n              } else if (promptError.message.includes(\u0027なしで続行\u0027)) { // \n                showStatus(`画像処理をスキップしました。`, \u0027info\u0027);\n                // \n              } else {\n                console.error(`[updateCurrentPage] プロンプト画像処理エラー (${textKey}):`, promptError);\n                showStatus(`画像処理エラー: ${promptError.message}`, \u0027error\u0027);\n              }\n              // \n            }\n        }\n        // \n        else if (identifiedType \u003d\u003d\u003d \u0027timestamp\u0027) {\n            // \n            let videoFile \u003d null;\n            let videoQuality \u003d 480;\n            try {\n                showStatus(\u0027画像切り出しのため、動画ファイルを選択してください。\u0027, \u0027info\u0027, 10000);\n                const videoResult \u003d await promptForVideo();\n                if (videoResult \u0026\u0026 videoResult.file) {\n                    videoFile \u003d videoResult.file;\n                    videoQuality \u003d videoResult.quality;\n                }\n                if (!videoFile) {\n                    throw new Error(\u0027動画選択がキャンセルされました。\u0027);\n                }\n                showStatus(\u0027動画から画像の抽出を開始します...\u0027, \u0027info\u0027, 60000);\n                // \n                const extractedFrames \u003d await extractFrames(videoFile, [textKey], videoQuality);\n                if (!extractedFrames || extractedFrames.length \u003d\u003d\u003d 0) {\n                    throw new Error(\"フレームの抽出に失敗しました。\");\n                }\n                const frame \u003d extractedFrames[0];\n                // \n                if (frame.isAnimation) {\n                    // \n                    // \n                    processedImageInfo \u003d { data: frame.data, type: \u0027animation\u0027 };\n                } else {\n                    // showStatus(`画像を角丸加工中... (${frame.timestamp})`, \u0027info\u0027, 3000);\n                    const roundedImageData \u003d await applyRoundedCorners(frame.data);\n                    processedImageInfo \u003d { data: roundedImageData, type: \u0027timestamp\u0027 };\n                }\n            } catch (videoError) {\n              if (videoError.message.includes(\u0027キャンセル\u0027)) {\n                console.warn(\u0027[updateCurrentPage] 動画処理キャンセル\u0027);\n                throw videoError;\n              } else if (videoError.message.includes(\u0027なしで続行\u0027)) { // \n                showStatus(\u0027動画処理をスキップしました。\u0027, \u0027info\u0027);\n                console.warn(\u0027[updateCurrentPage] 動画選択がスキップされました。\u0027);\n                // \n              } else {\n                console.error(\u0027[updateCurrentPage] 動画処理プロセス全体でエラー:\u0027, videoError);\n                showStatus(`動画処理エラー: ${videoError.message}`, \u0027error\u0027);\n              }\n            }\n        }\n        // \n        if (processedImageInfo) {\n            currentSingleSlideData._originalImage \u003d textKey;\n            // \n            if (processedImageInfo.type \u003d\u003d\u003d \u0027chart\u0027 || processedImageInfo.type \u003d\u003d\u003d \u0027animation\u0027 || processedImageInfo.type \u003d\u003d\u003d \u0027svg_code\u0027) {\n                // \n                currentSingleSlideData.image \u003d {\n                    \"info\": processedImageInfo.type,\n                     \"data\": processedImageInfo.data\n                };\n            } else {\n                // \n                currentSingleSlideData.image \u003d processedImageInfo.data;\n            }\n        } else if (identifiedType !\u003d\u003d \u0027url\u0027 \u0026\u0026 identifiedType !\u003d\u003d \u0027processed\u0027 \u0026\u0026 identifiedType !\u003d\u003d null) {\n            console.warn(\"[updateCurrentPage] Base64埋め込み失敗: 処理済み画像がありません。\");\n            // \n        } else {\n             // \n        }\n    } else {\n        // \n    }\n    // \n    try {\n        // \n        finalSingleSlideDataString \u003d JSON.stringify(currentSingleSlideData);\n    } catch (e) {\n        console.error(\u0027[updateCurrentPage] 最終JSON文字列化エラー:\u0027, e);\n        // \n        showStatus(\u0027警告: スライドデータの最終処理で問題が発生したため、元のデータを使用します...\u0027, \u0027error\u0027, 6000);\n        // \n        finalSingleSlideDataString \u003d JSON.stringify(currentSlideDataArray[currentIndex]);\n    }\n    // \n    loadingToastId \u003d showStatus(`ページ ${currentIndex + 1} を更新中...`, \u0027info\u0027, 15000);\n    // \n    // \n    const result \u003d await new Promise((resolve, reject) \u003d\u003e {\n      google.script.run\n        .withSuccessHandler(resolve)\n        .withFailureHandler(reject)\n        .updateSingleSlide(\n          presentationId,\n          currentIndex, // \n          finalSingleSlideDataString, // \n             settings,\n          imageUpdateOption // \n        );\n    });\n    // \n    if (result \u0026\u0026 result.status \u003d\u003d\u003d \u0027success\u0027) {\n      // \n      if (loadingToastId) {\n        const loadingToast \u003d $(loadingToastId);\n        if (loadingToast) {\n          loadingToast.remove();\n          // \n        }\n      }\n      showStatus(`ページ ${currentIndex + 1} の更新が完了しました！`, \u0027success\u0027);\n      // \n      // \n    } else {\n      // \n      throw new Error(result.message || \u0027不明なサーバーエラーが発生しました。\u0027);\n    }\n  } catch (error) {\n    // \n    if (error \u0026\u0026 error.message \u0026\u0026 error.message.includes(\u0027キャンセル\u0027)) {\n      showStatus(\u0027ページ更新がキャンセルされました。\u0027, \u0027info\u0027);\n    } else {\n      showStatus(`❌ ページ更新エラー: ${error.message || error}`, \u0027error\u0027, 8000);\n      console.error(\u0027[updateCurrentPage] Error:\u0027, error); // \n    }\n  } finally {\n    const newButtonText \u003d `${currentIndex + 1}ページ目を更新`;\n    stopButtonTimer(updateBtn, newButtonText);\n    updateBtn.disabled \u003d false;\n    //updateBtn.textContent \u003d originalBtnText; // \n  }\n}\n    function toggleGradientOptions() {\n      var optionsDiv \u003d $(\u0027gradient-options\u0027);\n      // \n      if ($(\u0027enableGradient\u0027).checked) {\n        optionsDiv.style.display \u003d \u0027block\u0027;\n        // \n      } else {\n        optionsDiv.style.display \u003d \u0027none\u0027;\n        // \n      }\n    }\n    function loadSettingsToForm() {\n      if (Object.keys(loadedSettings).length \u003e 0) {\n        applyAllSettings(loadedSettings);\n      } else {\n        updatePrimaryColor($(\u0027primaryColorText\u0027).value);\n        updateLargeFontColor($(\u0027largeFontColorText\u0027).value);\n        updateSmallFontColor($(\u0027smallFontColorText\u0027).value);\n        updateBackgroundColor($(\u0027backgroundColorText\u0027).value);\n      }\n      if (enableUiColorSync \u003d\u003d\u003d false) {\n        // \n        const defaultPrimary \u003d \u0027#4285F4\u0027;\n        // \n        const defaultPrimaryDark \u003d \u0027#3871CF\u0027; \n        const defaultLargeFont \u003d \u0027#333333\u0027;\n        const defaultSmallFont \u003d \u0027#1F2937\u0027;\n        // \n        const defaultBg \u003d \u0027#F9FAFB\u0027; \n        document.documentElement.style.setProperty(\u0027--primary-color\u0027, defaultPrimary);\n        document.documentElement.style.setProperty(\u0027--primary-color-dark\u0027, defaultPrimaryDark);\n        document.documentElement.style.setProperty(\u0027--text-large-font\u0027, defaultLargeFont);\n        document.documentElement.style.setProperty(\u0027--text-small-font\u0027, defaultSmallFont);\n        // \n        const leftPane \u003d $(\u0027left-pane\u0027);\n        const isNarrow \u003d leftPane \u0026\u0026 leftPane.classList.contains(\u0027narrow-layout\u0027);\n        if (!isNarrow) {\n            document.documentElement.style.setProperty(\u0027--bg-body\u0027, defaultBg);\n            document.documentElement.style.setProperty(\u0027--card-header-bg\u0027, defaultBg);\n        }\n      }\n    }\n    function applyAllSettings(settings) {\n      const s \u003d settings || {};\n      updatePrimaryColor(s.primaryColor || $(\u0027primaryColorText\u0027).value);\n      updateLargeFontColor(s.largeFontColor || \u0027#333333\u0027);\n      updateSmallFontColor(s.smallFontColor || \u0027#1F2937\u0027);\n      updateBackgroundColor(s.backgroundColor || \u0027#FFFFFF\u0027); // \n      $(\u0027backgroundColor\u0027).value \u003d s.backgroundColor || \u0027#FFFFFF\u0027;\n      $(\u0027backgroundColorText\u0027).value \u003d s.backgroundColor || \u0027#FFFFFF\u0027;\n      $(\u0027graphColorTheme\u0027).value \u003d s.graphColorTheme || \u0027primary\u0027;\n      $(\u0027fontFamily\u0027).value \u003d s.fontFamily || \u0027Noto Sans JP\u0027;\n      $(\u0027footerText\u0027).value \u003d (s.footerText \u003d\u003d\u003d undefined) ? \u0027© Google Inc.\u0027 : s.footerText;\n      $(\u0027driveFolderUrl\u0027).value \u003d s.driveFolderUrl || \u0027\u0027;\n      $(\u0027showTitleUnderline\u0027).checked \u003d typeof s.showTitleUnderline \u003d\u003d\u003d \u0027boolean\u0027 ? s.showTitleUnderline : true;\n      $(\u0027showBottomBar\u0027).checked \u003d typeof s.showBottomBar \u003d\u003d\u003d \u0027boolean\u0027 ? s.showBottomBar : true;\n      $(\u0027showDateColumn\u0027).checked \u003d typeof s.showDateColumn \u003d\u003d\u003d \u0027boolean\u0027 ? s.showDateColumn : true;\n      $(\u0027showPageNumber\u0027).checked \u003d typeof s.showPageNumber \u003d\u003d\u003d \u0027boolean\u0027 ? s.showPageNumber : true;\n      $(\u0027enableGradient\u0027).checked \u003d typeof s.enableGradient \u003d\u003d\u003d \u0027boolean\u0027 ? s.enableGradient : true;\n      $(\u0027enableGraphAnimation\u0027).checked \u003d typeof s.enableGraphAnimation \u003d\u003d\u003d \u0027boolean\u0027 ? s.enableGraphAnimation : false;\n      $(\u0027gradientStart\u0027).value \u003d s.gradientStart || \u0027#4285F4\u0027; \n      $(\u0027gradientStartText\u0027).value \u003d s.gradientStart || \u0027#4285F4\u0027;\n      $(\u0027gradientEnd\u0027).value \u003d s.gradientEnd || \u0027#ff52df\u0027; \n      $(\u0027gradientEndText\u0027).value \u003d s.gradientEnd || \u0027#ff52df\u0027;\n      const defaultLogo \u003d \u0027https://upload.wikimedia.org/wikipedia/commons/thumb/8/8a/Google_Gemini_logo.svg/2560px-Google_Gemini_logo.svg.png\u0027;\n  $(\u0027headerLogoUrl\u0027).value \u003d (s.headerLogoUrl \u003d\u003d\u003d undefined) ? defaultLogo : s.headerLogoUrl;\n    $(\u0027closingLogoUrl\u0027).value \u003d (s.closingLogoUrl \u003d\u003d\u003d undefined) ? defaultLogo : s.closingLogoUrl;\n      $(\u0027titleBgUrl\u0027).value \u003d s.titleBgUrl || \u0027\u0027; \n      $(\u0027sectionBgUrl\u0027).value \u003d s.sectionBgUrl || \u0027\u0027;\n      $(\u0027mainBgUrl\u0027).value \u003d s.mainBgUrl || \u0027\u0027; \n      $(\u0027closingBgUrl\u0027).value \u003d s.closingBgUrl || \u0027\u0027;\n      toggleGradientOptions(); \n      updateGradientPreview();\n    }\n    function loadUserPresets() { return JSON.parse(localStorage.getItem(\u0027slideFactory_presets\u0027) || \u0027{}\u0027); }\n    function saveUserPresets(presets) { localStorage.setItem(\u0027slideFactory_presets\u0027, JSON.stringify(presets)); }\n    function updatePresetSelect() {\n      const presets \u003d loadUserPresets(); const select \u003d $(\u0027presetSelect\u0027);\n      const deleteBtn \u003d $(\u0027deletePreset\u0027);\n      select.innerHTML \u003d \u0027\u003coption value\u003d\"_default\"\u003eデフォルト設定\u003c/option\u003e\u0027;\n      Object.keys(presets).forEach(name \u003d\u003e {\n        const option \u003d document.createElement(\u0027option\u0027);\n        option.value \u003d name; option.textContent \u003d name; select.appendChild(option);\n      });\n      deleteBtn.disabled \u003d select.value \u003d\u003d\u003d \u0027_default\u0027 || select.value \u003d\u003d\u003d \u0027\u0027;\n    }\n    function saveCurrentPreset() {\n      const currentPresetName \u003d $(\u0027presetSelect\u0027).value;\n      const modal \u003d $(\u0027presetSaveModal\u0027);\n      const overwriteBtn \u003d $(\u0027overwritePresetBtn\u0027);\n      const saveAsNewBtn \u003d $(\u0027saveAsNewPresetBtn\u0027);\n      const optionsDiv \u003d $(\u0027presetSaveOptions\u0027);\n      const newNameDiv \u003d $(\u0027newPresetNameInput\u0027);\n      const nameField \u003d $(\u0027presetNameField\u0027);\n      // \n      modal.style.display \u003d \u0027flex\u0027;\n      optionsDiv.style.display \u003d \u0027flex\u0027;\n      newNameDiv.style.display \u003d \u0027none\u0027;\n      nameField.value \u003d \u0027\u0027;\n      // \n      if (currentPresetName \u0026\u0026 currentPresetName !\u003d\u003d \u0027_default\u0027) {\n        overwriteBtn.style.display \u003d \u0027block\u0027;\n        $(\u0027currentPresetName\u0027).textContent \u003d `「${currentPresetName}」`;\n      } else {\n        overwriteBtn.style.display \u003d \u0027none\u0027;\n      }\n    }\n    function performOverwriteSave() {\n      const presetName \u003d $(\u0027presetSelect\u0027).value;\n      if (!presetName) return;\n      if (presetName \u003d\u003d\u003d \u0027_default\u0027) {\n        alert(\u0027「デフォルト設定」は上書き保存できません。別の名前で保存してください。\u0027);\n        closePresetModal(); // \n        return;\n      }\n      const presets \u003d loadUserPresets();\n      presets[presetName] \u003d getCurrentSettings();\n      saveUserPresets(presets);\n      updatePresetSelect();\n      $(\u0027presetSelect\u0027).value \u003d presetName;\n      closePresetModal();\n      showStatus(`プリセット「${presetName}」を上書き保存しました`, \u0027success\u0027);\n    }\n    function showNewPresetNameInput() {\n      $(\u0027presetSaveOptions\u0027).style.display \u003d \u0027none\u0027;\n      $(\u0027newPresetNameInput\u0027).style.display \u003d \u0027block\u0027;\n      $(\u0027presetNameField\u0027).focus();\n    }\n    function cancelNewPresetName() {\n      $(\u0027presetSaveOptions\u0027).style.display \u003d \u0027flex\u0027;\n      $(\u0027newPresetNameInput\u0027).style.display \u003d \u0027none\u0027;\n      $(\u0027presetNameField\u0027).value \u003d \u0027\u0027;\n    }\n    function performSaveAsNew() {\n      const presets \u003d loadUserPresets();\n      const name \u003d $(\u0027presetNameField\u0027).value.trim();\n      if (!name) {\n        alert(\u0027プリセット名を入力してください。\u0027);\n        return;\n      }\n      if (name \u003d\u003d\u003d \u0027_default\u0027) {\n        alert(\u0027「_default」という名前はプリセット名として使用できません。\u0027);\n        return; // \n      }\n      if (name.length \u003e 20) {\n        alert(\u0027プリセット名は20文字以内にしてください。\u0027);\n        return;\n      }\n      if (presets[name]) {\n        if (!confirm(`プリセット「${name}」は既に存在します。上書きしますか？`)) {\n          return;\n        }\n      } else if (Object.keys(presets).length \u003e\u003d 10) {\n        alert(\u0027プリセットは最大10個まで保存できます。\u0027);\n        return;\n      }\n      presets[name] \u003d getCurrentSettings();\n      saveUserPresets(presets);\n      updatePresetSelect();\n      $(\u0027presetSelect\u0027).value \u003d name;\n      closePresetModal();\n      showStatus(`プリセット「${name}」を保存しました`, \u0027success\u0027);\n    }\n    function closePresetModal() {\n      $(\u0027presetSaveModal\u0027).style.display \u003d \u0027none\u0027;\n    }\n    function loadSelectedPreset() {\n      const presets \u003d loadUserPresets();\n      const presetName \u003d $(\u0027presetSelect\u0027).value;\n      if (presetName \u003d\u003d\u003d \u0027_default\u0027) {\n        // \n        loadSettingsToForm(); \n        showStatus(`デフォルト設定を適用しました`, \u0027success\u0027);\n        return; // \n      }\n      if (presets[presetName]) {\n        applyAllSettings(presets[presetName]);\n        showStatus(`プリセット「${presetName}」を適用しました`, \u0027success\u0027);\n      }\n    }\n    function deleteSelectedPreset() {\n      const select \u003d $(\u0027presetSelect\u0027);\n      const presetName \u003d select.value;\n      // \n      if (!presetName || presetName \u003d\u003d\u003d \u0027_default\u0027) {\n        return;\n      }\n      // \n      const deleteLogic \u003d () \u003d\u003e {\n        const presets \u003d loadUserPresets();\n        delete presets[presetName];\n        saveUserPresets(presets);\n        updatePresetSelect(); // \n        showStatus(`プリセット「${presetName}」を削除しました`, \u0027success\u0027);\n      };\n      // \n      showDeleteItemConfirmModal(deleteLogic);\n    }\n    // \nconst SvgVisualEditor \u003d (function() {\n  let currentSvgElement \u003d null;\n  let onSaveCallback \u003d null;\n  // \n  let selectedElements \u003d [];\n  let clipboard \u003d [];\n  let movingElements \u003d [];\n  let undoStack \u003d [];\n  let redoStack \u003d [];\n  // \n  let isDragging \u003d false;\n  let isResizing \u003d false; // \n  let activeResizeHandle \u003d null; // \n  let isBoxSelecting \u003d false;\n  let dragStartClientPos \u003d { x: 0, y: 0 };\n  let selectionBoxStart \u003d { x: 0, y: 0 };\n  // \n  let initialTransforms \u003d new Map();\n  let initialBBoxes \u003d new Map(); // \n  // \n  let modal, canvas, controls, noSelection;\n  let undoBtn, redoBtn;\n  let selectionRectElement;\n  let resizeHandlesGroup; // \n  let inputs \u003d {};\n  let btnFront, btnForward, btnBackward, btnBack;\n  // \n  let inputCanvasW, inputCanvasH;\n  let inputVbx, inputVby, inputVbw, inputVbh;\n  function init() {\n    modal \u003d document.getElementById(\u0027svgEditorModal\u0027);\n    canvas \u003d document.getElementById(\u0027svgEditorCanvas\u0027);\n    controls \u003d document.getElementById(\u0027svgEditorControls\u0027);\n    noSelection \u003d document.getElementById(\u0027svgEditorNoSelection\u0027);\n    undoBtn \u003d document.getElementById(\u0027svgUndoBtn\u0027);\n    redoBtn \u003d document.getElementById(\u0027svgRedoBtn\u0027);\n    btnFront \u003d document.getElementById(\u0027svgBringFrontBtn\u0027);\n    btnForward \u003d document.getElementById(\u0027svgBringForwardBtn\u0027);\n    btnBackward \u003d document.getElementById(\u0027svgSendBackwardBtn\u0027);\n    btnBack \u003d document.getElementById(\u0027svgSendBackBtn\u0027);\n    inputCanvasW \u003d document.getElementById(\u0027svgCanvasWidth\u0027);\n    inputCanvasH \u003d document.getElementById(\u0027svgCanvasHeight\u0027);\n    inputVbx \u003d document.getElementById(\u0027svgViewBoxX\u0027);\n    inputVby \u003d document.getElementById(\u0027svgViewBoxY\u0027);\n    inputVbw \u003d document.getElementById(\u0027svgViewBoxW\u0027);\n    inputVbh \u003d document.getElementById(\u0027svgViewBoxH\u0027);\n    inputs \u003d {\n      tagName: document.getElementById(\u0027svgEditTagName\u0027),\n      text: document.getElementById(\u0027svgEditText\u0027),\n      fillColor: document.getElementById(\u0027svgEditFillColor\u0027),\n      fillText: document.getElementById(\u0027svgEditFillText\u0027),\n      strokeColor: document.getElementById(\u0027svgEditStrokeColor\u0027),\n      strokeText: document.getElementById(\u0027svgEditStrokeText\u0027),\n      strokeWidth: document.getElementById(\u0027svgEditStrokeWidth\u0027),\n      scale: document.getElementById(\u0027svgEditScale\u0027),\n      scaleRange: document.getElementById(\u0027svgEditScaleRange\u0027),\n      opacity: document.getElementById(\u0027svgEditOpacity\u0027),\n      opacityRange: document.getElementById(\u0027svgEditOpacityRange\u0027),\n      fillOpacity: document.getElementById(\u0027svgEditFillOpacity\u0027),\n      fillOpacityRange: document.getElementById(\u0027svgEditFillOpacityRange\u0027),\n      strokeOpacity: document.getElementById(\u0027svgEditStrokeOpacity\u0027),\n      strokeOpacityRange: document.getElementById(\u0027svgEditStrokeOpacityRange\u0027)\n    };\n    if (undoBtn) undoBtn.addEventListener(\u0027click\u0027, undo);\n    if (redoBtn) redoBtn.addEventListener(\u0027click\u0027, redo);\n    document.getElementById(\u0027svgEditorSaveBtn\u0027).addEventListener(\u0027click\u0027, saveAndClose);\n    document.getElementById(\u0027svgEditorCancelBtn\u0027).addEventListener(\u0027click\u0027, close);\n    if (btnFront) btnFront.addEventListener(\u0027click\u0027, () \u003d\u003e reorderSelection(\u0027front\u0027));\n    if (btnForward) btnForward.addEventListener(\u0027click\u0027, () \u003d\u003e reorderSelection(\u0027forward\u0027));\n    if (btnBackward) btnBackward.addEventListener(\u0027click\u0027, () \u003d\u003e reorderSelection(\u0027backward\u0027));\n    if (btnBack) btnBack.addEventListener(\u0027click\u0027, () \u003d\u003e reorderSelection(\u0027back\u0027));\n    if (inputCanvasW) inputCanvasW.addEventListener(\u0027input\u0027, updateCanvasSize);\n    if (inputCanvasH) inputCanvasH.addEventListener(\u0027input\u0027, updateCanvasSize);\n    [inputVbx, inputVby, inputVbw, inputVbh].forEach(input \u003d\u003e {\n      if (input) input.addEventListener(\u0027input\u0027, updateCanvasViewBox);\n    });\n    const bindInput \u003d (el, propName, linkedEl \u003d null) \u003d\u003e {\n      if (!el) return;\n      el.addEventListener(\u0027input\u0027, (e) \u003d\u003e {\n        if (linkedEl) linkedEl.value \u003d e.target.value;\n        applyPropertyChange(propName, e.target.value);\n      });\n    };\n    bindInput(inputs.text, \u0027text\u0027);\n    bindInput(inputs.fillColor, \u0027fill\u0027, inputs.fillText);\n    bindInput(inputs.fillText, \u0027fill\u0027, inputs.fillColor);\n    bindInput(inputs.strokeColor, \u0027stroke\u0027, inputs.strokeText);\n    bindInput(inputs.strokeText, \u0027stroke\u0027, inputs.strokeColor);\n    bindInput(inputs.strokeWidth, \u0027stroke-width\u0027);\n    bindInput(inputs.opacity, \u0027opacity\u0027, inputs.opacityRange);\n    bindInput(inputs.opacityRange, \u0027opacity\u0027, inputs.opacity);\n    bindInput(inputs.fillOpacity, \u0027fill-opacity\u0027, inputs.fillOpacityRange);\n    bindInput(inputs.fillOpacityRange, \u0027fill-opacity\u0027, inputs.fillOpacity);\n    bindInput(inputs.strokeOpacity, \u0027stroke-opacity\u0027, inputs.strokeOpacityRange);\n    bindInput(inputs.strokeOpacityRange, \u0027stroke-opacity\u0027, inputs.strokeOpacity);\n    // \n    if (inputs.scale) {\n      inputs.scale.addEventListener(\u0027input\u0027, (e) \u003d\u003e {\n        if (inputs.scaleRange) inputs.scaleRange.value \u003d e.target.value;\n        applyTransformChange();\n      });\n    }\n    if (inputs.scaleRange) {\n      inputs.scaleRange.addEventListener(\u0027input\u0027, (e) \u003d\u003e {\n        if (inputs.scale) inputs.scale.value \u003d e.target.value;\n        applyTransformChange();\n      });\n    }\n    document.addEventListener(\u0027keydown\u0027, handleKeyDown);\n  }\n  function open(svgString, callback) {\n    onSaveCallback \u003d callback;\n    canvas.innerHTML \u003d svgString;\n    currentSvgElement \u003d canvas.querySelector(\u0027svg\u0027);\n    if (!currentSvgElement) {\n      alert(\u0027有効なSVGコードではありません。\u0027);\n      return;\n    }\n    loadCanvasSettings();\n    // \n    selectionRectElement \u003d document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n    selectionRectElement.id \u003d \"selectionRect\";\n    selectionRectElement.style.fill \u003d \"rgba(0, 120, 255, 0.1)\";\n    selectionRectElement.style.stroke \u003d \"rgba(0, 120, 255, 0.5)\";\n    selectionRectElement.style.display \u003d \"none\";\n    currentSvgElement.appendChild(selectionRectElement);\n    // \n    createResizeHandles();\n    // \n    canvas.addEventListener(\u0027mousedown\u0027, handleMouseDown);\n    // \n    window.addEventListener(\u0027mousemove\u0027, handleMouseMove);\n    window.addEventListener(\u0027mouseup\u0027, handleMouseUp);\n    undoStack \u003d [];\n    redoStack \u003d [];\n    selectedElements \u003d [];\n    updateUiState();\n    modal.style.display \u003d \u0027flex\u0027;\n  }\n  // \n  function createResizeHandles() {\n    resizeHandlesGroup \u003d document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\n    resizeHandlesGroup.id \u003d \"resizeHandles\";\n    resizeHandlesGroup.style.display \u003d \"none\";\n    const handles \u003d [\n      { id: \u0027nw\u0027, cursor: \u0027nw-resize\u0027 }, { id: \u0027n\u0027, cursor: \u0027n-resize\u0027 }, { id: \u0027ne\u0027, cursor: \u0027ne-resize\u0027 },\n      { id: \u0027w\u0027, cursor: \u0027w-resize\u0027 },                                    { id: \u0027e\u0027, cursor: \u0027e-resize\u0027 },\n      { id: \u0027sw\u0027, cursor: \u0027sw-resize\u0027 }, { id: \u0027s\u0027, cursor: \u0027s-resize\u0027 }, { id: \u0027se\u0027, cursor: \u0027se-resize\u0027 }\n    ];\n    handles.forEach(h \u003d\u003e {\n      const rect \u003d document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n      rect.setAttribute(\u0027width\u0027, \u00278\u0027);\n      rect.setAttribute(\u0027height\u0027, \u00278\u0027);\n      rect.setAttribute(\u0027fill\u0027, \u0027#fff\u0027);\n      rect.setAttribute(\u0027stroke\u0027, \u0027#4285F4\u0027);\n      rect.setAttribute(\u0027stroke-width\u0027, \u00271\u0027);\n      rect.style.cursor \u003d h.cursor;\n      rect.dataset.handle \u003d h.id; // \n      resizeHandlesGroup.appendChild(rect);\n    });\n    // \n    const outline \u003d document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n    outline.id \u003d \"resizeOutline\";\n    outline.setAttribute(\u0027fill\u0027, \u0027none\u0027);\n    outline.setAttribute(\u0027stroke\u0027, \u0027#4285F4\u0027);\n    outline.setAttribute(\u0027stroke-width\u0027, \u00271\u0027);\n    outline.setAttribute(\u0027stroke-dasharray\u0027, \u00274\u0027);\n    outline.style.pointerEvents \u003d \u0027none\u0027;\n    resizeHandlesGroup.insertBefore(outline, resizeHandlesGroup.firstChild);\n    currentSvgElement.appendChild(resizeHandlesGroup);\n  }\n  // \n  function selectAll() {\n    if (!currentSvgElement) return;\n    // \n    selectedElements.forEach(el \u003d\u003e el.classList.remove(\u0027svg-editor-selected\u0027));\n    selectedElements \u003d [];\n    // \n    const allElements \u003d currentSvgElement.querySelectorAll(\u0027*:not(defs):not(style):not(filter):not(#selectionRect):not(#resizeHandles):not(#resizeHandles *)\u0027);\n    // \n    allElements.forEach(el \u003d\u003e {\n      if ([\u0027path\u0027, \u0027line\u0027, \u0027polyline\u0027, \u0027rect\u0027, \u0027circle\u0027, \u0027ellipse\u0027, \u0027text\u0027, \u0027g\u0027, \u0027polygon\u0027, \u0027image\u0027].includes(el.tagName)) {\n        selectedElements.push(el);\n        el.classList.add(\u0027svg-editor-selected\u0027);\n      }\n    });\n    // \n    updateUiState();\n    updateResizeHandles();\n  }\n  // \n  function updateResizeHandles() {\n    // \n    if (selectedElements.length \u003d\u003d\u003d 0) {\n      resizeHandlesGroup.style.display \u003d \"none\";\n      return;\n    }\n    // \n    let minX \u003d Infinity, minY \u003d Infinity;\n    let maxX \u003d -Infinity, maxY \u003d -Infinity;\n    selectedElements.forEach(el \u003d\u003e {\n      const t \u003d parseTransform(el);\n      let bbox;\n      try { bbox \u003d el.getBBox(); } catch(e) { return; }\n      // \n      const elX \u003d t.x + (bbox.x * t.scaleX);\n      const elY \u003d t.y + (bbox.y * t.scaleY);\n      const elW \u003d bbox.width * t.scaleX;\n      const elH \u003d bbox.height * t.scaleY;\n      // \n      if (elX \u003c minX) minX \u003d elX;\n      if (elY \u003c minY) minY \u003d elY;\n      if (elX + elW \u003e maxX) maxX \u003d elX + elW;\n      if (elY + elH \u003e maxY) maxY \u003d elY + elH;\n    });\n    if (minX \u003d\u003d\u003d Infinity) return; // \n    resizeHandlesGroup.style.display \u003d \"block\";\n    const width \u003d maxX - minX;\n    const height \u003d maxY - minY;\n    const midX \u003d minX + width / 2;\n    const midY \u003d minY + height / 2;\n    // \n    const outline \u003d resizeHandlesGroup.querySelector(\u0027#resizeOutline\u0027);\n    outline.setAttribute(\u0027x\u0027, minX);\n    outline.setAttribute(\u0027y\u0027, minY);\n    outline.setAttribute(\u0027width\u0027, width);\n    outline.setAttribute(\u0027height\u0027, height);\n    // \n    const handles \u003d Array.from(resizeHandlesGroup.querySelectorAll(\u0027rect:not(#resizeOutline)\u0027));\n    // \n    if (selectedElements.length \u003e 1) {\n        handles.forEach(h \u003d\u003e h.style.display \u003d \u0027none\u0027);\n        return; \n    }\n    // \n    handles.forEach(rect \u003d\u003e {\n      rect.style.display \u003d \u0027block\u0027; // \n      const id \u003d rect.dataset.handle;\n      const coords \u003d {\n        nw: { x: minX, y: minY }, n:  { x: midX, y: minY }, ne: { x: maxX, y: minY },\n        w:  { x: minX, y: midY },                           e:  { x: maxX, y: midY },\n        sw: { x: minX, y: maxY }, s:  { x: midX, y: maxY }, se: { x: maxX, y: maxY }\n      };\n      if (coords[id]) {\n        rect.setAttribute(\u0027x\u0027, coords[id].x - 4);\n        rect.setAttribute(\u0027y\u0027, coords[id].y - 4);\n      }\n    });\n  }\n  function loadCanvasSettings() {\n    if (!currentSvgElement) return;\n    let w \u003d currentSvgElement.getAttribute(\u0027width\u0027);\n    let h \u003d currentSvgElement.getAttribute(\u0027height\u0027);\n    let vb \u003d currentSvgElement.getAttribute(\u0027viewBox\u0027);\n    let vbX \u003d 0, vbY \u003d 0, vbW \u003d 800, vbH \u003d 600;\n    if (vb) {\n      const parts \u003d vb.split(/\\s+|,/).filter(Boolean).map(parseFloat);\n      if (parts.length \u003d\u003d\u003d 4) [vbX, vbY, vbW, vbH] \u003d parts;\n    } else {\n      if (w) vbW \u003d parseFloat(w);\n      if (h) vbH \u003d parseFloat(h);\n      vb \u003d `${vbX} ${vbY} ${vbW} ${vbH}`;\n      currentSvgElement.setAttribute(\u0027viewBox\u0027, vb);\n    }\n    if (!w) currentSvgElement.setAttribute(\u0027width\u0027, vbW);\n    if (!h) currentSvgElement.setAttribute(\u0027height\u0027, vbH);\n    if (inputCanvasW) inputCanvasW.value \u003d parseFloat(w || vbW);\n    if (inputCanvasH) inputCanvasH.value \u003d parseFloat(h || vbH);\n    if (inputVbx) inputVbx.value \u003d vbX;\n    if (inputVby) inputVby.value \u003d vbY;\n    if (inputVbw) inputVbw.value \u003d vbW;\n    if (inputVbh) inputVbh.value \u003d vbH;\n  }\n  function updateCanvasSize() {\n    if (!currentSvgElement) return;\n    currentSvgElement.setAttribute(\u0027width\u0027, inputCanvasW.value);\n    currentSvgElement.setAttribute(\u0027height\u0027, inputCanvasH.value);\n  }\n  function updateCanvasViewBox() {\n    if (!currentSvgElement) return;\n    const x \u003d inputVbx.value || 0;\n    const y \u003d inputVby.value || 0;\n    const w \u003d inputVbw.value || 800;\n    const h \u003d inputVbh.value || 600;\n    currentSvgElement.setAttribute(\u0027viewBox\u0027, `${x} ${y} ${w} ${h}`);\n  }\n  function saveState() {\n    undoStack.push(currentSvgElement.outerHTML);\n    if (undoStack.length \u003e 20) undoStack.shift();\n    redoStack \u003d [];\n    updateUiState();\n  }\n  function undo() {\n    if (undoStack.length \u003d\u003d\u003d 0) return;\n    redoStack.push(currentSvgElement.outerHTML);\n    restoreState(undoStack.pop());\n  }\n  function redo() {\n    if (redoStack.length \u003d\u003d\u003d 0) return;\n    undoStack.push(currentSvgElement.outerHTML);\n    restoreState(redoStack.pop());\n  }\n  function restoreState(htmlState) {\n    canvas.innerHTML \u003d htmlState;\n    currentSvgElement \u003d canvas.querySelector(\u0027svg\u0027);\n    // \n    // \n    selectionRectElement \u003d document.getElementById(\u0027selectionRect\u0027);\n    resizeHandlesGroup \u003d document.getElementById(\u0027resizeHandles\u0027);\n    // \n    if (!resizeHandlesGroup) createResizeHandles();\n    if (!selectionRectElement) {\n       selectionRectElement \u003d document.createElementNS(\"http://www.w3.org/2000/svg\", \"rect\");\n       selectionRectElement.id \u003d \"selectionRect\";\n       currentSvgElement.appendChild(selectionRectElement);\n    }\n    loadCanvasSettings();\n    clearSelection();\n    updateUiState();\n  }\n  function getSvgPoint(evt) {\n    const point \u003d currentSvgElement.createSVGPoint();\n    point.x \u003d evt.clientX;\n    point.y \u003d evt.clientY;\n    return point.matrixTransform(currentSvgElement.getScreenCTM().inverse());\n  }\n  function getLocalPoint(clientX, clientY, element) {\n    const point \u003d currentSvgElement.createSVGPoint();\n    point.x \u003d clientX;\n    point.y \u003d clientY;\n    // \n    const parent \u003d element.parentNode || currentSvgElement;\n    return point.matrixTransform(parent.getScreenCTM().inverse());\n  }\n  // \n  function findNearbyElement(clientX, clientY) {\n    const HIT_RADIUS \u003d 5;\n    // \n    const allElements \u003d currentSvgElement.querySelectorAll(\u0027*:not(defs):not(style):not(filter):not(#selectionRect):not(#resizeHandles):not(#resizeHandles *)\u0027);\n    for (let i \u003d allElements.length - 1; i \u003e\u003d 0; i--) {\n      const el \u003d allElements[i];\n      if (![\u0027path\u0027, \u0027line\u0027, \u0027polyline\u0027, \u0027rect\u0027, \u0027circle\u0027, \u0027ellipse\u0027, \u0027text\u0027, \u0027g\u0027, \u0027polygon\u0027, \u0027image\u0027].includes(el.tagName)) continue;\n      // \n      if (selectedElements.includes(el)) continue;\n      // \n      try {\n        const rect \u003d el.getBoundingClientRect();\n        if (clientX \u003e\u003d rect.left - HIT_RADIUS \u0026\u0026 clientX \u003c\u003d rect.right + HIT_RADIUS \u0026\u0026\n            clientY \u003e\u003d rect.top - HIT_RADIUS \u0026\u0026 clientY \u003c\u003d rect.bottom + HIT_RADIUS) {\n          return el;\n        }\n      } catch (e) {}\n    }\n    return null;\n  }\n  function handleMouseDown(evt) {\n    if (evt.button !\u003d\u003d 0) return;\n    const target \u003d evt.target;\n    // \n    if (target \u003d\u003d\u003d canvas) {\n        evt.preventDefault();\n        clearSelection(); // \n        return;\n    }\n    // \n    if (!currentSvgElement) return; // \n    // \n    if (target.parentNode \u003d\u003d\u003d resizeHandlesGroup \u0026\u0026 target.dataset.handle) {\n        evt.preventDefault();\n        isResizing \u003d true;\n        activeResizeHandle \u003d target.dataset.handle;\n        saveState();\n        // \n        const el \u003d selectedElements[0];\n        initialTransforms.set(el, parseTransform(el));\n        try { initialBBoxes.set(el, el.getBBox()); } catch(e){}\n        dragStartClientPos \u003d { x: evt.clientX, y: evt.clientY };\n        return;\n    }\n    let isBg \u003d target \u003d\u003d\u003d currentSvgElement;\n    // \n    const isElement \u003d !isBg \u0026\u0026 target !\u003d\u003d selectionRectElement \u0026\u0026 target.parentNode !\u003d\u003d resizeHandlesGroup;\n    const point \u003d getSvgPoint(evt);\n    const isMultiSelect \u003d evt.shiftKey || evt.ctrlKey || evt.metaKey;\n    if (isElement) {\n      if (isMultiSelect) {\n        toggleSelection(target);\n        if (selectedElements.includes(target)) setupDrag(evt);\n      } else {\n        if (!selectedElements.includes(target)) selectSingle(target);\n        setupDrag(evt);\n      }\n    } else {\n      evt.preventDefault();\n      if (!isMultiSelect) clearSelection();\n      isBoxSelecting \u003d true;\n      selectionBoxStart \u003d point;\n      updateSelectionBox(point);\n      selectionRectElement.style.display \u003d \u0027block\u0027;\n    }\n  }\n  function setupDrag(evt) {\n    saveState();\n    isDragging \u003d true;\n    dragStartClientPos \u003d { x: evt.clientX, y: evt.clientY };\n    initialTransforms.clear();\n    // \n    movingElements \u003d selectedElements.filter(el \u003d\u003e {\n        let parent \u003d el.parentNode;\n        while(parent \u0026\u0026 parent !\u003d\u003d currentSvgElement) {\n            if(selectedElements.includes(parent)) return false;\n            parent \u003d parent.parentNode;\n        }\n        return true;\n    });\n    movingElements.forEach(el \u003d\u003e {\n      initialTransforms.set(el, parseTransform(el));\n    });\n  }\n  function handleMouseMove(evt) {\n    if (!currentSvgElement) return;\n    // \n    if (isResizing \u0026\u0026 selectedElements.length \u003d\u003d\u003d 1) {\n        const el \u003d selectedElements[0];\n        const initT \u003d initialTransforms.get(el);\n        const bbox \u003d initialBBoxes.get(el);\n        if (initT \u0026\u0026 bbox) {\n            // \n            const startLocal \u003d getLocalPoint(dragStartClientPos.x, dragStartClientPos.y, el);\n            const currentLocal \u003d getLocalPoint(evt.clientX, evt.clientY, el);\n            const dx \u003d currentLocal.x - startLocal.x;\n            const dy \u003d currentLocal.y - startLocal.y;\n            // \n            const oldW \u003d bbox.width * initT.scaleX;\n            const oldH \u003d bbox.height * initT.scaleY;\n            const aspectRatio \u003d oldW / oldH;\n            // \n            let newW \u003d oldW;\n            let newH \u003d oldH;\n            if (activeResizeHandle.includes(\u0027e\u0027)) newW +\u003d dx;\n            if (activeResizeHandle.includes(\u0027w\u0027)) newW -\u003d dx;\n            if (activeResizeHandle.includes(\u0027s\u0027)) newH +\u003d dy;\n            if (activeResizeHandle.includes(\u0027n\u0027)) newH -\u003d dy;\n            // \n            if (newW \u003c 1) newW \u003d 1;\n            if (newH \u003c 1) newH \u003d 1;\n            // \n            if ([\u0027nw\u0027, \u0027ne\u0027, \u0027sw\u0027, \u0027se\u0027].includes(activeResizeHandle)) {\n                // \n                if (Math.abs(newW - oldW) \u003e Math.abs((newH - oldH) * aspectRatio)) {\n                    newH \u003d newW / aspectRatio;\n                } else {\n                    newW \u003d newH * aspectRatio;\n                }\n            }\n            // \n            const newScaleX \u003d newW / bbox.width;\n            const newScaleY \u003d newH / bbox.height;\n            // \n            let newX \u003d initT.x;\n            let newY \u003d initT.y;\n            // \n            if (activeResizeHandle.includes(\u0027w\u0027)) {\n                // \n                const fixedRight \u003d initT.x + (bbox.x + bbox.width) * initT.scaleX;\n                newX \u003d fixedRight - (bbox.x + bbox.width) * newScaleX;\n            } else {\n                // \n                const fixedLeft \u003d initT.x + bbox.x * initT.scaleX;\n                newX \u003d fixedLeft - bbox.x * newScaleX;\n            }\n            // \n            if (activeResizeHandle.includes(\u0027n\u0027)) {\n                // \n                const fixedBottom \u003d initT.y + (bbox.y + bbox.height) * initT.scaleY;\n                newY \u003d fixedBottom - (bbox.y + bbox.height) * newScaleY;\n            } else {\n                // \n                const fixedTop \u003d initT.y + bbox.y * initT.scaleY;\n                newY \u003d fixedTop - bbox.y * newScaleY;\n            }\n            setTransform(el, newX, newY, newScaleX, newScaleY, initT.otherTransforms);\n            updateResizeHandles(); \n        }\n        return;\n    }\n    // \n    const point \u003d getSvgPoint(evt);\n    if (isDragging) {\n      movingElements.forEach(el \u003d\u003e {\n        const initT \u003d initialTransforms.get(el);\n        if (initT) {\n          const startLocal \u003d getLocalPoint(dragStartClientPos.x, dragStartClientPos.y, el);\n          const currentLocal \u003d getLocalPoint(evt.clientX, evt.clientY, el);\n          const dx \u003d currentLocal.x - startLocal.x;\n          const dy \u003d currentLocal.y - startLocal.y;\n          setTransform(el, initT.x + dx, initT.y + dy, initT.scaleX, initT.scaleY, initT.otherTransforms);\n        }\n      });\n      updateResizeHandles(); \n    } else if (isBoxSelecting) {\n      updateSelectionBox(point);\n    }\n  }\n  function handleMouseUp(evt) {\n    if (isDragging) {\n      isDragging \u003d false;\n      initialTransforms.clear();\n      movingElements \u003d [];\n    } else if (isResizing) {\n      isResizing \u003d false;\n      activeResizeHandle \u003d null;\n    } else if (isBoxSelecting) {\n      isBoxSelecting \u003d false;\n      selectElementsInBox();\n      selectionRectElement.style.display \u003d \u0027none\u0027;\n    }\n  }\n  function selectElementsInBox() {\n    const boxRect \u003d selectionRectElement.getBoundingClientRect();\n    const allElements \u003d currentSvgElement.querySelectorAll(\u0027*:not(defs):not(style):not(filter):not(#selectionRect):not(#resizeHandles):not(#resizeHandles *)\u0027);\n    allElements.forEach(el \u003d\u003e {\n      if (![\u0027g\u0027, \u0027text\u0027, \u0027path\u0027, \u0027rect\u0027, \u0027circle\u0027, \u0027ellipse\u0027, \u0027image\u0027, \u0027polygon\u0027, \u0027polyline\u0027].includes(el.tagName)) return;\n      try {\n        const elRect \u003d el.getBoundingClientRect();\n        const isInside \u003d (\n          elRect.left \u003e\u003d boxRect.left \u0026\u0026\n          elRect.right \u003c\u003d boxRect.right \u0026\u0026\n          elRect.top \u003e\u003d boxRect.top \u0026\u0026\n          elRect.bottom \u003c\u003d boxRect.bottom\n        );\n        if (isInside) {\n          addToSelection(el);\n        }\n      } catch (e) {}\n    });\n  }\n  function updateSelectionBox(currentPoint) {\n    const x \u003d Math.min(selectionBoxStart.x, currentPoint.x);\n    const y \u003d Math.min(selectionBoxStart.y, currentPoint.y);\n    const width \u003d Math.abs(currentPoint.x - selectionBoxStart.x);\n    const height \u003d Math.abs(currentPoint.y - selectionBoxStart.y);\n    selectionRectElement.setAttribute(\u0027x\u0027, x);\n    selectionRectElement.setAttribute(\u0027y\u0027, y);\n    selectionRectElement.setAttribute(\u0027width\u0027, width);\n    selectionRectElement.setAttribute(\u0027height\u0027, height);\n  }\n  // \n  function copySelection() {\n    if (selectedElements.length \u003d\u003d\u003d 0) return;\n    // \n    clipboard \u003d selectedElements.map(el \u003d\u003e el.cloneNode(true));\n  }\n  // \n  function cutSelection() {\n    if (selectedElements.length \u003d\u003d\u003d 0) return;\n    saveState(); // \n    copySelection(); // \n    deleteSelection(); // \n  }\n  // \n  function pasteClipboard() {\n    if (clipboard.length \u003d\u003d\u003d 0 || !currentSvgElement) return;\n    saveState(); // \n    clearSelection(); // \n    // \n    const newElements \u003d clipboard.map(el \u003d\u003e el.cloneNode(true));\n    newElements.forEach(el \u003d\u003e {\n      // \n      el.removeAttribute(\u0027id\u0027);\n      // \n      const t \u003d parseTransform(el);\n      setTransform(el, t.x + 10, t.y + 10, t.scaleX, t.scaleY, t.otherTransforms);\n      // \n      // \n      if (resizeHandlesGroup \u0026\u0026 resizeHandlesGroup.parentNode \u003d\u003d\u003d currentSvgElement) {\n          currentSvgElement.insertBefore(el, resizeHandlesGroup);\n      } else {\n          currentSvgElement.appendChild(el);\n      }\n      // \n      addToSelection(el);\n    });\n    // \n    clipboard \u003d newElements.map(el \u003d\u003e el.cloneNode(true));\n  }\n  function handleKeyDown(e) {\n    if (modal.style.display \u003d\u003d\u003d \u0027none\u0027) return;\n    // \n    const key \u003d e.key.toLowerCase();\n    const isCtrl \u003d e.ctrlKey || e.metaKey;\n    // \n    const target \u003d e.target;\n    if (target.tagName \u003d\u003d\u003d \u0027INPUT\u0027 || target.tagName \u003d\u003d\u003d \u0027TEXTAREA\u0027) {\n      return;\n    }\n    // \n    if (isCtrl \u0026\u0026 key \u003d\u003d\u003d \u0027a\u0027) {\n      e.preventDefault();\n      selectAll();\n      return;\n    }\n    // \n    if (isCtrl \u0026\u0026 key \u003d\u003d\u003d \u0027c\u0027) {\n      e.preventDefault();\n      copySelection();\n      return;\n    }\n    // \n    if (isCtrl \u0026\u0026 key \u003d\u003d\u003d \u0027x\u0027) {\n      e.preventDefault();\n      cutSelection();\n      return;\n    }\n    // \n    if (isCtrl \u0026\u0026 key \u003d\u003d\u003d \u0027v\u0027) {\n      e.preventDefault();\n      pasteClipboard();\n      return;\n    }\n    // \n    if (isCtrl \u0026\u0026 key \u003d\u003d\u003d \u0027z\u0027) {\n      e.preventDefault();\n      undo(); \n      return;\n    }\n    // \n    if (isCtrl \u0026\u0026 key \u003d\u003d\u003d \u0027y\u0027) {\n      e.preventDefault();\n      redo(); \n      return;\n    }\n    // \n    if ([\u0027Delete\u0027, \u0027Backspace\u0027].includes(e.key)) {\n      e.preventDefault();\n      deleteSelection();\n      return;\n    }\n    // \n    if (selectedElements.length \u003e 0 \u0026\u0026 [\u0027ArrowUp\u0027, \u0027ArrowDown\u0027, \u0027ArrowLeft\u0027, \u0027ArrowRight\u0027].includes(e.key)) {\n      e.preventDefault();\n      const step \u003d e.shiftKey ? 10 : 1;\n      let dx \u003d 0, dy \u003d 0;\n      if (e.key \u003d\u003d\u003d \u0027ArrowUp\u0027) dy \u003d -step;\n      if (e.key \u003d\u003d\u003d \u0027ArrowDown\u0027) dy \u003d step;\n      if (e.key \u003d\u003d\u003d \u0027ArrowLeft\u0027) dx \u003d -step;\n      if (e.key \u003d\u003d\u003d \u0027ArrowRight\u0027) dx \u003d step;\n      saveState();\n      // \n      const targets \u003d selectedElements.filter(el \u003d\u003e {\n          let parent \u003d el.parentNode;\n          while(parent \u0026\u0026 parent !\u003d\u003d currentSvgElement) {\n              if(selectedElements.includes(parent)) return false;\n              parent \u003d parent.parentNode;\n          }\n          return true;\n      });\n      targets.forEach(el \u003d\u003e {\n        const t \u003d parseTransform(el);\n        setTransform(el, t.x + dx, t.y + dy, t.scaleX, t.scaleY, t.otherTransforms);\n      });\n      updateResizeHandles();\n    }\n  }\n  function deleteSelection() {\n    if (selectedElements.length \u003d\u003d\u003d 0) return;\n    saveState();\n    selectedElements.forEach(el \u003d\u003e {\n      if (el.parentNode) el.parentNode.removeChild(el);\n    });\n    clearSelection();\n  }\n  function selectSingle(el) { clearSelection(); addToSelection(el); }\n  function toggleSelection(el) {\n    if (selectedElements.includes(el)) removeFromSelection(el);\n    else addToSelection(el);\n  }\n  function addToSelection(el) {\n    if (!selectedElements.includes(el)) {\n      selectedElements.push(el);\n      el.classList.add(\u0027svg-editor-selected\u0027);\n      // \n      el.setAttribute(\u0027vector-effect\u0027, \u0027non-scaling-stroke\u0027);\n      // \n    }\n    updateUiState();\n    updateResizeHandles();\n  }\n  function removeFromSelection(el) {\n    const idx \u003d selectedElements.indexOf(el);\n    if (idx \u003e -1) {\n      selectedElements.splice(idx, 1);\n      el.classList.remove(\u0027svg-editor-selected\u0027);\n    }\n    updateUiState();\n    updateResizeHandles();\n  }\n  function clearSelection() {\n    selectedElements.forEach(el \u003d\u003e el.classList.remove(\u0027svg-editor-selected\u0027));\n    selectedElements \u003d [];\n    updateUiState();\n    if (resizeHandlesGroup) resizeHandlesGroup.style.display \u003d \"none\";\n  }\n  // \n  function parseTransform(el) {\n    const transform \u003d el.getAttribute(\u0027transform\u0027) || \u0027\u0027;\n    let x \u003d 0, y \u003d 0, scaleX \u003d 1, scaleY \u003d 1;\n    const translateMatch \u003d transform.match(/translate\\(([^,]+)(?:[,\\s]+([^)]+))?\\)/);\n    if (translateMatch) {\n      x \u003d parseFloat(translateMatch[1]) || 0;\n      y \u003d parseFloat(translateMatch[2]) || 0;\n    }\n    const scaleMatch \u003d transform.match(/scale\\(([^)]+)\\)/);\n    if (scaleMatch) {\n      // \n      const parts \u003d scaleMatch[1].split(/[,\\s]+/).map(parseFloat);\n      scaleX \u003d parts[0] || 1;\n      scaleY \u003d (parts[1] !\u003d\u003d undefined) ? parts[1] : scaleX;\n    }\n    let otherTransforms \u003d transform\n        .replace(/translate\\([^)]+\\)/, \u0027\u0027)\n        .replace(/scale\\([^)]+\\)/, \u0027\u0027)\n        .trim();\n    return { x, y, scaleX, scaleY, otherTransforms };\n  }\n  // \n  function setTransform(el, x, y, scaleX, scaleY, otherTransforms \u003d \u0027\u0027) {\n    const newTransform \u003d `translate(${x}, ${y}) scale(${scaleX}, ${scaleY}) ${otherTransforms}`;\n    el.setAttribute(\u0027transform\u0027, newTransform.trim());\n  }\n  function applyPropertyChange(propName, value) {\n    if (selectedElements.length \u003d\u003d\u003d 0) return;\n    selectedElements.forEach(el \u003d\u003e {\n      if (propName \u003d\u003d\u003d \u0027text\u0027) {\n        if ([\u0027text\u0027, \u0027tspan\u0027].includes(el.tagName.toLowerCase())) {\n          el.textContent \u003d value;\n        }\n      } else {\n        el.setAttribute(propName, value);\n        if ([\u0027fill\u0027, \u0027stroke\u0027, \u0027stroke-width\u0027, \u0027font-size\u0027, \u0027font-family\u0027, \u0027opacity\u0027, \u0027fill-opacity\u0027, \u0027stroke-opacity\u0027].includes(propName)) {\n          el.style.setProperty(propName, value, \u0027important\u0027);\n        }\n      }\n    });\n  }\n  // \n  function applyTransformChange() {\n    if (selectedElements.length \u003d\u003d\u003d 0) return;\n    const newScale \u003d parseFloat(inputs.scale.value) || 1;\n    selectedElements.forEach(el \u003d\u003e {\n      const t \u003d parseTransform(el); // \n      let bbox;\n      try { \n        bbox \u003d el.getBBox(); // \n      } catch (e) {\n        // \n        setTransform(el, t.x, t.y, newScale, newScale, t.otherTransforms);\n        return;\n      }\n      // \n      const cx \u003d bbox.x + (bbox.width / 2);\n      const cy \u003d bbox.y + (bbox.height / 2);\n      // \n      const newX \u003d t.x + cx * (t.scaleX - newScale);\n      const newY \u003d t.y + cy * (t.scaleY - newScale);\n      // \n      setTransform(el, newX, newY, newScale, newScale, t.otherTransforms);\n    });\n    updateResizeHandles();\n  }\n  function reorderSelection(action) {\n    if (selectedElements.length \u003d\u003d\u003d 0) return;\n    saveState();\n    const elements \u003d [...selectedElements];\n    elements.forEach(el \u003d\u003e {\n      const p \u003d el.parentNode;\n      if (!p) return;\n      // \n      const insertAnchor \u003d (node) \u003d\u003e {\n          if (node \u003d\u003d\u003d resizeHandlesGroup || node \u003d\u003d\u003d selectionRectElement) return false;\n          return true;\n      };\n      if (action \u003d\u003d\u003d \u0027front\u0027) {\n        // \n        if (resizeHandlesGroup \u0026\u0026 resizeHandlesGroup.parentNode \u003d\u003d\u003d p) {\n            p.insertBefore(el, resizeHandlesGroup);\n        } else {\n            p.appendChild(el);\n        }\n      } else if (action \u003d\u003d\u003d \u0027back\u0027) {\n        let firstContent \u003d p.firstChild;\n        while (firstContent \u0026\u0026 ([\u0027defs\u0027, \u0027style\u0027, \u0027metadata\u0027].includes(firstContent.tagName))) {\n          firstContent \u003d firstContent.nextElementSibling;\n        }\n        p.insertBefore(el, firstContent);\n      } else if (action \u003d\u003d\u003d \u0027forward\u0027) {\n        let next \u003d el.nextElementSibling;\n        while(next \u0026\u0026 (next \u003d\u003d\u003d selectionRectElement || next \u003d\u003d\u003d resizeHandlesGroup)) {\n            next \u003d next.nextElementSibling;\n        }\n        if (next) {\n          p.insertBefore(el, next.nextElementSibling);\n        }\n      } else if (action \u003d\u003d\u003d \u0027backward\u0027) {\n        const prev \u003d el.previousElementSibling;\n        if (prev \u0026\u0026 ![\u0027defs\u0027, \u0027style\u0027, \u0027metadata\u0027].includes(prev.tagName)) {\n          p.insertBefore(el, prev);\n        }\n      }\n    });\n    // \n    if (resizeHandlesGroup) currentSvgElement.appendChild(resizeHandlesGroup);\n    if (selectionRectElement) currentSvgElement.appendChild(selectionRectElement);\n  }\n  function ensureHex(color) {\n    if (!color || color \u003d\u003d\u003d \u0027none\u0027 || color \u003d\u003d\u003d \u0027transparent\u0027) return \u0027#000000\u0027;\n    if (/^#[0-9A-F]{6}$/i.test(color)) return color;\n    const rgb \u003d color.match(/\\d+/g);\n    if (rgb \u0026\u0026 rgb.length \u003e\u003d 3) {\n      const r \u003d parseInt(rgb[0]);\n      const g \u003d parseInt(rgb[1]);\n      const b \u003d parseInt(rgb[2]);\n      return \"#\" + ((1 \u003c\u003c 24) + (r \u003c\u003c 16) + (g \u003c\u003c 8) + b).toString(16).slice(1).toUpperCase();\n    }\n    return \u0027#000000\u0027;\n  }\n  function updateUiState() {\n    if (undoBtn) undoBtn.disabled \u003d undoStack.length \u003d\u003d\u003d 0;\n    if (redoBtn) redoBtn.disabled \u003d redoStack.length \u003d\u003d\u003d 0;\n    if (selectedElements.length \u003d\u003d\u003d 0) {\n      noSelection.style.display \u003d \u0027block\u0027;\n      controls.style.display \u003d \u0027none\u0027;\n    } else {\n      noSelection.style.display \u003d \u0027none\u0027;\n      controls.style.display \u003d \u0027block\u0027;\n      const lastEl \u003d selectedElements[selectedElements.length - 1];\n      inputs.tagName.value \u003d selectedElements.length \u003e 1 ? `Multiple (${selectedElements.length})` : lastEl.tagName;\n      inputs.text.value \u003d lastEl.textContent ? lastEl.textContent.trim() : \u0027\u0027;\n      const style \u003d getComputedStyle(lastEl);\n      const fill \u003d style.fill \u0026\u0026 style.fill !\u003d\u003d \u0027none\u0027 ? style.fill : (lastEl.getAttribute(\u0027fill\u0027) || \u0027#000000\u0027);\n      const stroke \u003d style.stroke \u0026\u0026 style.stroke !\u003d\u003d \u0027none\u0027 ? style.stroke : (lastEl.getAttribute(\u0027stroke\u0027) || \u0027#000000\u0027);\n      const strokeW \u003d style.strokeWidth || lastEl.getAttribute(\u0027stroke-width\u0027);\n      updateColorInput(inputs.fillColor, inputs.fillText, fill);\n      updateColorInput(inputs.strokeColor, inputs.strokeText, stroke);\n      inputs.strokeWidth.value \u003d parseFloat(strokeW) || 0;\n      const op \u003d style.opacity || lastEl.getAttribute(\u0027opacity\u0027) || 1;\n      const fillOp \u003d style.fillOpacity || lastEl.getAttribute(\u0027fill-opacity\u0027) || 1;\n      const strokeOp \u003d style.strokeOpacity || lastEl.getAttribute(\u0027stroke-opacity\u0027) || 1;\n      updateRangeInput(inputs.opacity, inputs.opacityRange, op);\n      updateRangeInput(inputs.fillOpacity, inputs.fillOpacityRange, fillOp);\n      updateRangeInput(inputs.strokeOpacity, inputs.strokeOpacityRange, strokeOp);\n      const t \u003d parseTransform(lastEl);\n      if (inputs.scale) inputs.scale.value \u003d t.scaleX; // \n      if (inputs.scaleRange) inputs.scaleRange.value \u003d t.scaleX;\n    }\n  }\n  function updateColorInput(colorInput, textInput, value) {\n    if (!textInput) return;\n    textInput.value \u003d value;\n    if (colorInput) {\n      const hexValue \u003d ensureHex(value);\n      colorInput.value \u003d hexValue;\n    }\n  }\n  function updateRangeInput(numInput, rangeInput, value) {\n    if (numInput) numInput.value \u003d value;\n    if (rangeInput) rangeInput.value \u003d value;\n  }\n  function saveAndClose() {\n    // \n    if (selectionRectElement \u0026\u0026 selectionRectElement.parentNode) {\n      selectionRectElement.parentNode.removeChild(selectionRectElement);\n      selectionRectElement \u003d null;\n    }\n    if (resizeHandlesGroup \u0026\u0026 resizeHandlesGroup.parentNode) {\n        resizeHandlesGroup.parentNode.removeChild(resizeHandlesGroup);\n        resizeHandlesGroup \u003d null;\n    }\n    if (currentSvgElement) {\n        const selectedEls \u003d currentSvgElement.querySelectorAll(\u0027.svg-editor-selected\u0027);\n        selectedEls.forEach(el \u003d\u003e el.classList.remove(\u0027svg-editor-selected\u0027));\n    }\n    clearSelection();\n    const newSvgString \u003d currentSvgElement.outerHTML;\n    if (onSaveCallback) {\n      onSaveCallback(newSvgString);\n    }\n    close();\n  }\n  function close() {\n    // \n    canvas.removeEventListener(\u0027mousedown\u0027, handleMouseDown);\n    // \n    window.removeEventListener(\u0027mousemove\u0027, handleMouseMove);\n    window.removeEventListener(\u0027mouseup\u0027, handleMouseUp);\n    modal.style.display \u003d \u0027none\u0027;\n    canvas.innerHTML \u003d \u0027\u0027;\n    currentSvgElement \u003d null;\n    selectedElements \u003d [];\n    if (typeof window.adjustResponsiveLayout \u003d\u003d\u003d \u0027function\u0027) {\n      window.adjustResponsiveLayout();\n    }\n  }\n  document.addEventListener(\u0027DOMContentLoaded\u0027, init);\n  return { open: open };\n})();\n// \n    // \n// \nconst SlideEditor \u003d (function() {\n    let slideData \u003d []; // \n    let currentIndex \u003d 0; // \n    let isEditorActive \u003d false; // \n    // \n    let editorContainer \u003d null;\n    // \n    let statusContainer \u003d null;\n    let mainTextarea \u003d null;\n    // \n    let step1Card \u003d null;\n    let previewToggleButton \u003d null; // \n    function init() {\n        mainTextarea \u003d $(\u0027slideDataInput\u0027);\n        statusContainer \u003d $(\u0027validationStatus\u0027); \n        previewToggleButton \u003d $(\u0027showLastSlideBtn\u0027); \n        try {\n            const h2 \u003d Array.from(document.querySelectorAll(\u0027.card-header\u0027)).find(el \u003d\u003e el.textContent.trim().startsWith(\u0027Geminiで\u0027));\n            if (h2) {\n                step1Card \u003d h2.closest(\u0027.card\u0027);\n            }\n        } catch(e) { console.warn(\u0027Could not find Step 1 card to hide.\u0027); }\n        // \n        editorContainer \u003d document.createElement(\u0027div\u0027);\n        editorContainer.id \u003d \u0027slideEditorUI\u0027;\n        editorContainer.style.display \u003d \u0027none\u0027;\n        editorContainer.style.border \u003d \u00271px solid var(--border-color)\u0027;\n        editorContainer.style.borderRadius \u003d \u0027var(--radius-md)\u0027;\n        editorContainer.style.padding \u003d \u00271.5rem\u0027;\n        editorContainer.style.background \u003d \u0027var(--bg-surface)\u0027;\n        editorContainer.style.marginBottom \u003d \u00271rem\u0027;\n        // \n        const buttonGroup \u003d $(\u0027buttonGroup\u0027); \n        if (buttonGroup \u0026\u0026 buttonGroup.parentNode) {\n            // \n            buttonGroup.parentNode.insertBefore(editorContainer, buttonGroup.nextSibling); \n        } else {\n            mainTextarea.parentNode.insertBefore(editorContainer, mainTextarea.nextSibling);\n        }\n        // \n        editorContainer.addEventListener(\u0027click\u0027, function(event) {\n            // \n            const navBtn \u003d event.target.closest(\u0027#editorPrevBtn, #editorNextBtn\u0027);\n            if (navBtn \u0026\u0026 !navBtn.disabled) {\n                event.preventDefault();\n                if (navBtn.id \u003d\u003d\u003d \u0027editorPrevBtn\u0027 \u0026\u0026 currentIndex \u003e 0) {\n                    currentIndex--;\n                    renderEditorUI();\n                } else if (navBtn.id \u003d\u003d\u003d \u0027editorNextBtn\u0027 \u0026\u0026 currentIndex \u003c slideData.length - 1) {\n                    currentIndex++;\n                    renderEditorUI();\n                }\n                updatePreviewButtonForEditor(true);\n                return;\n            }\n            // \n            const actionBtn \u003d event.target.closest(\u0027button[data-action]\u0027);\n            if (actionBtn) {\n                event.preventDefault();\n                const action \u003d actionBtn.dataset.action;\n                const pathString \u003d actionBtn.dataset.path;\n                try {\n                    if (action \u003d\u003d\u003d \u0027add\u0027) {\n                        const path \u003d pathString.replace(\u0027editor_field_\u0027, \u0027\u0027).split(\u0027_\u0027);\n                        const { parent, lastKey } \u003d getObjectFromPath(path);\n                        if (!Array.isArray(parent[lastKey])) throw new Error(`Target is not an array: ${pathString}`);\n                        const array \u003d parent[lastKey];\n                        const newItem \u003d getNewItemShape(lastKey, array);\n                        array.push(newItem);\n                        renderEditorUI();\n                    } else if (action \u003d\u003d\u003d \u0027delete\u0027) {\n                // \n                const deleteLogic \u003d () \u003d\u003e {\n                    const path \u003d pathString.replace(\u0027editor_field_\u0027, \u0027\u0027).split(\u0027_\u0027);\n                    const index \u003d parseInt(path.pop(), 10);\n                    const { parent, lastKey } \u003d getObjectFromPath(path); // \n                    if (!Array.isArray(parent[lastKey])) throw new Error(`Target is not an array: ${pathString}`);\n                    parent[lastKey].splice(index, 1);\n                    renderEditorUI(); // \n                };\n                // \n                showDeleteItemConfirmModal(deleteLogic);\n            }\n                } catch (e) {\n                    console.error(\"Failed to update array:\", e);\n                    showStatus(\u0027エラー: 項目の追加/削除に失敗しました\u0027, \u0027error\u0027);\n                }\n                return;\n            }\n        });\n        editorContainer.addEventListener(\u0027input\u0027, function(event) {\n            const field \u003d event.target.closest(\u0027input, textarea, select\u0027);\n            if (!field || !field.id) return;\n            if (field.type \u003d\u003d\u003d \u0027color\u0027 \u0026\u0026 field.id.endsWith(\u0027_picker\u0027)) {\n                const textInput \u003d $(field.id.replace(\u0027_picker\u0027, \u0027\u0027));\n                if (textInput) {\n                    textInput.value \u003d field.value;\n                    updateDataFromField(textInput);\n                }\n            } else if (field.type \u003d\u003d\u003d \u0027text\u0027 \u0026\u0026 $(field.id + \u0027_picker\u0027)) {\n                const picker \u003d $(field.id + \u0027_picker\u0027);\n                if (isColorString(field.value)) {\n                    picker.value \u003d field.value;\n                    field.style.borderColor \u003d \u0027var(--border-color)\u0027;\n                } else {\n                    field.style.borderColor \u003d \u0027var(--danger-color)\u0027;\n                }\n                updateDataFromField(field);\n            } else {\n                updateDataFromField(field);\n            }\n            if (field.tagName \u003d\u003d\u003d \u0027TEXTAREA\u0027 \u0026\u0026 field.nextElementSibling \u0026\u0026 field.nextElementSibling.classList.contains(\u0027svg-preview-container\u0027)) {\n                // \n                field.nextElementSibling.innerHTML \u003d field.value;\n            }\n        });\n    }\n    // \n    function setEditorMode(shouldActivate, options \u003d {}) {\n        const validationDiv \u003d $(\u0027jsonValidation\u0027); // \n        const editorDiv \u003d editorContainer;\n        const buttonGroupDiv \u003d $(\u0027buttonGroup\u0027);\n        const textareaDiv \u003d mainTextarea;\n        if (!validationDiv || !editorDiv || !buttonGroupDiv || !textareaDiv) {\n            console.error(\u0027SlideEditor: レイアウト変更に必要なDOM要素が見つかりません\u0027);\n            return false;\n        }\n        const parent \u003d validationDiv.parentNode; // \n        if (shouldActivate) {\n            // \n            if (isEditorActive) return true; // \n            try {\n                const parsed \u003d JSON.parse(textareaDiv.value);\n                if (!Array.isArray(parsed) || parsed.length \u003d\u003d\u003d 0) {\n                    throw new Error(\u0027データが配列でないか、空です\u0027);\n                }\n                slideData \u003d parsed;\n                slideData.forEach(slide \u003d\u003e {\n                    if (typeof slide.image \u003d\u003d\u003d \u0027string\u0027 \u0026\u0026 slide.image.trim().startsWith(\u0027{\u0027)) {\n                        try {\n                            // \n                            const chartObj \u003d JSON.parse(slide.image);\n                            // \n                            if (chartObj \u0026\u0026 chartObj.chartType) {\n                                slide.image \u003d chartObj;\n                            }\n                        } catch (e) {\n                            // \n                        }\n                    }\n                });\n            } catch (e) {\n                showJsonErrorModal(\u0027エラー: JSONデータが不正なため編集モードに移行できません\\n\u0027 + e.message); // \n                return false;\n            }\n            textareaDiv.style.display \u003d \u0027none\u0027;\n            if (step1Card) step1Card.style.display \u003d \u0027none\u0027;\n            // \n            parent.insertBefore(buttonGroupDiv, validationDiv.nextSibling); \n            editorDiv.style.display \u003d \u0027block\u0027;\n            buttonGroupDiv.style.marginBottom \u003d \u00271rem\u0027;\n            buttonGroupDiv.style.marginTop \u003d \u00270\u0027;\n            currentIndex \u003d 0;\n            isEditorActive \u003d true;\n            renderEditorUI();\n            updatePreviewButtonForEditor(true); // \n            // \n            validationDiv.style.display \u003d \u0027none\u0027;\n            return true;\n        } else {\n            // \n            if (!isEditorActive) return true; // \n            try {\n                textareaDiv.value \u003d JSON.stringify(slideData, null, 2);\n            } catch (e) {\n                showJsonErrorModal(\u0027エラー: 編集内容をテキストに変換できませんでした\\n\u0027 + e.message); // \n            }\n            textareaDiv.style.display \u003d \u0027block\u0027;\n            if (step1Card) step1Card.style.display \u003d \u0027block\u0027;\n            editorDiv.style.display \u003d \u0027none\u0027;\n            // \n            parent.insertBefore(buttonGroupDiv, editorDiv.nextSibling); \n            buttonGroupDiv.style.marginBottom \u003d \u0027\u0027;\n            buttonGroupDiv.style.marginTop \u003d \u0027\u0027;\n            isEditorActive \u003d false;\n            updatePreviewButtonForEditor(false); // \n            if (!options.skipValidation) {\n                // \n                suppressEditorAutoActivation \u003d true; // \n                try {\n                    validateJSON(); \n                } finally {\n                    suppressEditorAutoActivation \u003d false;\n                }\n            }\n            // \n            validationDiv.style.display \u003d \u0027none\u0027;\n            textareaDiv.focus();\n            return true;\n        }\n    }\n    function enterEditorMode() {\n        return setEditorMode(true);\n    }\n    function exitEditorMode(options) {\n        return setEditorMode(false, options);\n    }\n    function reset() {\n        slideData \u003d [];\n        currentIndex \u003d 0;\n        if (isEditorActive) {\n            exitEditorMode({ skipValidation: true });\n        }\n        isEditorActive \u003d false; \n        if (editorContainer) editorContainer.style.display \u003d \u0027none\u0027;\n        if (mainTextarea) {\n            mainTextarea.value \u003d \u0027\u0027;\n            mainTextarea.style.display \u003d \u0027block\u0027;\n        }\n        if (step1Card) step1Card.style.display \u003d \u0027block\u0027;\n        if (typeof updatePreviewButtonForEditor \u003d\u003d\u003d \u0027function\u0027) {\n            updatePreviewButtonForEditor(false);\n        }\n        // \n        const validationDiv \u003d $(\u0027jsonValidation\u0027);\n        if(validationDiv) validationDiv.style.display \u003d \u0027none\u0027;\n        // \n        if (typeof adjustTextAreaHeight \u003d\u003d\u003d \u0027function\u0027) {\n            setTimeout(adjustTextAreaHeight, 0);\n        }\n    }\n    function setupForUpdate() {\n        // \n        enterEditorMode();\n        // \n        if (typeof updatePreviewButtonForEditor \u003d\u003d\u003d \u0027function\u0027) {\n            updatePreviewButtonForEditor(true); // \n        }\n        // \n        const updateBtn \u003d $(\u0027updatePageBtn\u0027);\n        const generateBtn \u003d $(\u0027generateBtn\u0027);\n        if (updateBtn \u0026\u0026 generateBtn) {\n             // \n             updateBtn.style.display \u003d \u0027inline-flex\u0027;\n             updateBtn.querySelector(\u0027.btn-text\u0027).textContent \u003d \u00271ページ目を更新\u0027;\n             // \n             updateBtn.classList.remove(\u0027btn-secondary\u0027);\n             updateBtn.classList.add(\u0027btn-primary\u0027);\n             updateBtn.style.backgroundColor \u003d \u0027\u0027; // \n             // \n             generateBtn.querySelector(\u0027.btn-text\u0027).textContent \u003d \u0027スライドを更新\u0027; \n        }\n    }\n    function renderEditorUI() {\n        if (!slideData || slideData.length \u003d\u003d\u003d 0) {\n            editorContainer.innerHTML \u003d \u0027\u003cp\u003eデータがありません。\u003c/p\u003e\u0027;\n            return;\n        }\n        if (currentIndex \u003c 0) currentIndex \u003d 0;\n        if (currentIndex \u003e\u003d slideData.length) currentIndex \u003d slideData.length - 1;\n        const currentSlide \u003d slideData[currentIndex];\n        let slideTypeDisplay \u003d currentSlide.type || \u0027N/A\u0027;\n        if (typeof currentSlide.image \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026 currentSlide.image !\u003d\u003d null \u0026\u0026 currentSlide.image.chartType) {\n            slideTypeDisplay +\u003d ` \u003cspan style\u003d\"font-weight: 400; color: var(--text-secondary); font-size: 0.9em;\"\u003e(${currentSlide.image.chartType})\u003c/span\u003e`;\n        }\n        let navHTML \u003d `\n            \u003cdiv style\u003d\"display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px solid var(--border-color);\"\u003e\n                \u003cbutton id\u003d\"editorPrevBtn\" class\u003d\"btn-secondary\" style\u003d\"text-transform: none; ${currentIndex \u003d\u003d\u003d 0 ? \u0027visibility: hidden;\u0027 : \u0027\u0027}\" ${currentIndex \u003d\u003d\u003d 0 ? \u0027disabled\u0027 : \u0027\u0027}\u003e\n                    \u003cspan class\u003d\"nav-text-full\"\u003e\u003c 前のページ\u003c/span\u003e\n                    \u003cspan class\u003d\"nav-text-short\"\u003e\u003c 前\u003c/span\u003e\n                \u003c/button\u003e\n                \u003cspan style\u003d\"font-size: 0.875rem; text-align: center;\"\u003e\n                    \u003cspan class\u003d\"nav-text-full\"\u003eスライド ${currentIndex + 1} / ${slideData.length}\u003c/span\u003e\n                    \u003cspan class\u003d\"nav-text-short\"\u003e${currentIndex + 1} / ${slideData.length}\u003c/span\u003e\n                    \u003cstrong style\u003d\"display: block; font-size: 1rem; color: var(--primary-color);\"\u003e${slideTypeDisplay}\u003c/strong\u003e\n                \u003c/span\u003e\n                \u003cdiv style\u003d\"display: flex; gap: 0.5rem; align-items: center;\"\u003e\n                    \u003cbutton id\u003d\"editorNextBtn\" class\u003d\"btn-secondary\" style\u003d\"text-transform: none; ${currentIndex \u003d\u003d\u003d slideData.length - 1 ? \u0027visibility: hidden;\u0027 : \u0027\u0027}\" ${currentIndex \u003d\u003d\u003d slideData.length - 1 ? \u0027disabled\u0027 : \u0027\u0027}\u003e\n                        \u003cspan class\u003d\"nav-text-full\"\u003e次のページ \u003e\u003c/span\u003e\n                        \u003cspan class\u003d\"nav-text-short\"\u003e次 \u003e\u003c/span\u003e\n                    \u003c/button\u003e\n                \u003c/div\u003e\n            \u003c/div\u003e\n        `;\n        let formCSS \u003d `\n            \u003cstyle\u003e\n                .svg-preview-container svg {\n                    max-width: 100% !important;\n                    height: auto !important;\n                }\n                #editorFormArea .form-group-grid { display: flex; align-items: flex-start; gap: 0.75rem; padding: 0.5rem 0; border-bottom: 1px solid #f3f4f6; }\n                #editorFormArea .editor-form-label { flex-shrink: 0; font-weight: 500; font-size: 0.8125rem; color: var(--text-secondary); margin-top: 0.5rem; text-align: right; padding-right: 0.75rem; line-height: 1.4; white-space: nowrap; box-sizing: border-box; width: var(--label-width, 120px); }\n                #editorFormArea .field-wrapper { flex-grow: 1; min-width: 0; position: relative; display: flex; align-items: flex-start; gap: 0.5rem; }\n                #editorFormArea .field-wrapper \u003e *:first-child:not(.btn-delete) { flex-grow: 1; }\n                #editorFormArea .field-wrapper textarea { width: 100%; resize: none; overflow: hidden; }\n                #editorFormArea .field-wrapper input[type\u003d\"text\"], #editorFormArea .field-wrapper select { width: 100%; }\n                #editorFormArea .btn-delete { background: none; border: none; color: var(--text-light); border-radius: 50%; width: 20px; height: 20px; font-size: 1.3rem; line-height: 1; cursor: pointer; padding: 0; font-weight: 400; flex-shrink: 0; margin-top: 0.4rem; }\n                #editorFormArea .btn-delete:hover { background: var(--bg-body); color: var(--text-secondary); }\n                #editorFormArea fieldset { border: 1px solid var(--border-color); border-radius: var(--radius-md); padding: 0.75rem 1rem 1rem 1rem; margin: 0; }\n                #editorFormArea fieldset legend { font-weight: 600; font-size: 0.9rem; color: var(--text-primary); padding: 0 0.5rem; margin-left: 0.5rem; }\n                #editorFormArea .array-item { border-bottom: 1px dashed var(--border-color); padding-bottom: 0.5rem; margin-bottom: 0.5rem; }\n                #editorFormArea .array-item:last-child { border-bottom: none; padding-bottom: 0; margin-bottom: 0; }\n                #editorFormArea .array-add-btn { margin-top: 0.75rem; }\n                .clear-button-wrapper { display: flex;\n                    align-items: center; margin-top: 1rem; clear: both; }\n                #editorClearBtn {\n                    margin-left: auto; \n                    text-transform: none;\n                    font-size: 0.875rem; padding: 0.5rem 1rem; width: auto; background-color: var(--secondary-color); color: white;\n                }\n                #editorClearBtn:hover { background-color: var(--danger-color); color: white; }\n                .btn-text-short-ver { display: none; }\n                .btn-text-full-ver { display: inline; }\n                @media (max-width: 600px) {\n                    .btn-text-short-ver { display: inline; }\n                    .btn-text-full-ver { display: none; }\n                }\n                #left-pane.narrow-layout .btn-text-short-ver { display: inline; }\n                #left-pane.narrow-layout .btn-text-full-ver { display: none; }\n            \u003c/style\u003e\n        `;\n        let formHTML \u003d `\u003cdiv id\u003d\"editorFormArea\" style\u003d\"padding-top: 0.5rem;\"\u003e\u003c/div\u003e`;\n        editorContainer.innerHTML \u003d navHTML + formCSS + formHTML;\n        renderSlideEditorForm(currentSlide);\n        const formArea \u003d $(\u0027editorFormArea\u0027);\n        if (formArea) {\n          // \n          // \n          const hasSummarySlide \u003d slideData.some(s \u003d\u003e s.isSummary \u003d\u003d\u003d true);\n          // \n          const isCurrentSlideSummary \u003d currentSlide.isSummary \u003d\u003d\u003d true;\n          // \n          const shouldShowSummaryBtn \u003d !hasSummarySlide || isCurrentSlideSummary;\n          let summaryBtnHTML \u003d \u0027\u0027;\n          if (shouldShowSummaryBtn) {\n              const summaryBtnTextFull \u003d isCurrentSlideSummary ? \u0027要約画像を変更\u0027 : \u0027要約スライドを追加\u0027;\n              const summaryBtnTextShort \u003d isCurrentSlideSummary ? \u0027画像変更\u0027 : \u0027要約を追加\u0027;\n              // \n              summaryBtnHTML \u003d `\n              \u003cbutton id\u003d\"editorAddSummaryBtn\" type\u003d\"button\" \n                     style\u003d\"\n                        padding: 0.5rem 1.0rem;\n                        font-size: 0.8rem;\n                        font-weight: 600;\n                        color: var(--text-on-primary, #FFFFFF);\n                        background-color: rgba(var(--primary-color-rgb, 66, 133, 244), 0.8);\n                        backdrop-filter: blur(4px);\n                        -webkit-backdrop-filter: blur(4px);\n                        border: none;\n                        border-radius: 9999px;\n                        box-shadow: var(--shadow-sm);\n                        cursor: pointer;\n                        transition: all 0.2s ease;\n                        white-space: nowrap;\n                        display: inline-flex;\n                        justify-content: center;\n                        align-items: center;\n                     \"\n                     onmouseover\u003d\"this.style.backgroundColor\u003d\u0027rgba(var(--primary-color-rgb, 66, 133, 244), 1.0)\u0027\"\n                     onmouseout\u003d\"this.style.backgroundColor\u003d\u0027rgba(var(--primary-color-rgb, 66, 133, 244), 0.8)\u0027\"\n                \u003e\n                  \u003cspan class\u003d\"btn-text-full-ver\"\u003e${summaryBtnTextFull}\u003c/span\u003e\n                  \u003cspan class\u003d\"btn-text-short-ver\"\u003e${summaryBtnTextShort}\u003c/span\u003e\n               \u003c/button\u003e`;\n          }\n          // \n          // \n          formArea.innerHTML +\u003d `\n            \u003cdiv class\u003d\"clear-button-wrapper\"\u003e\n              ${summaryBtnHTML}\n              \u003cbutton id\u003d\"editorClearBtn\" class\u003d\"btn\"\u003e\n                  \u003cspan class\u003d\"btn-text-full-ver\"\u003eデータをクリア\u003c/span\u003e\n                  \u003cspan class\u003d\"btn-text-short-ver\"\u003eクリア\u003c/span\u003e\n              \u003c/button\u003e\n            \u003c/div\u003e\n           `;\n        }\n        optimizeLabelWidths();\n        initTextareaAutosize();\n        // \n        const clearBtn \u003d $(\u0027editorClearBtn\u0027);\n        if (clearBtn) {\n            clearBtn.addEventListener(\u0027click\u0027, function(event) {\n                event.preventDefault();\n                showClearConfirmModal(); \n            });\n        }\n        // \n        const addSummaryBtn \u003d $(\u0027editorAddSummaryBtn\u0027);\n        if (addSummaryBtn) {\n            addSummaryBtn.addEventListener(\u0027click\u0027, function(event) {\n                event.preventDefault();\n                const summaryModal \u003d $(\u0027summaryPromptModal\u0027);\n                const summaryTextarea \u003d $(\u0027summaryPromptTextarea\u0027);\n                // \n                const currentData \u003d SlideEditor.getSlideData();\n                const currentJson \u003d JSON.stringify(currentData, null, 2);\n                if (!currentJson) {\n                    showStatus(\u0027JSONデータがありません。\u0027, \u0027error\u0027);\n                    return;\n                }\n                const promptText \u003d \n`以下のJSONデータは、現在作成中のスライド構成です。\nこのプレゼンテーションの内容全体を総括する「まとめ（Summary）」のインフォグラフィック画像を1枚作成し、\n画像データとして出力してください。\n【条件】\n1. \n2. \n3. \n【現在のスライド構成データ】\n${currentJson}`;\n                if (summaryTextarea) summaryTextarea.value \u003d promptText;\n                if (summaryModal) summaryModal.style.display \u003d \u0027flex\u0027;\n            });\n        }\n    }\n    function renderSlideEditorForm(slide) {\n        const formArea \u003d $(\u0027editorFormArea\u0027);\n        if (!formArea) return;\n        let html \u003d \u0027\u0027;\n        // \n        const commonFieldOrder \u003d [\n            \u0027type\u0027,          // \n            \u0027title\u0027,         // \n            \u0027sectionNo\u0027,     // \n            \u0027subhead\u0027,       // \n            \u0027date\u0027,          // \n            // \n            \u0027imagePosition\u0027, // \n            // \n            \u0027centerText\u0027,    // \n            \u0027points\u0027,        // \n            \u0027items\u0027,         // \n            \u0027steps\u0027,         // \n            \u0027milestones\u0027,    // \n            \u0027stats\u0027,         // \n            \u0027headers\u0027,       // \n            \u0027rows\u0027,          // \n            \u0027columns\u0027,       // \n            \u0027lanes\u0027,         // \n            \u0027levels\u0027,        // \n            \u0027flows\u0027,         // \n            \u0027leftTitle\u0027,     // \n            \u0027leftItems\u0027,     // \n            \u0027rightTitle\u0027,    // \n            \u0027rightItems\u0027,    // \n            // \n            \u0027image\u0027,         // \n            \u0027imageCaption\u0027,  // \n            // \n            \u0027showTrends\u0027,    // \n            \u0027notes\u0027          // \n        ];\n        // \n        commonFieldOrder.forEach(key \u003d\u003e {\n            if (slide.hasOwnProperty(key)) {\n                html +\u003d createFormField(slide, key, slide[key]);\n            }\n        });\n        // \n        Object.keys(slide).forEach(key \u003d\u003e {\n            if (!commonFieldOrder.includes(key)) {\n                html +\u003d createFormField(slide, key, slide[key]);\n            }\n        });\n        formArea.innerHTML \u003d html;\n    }\n    function createFormField(parentObject, key, value, idPrefix \u003d \u0027editor_field_\u0027) {\n         // \n         const labelMap \u003d {\n            title: \u0027タイトル\u0027,\n            date: \u0027日付\u0027,\n            notes: \u0027スピーカーノート\u0027,\n            subhead: \u0027サブヘッド\u0027,\n            sectionNo: \u0027セクション番号\u0027,\n            points: \u0027箇条書き\u0027,\n            columns: \u0027カラム\u0027,\n            items: \u0027項目\u0027,\n            leftTitle: \u0027左タイトル\u0027,\n            rightTitle: \u0027右タイトル\u0027,\n            leftItems: \u0027左の項目\u0027,\n            rightItems: \u0027右の項目\u0027,\n            steps: \u0027ステップ\u0027,\n            milestones: \u0027マイルストーン\u0027,\n            label: \u0027ラベル\u0027,\n            state: \u0027状態\u0027,\n            lanes: \u0027レーン\u0027,\n            centerText: \u0027中央テキスト\u0027,\n            headers: \u0027ヘッダー\u0027,\n            rows: \u0027行\u0027,\n            percent: \u0027パーセント\u0027,\n            text: \u0027テキスト\u0027,\n            author: \u0027引用元\u0027,\n            value: \u0027値\u0027,\n            change: \u0027変化\u0027,\n            status: \u0027ステータス\u0027,\n            q: \u0027質問\u0027,\n            a: \u0027回答\u0027,\n            stats: \u0027統計\u0027,\n            leftValue: \u0027左の値\u0027,\n            rightValue: \u0027右の値\u0027,\n            trend: \u0027傾向\u0027,\n            showTrends: \u0027傾向表示\u0027,\n            levels: \u0027レベル\u0027,\n            description: \u0027説明\u0027,\n            desc: \u0027詳細\u0027,\n            flows: \u0027フロー\u0027,\n            image: \u0027画像/グラフ\u0027,\n            imageCaption: \u0027画像キャプション\u0027,\n            imagePosition: \u0027画像の位置\u0027,\n            // \n            chartType: \u0027グラフ種別\u0027,\n            data: \u0027データ\u0027,\n            subtitle: \u0027サブタイトル\u0027,\n            source: \u0027出典\u0027,\n            yAxisUnitLabel: \u0027Y軸単位\u0027,\n            xAxisLabels: \u0027X軸ラベル\u0027,\n            series: \u0027系列\u0027,\n            values: \u0027値 (配列)\u0027,\n            colors: \u0027色設定\u0027,\n            color: \u0027色 (単一/棒)\u0027, // \n            line: \u0027線の色\u0027, // \n            id: \u0027ID\u0027,\n            start: \u0027開始色\u0027,\n            end: \u0027終了色\u0027,\n            centerLabel: \u0027中央ラベル\u0027,\n            legendLabels: \u0027凡例ラベル\u0027,\n            barData: \u0027棒データ\u0027,\n            barValue: \u0027棒の値\u0027,\n            lineValue: \u0027線の値\u0027,\n            legendBarLabel: \u0027棒の凡例\u0027,\n            legendLineLabel: \u0027線の凡例\u0027,\n            yAxisLeftLabel: \u0027左Y軸ラベル\u0027,\n            yAxisRightLabel: \u0027右Y軸ラベル\u0027\n         };\n         // \n         const fieldId \u003d `${idPrefix}${key}`;\n         const currentSlideType \u003d slideData[currentIndex].type;\n         const isGraphDataArray \u003d idPrefix.startsWith(\u0027editor_field_image_data_\u0027);\n         const isArrayPrimitive \u003d idPrefix.endsWith(\u0027_\u0027) \u0026\u0026 /^\\d+$/.test(key);\n         // \n         if (String(key).startsWith(\u0027_\u0027) ||\n            (key \u003d\u003d\u003d \u0027type\u0027 \u0026\u0026 idPrefix \u003d\u003d\u003d \u0027editor_field_\u0027) ||\n            (key \u003d\u003d\u003d \u0027twoColumn\u0027) ||\n            (key \u003d\u003d\u003d \u0027isSummary\u0027) ||\n            (key \u003d\u003d\u003d \u0027columns\u0027 \u0026\u0026 currentSlideType \u003d\u003d\u003d \u0027cards\u0027) ||\n            (idPrefix.startsWith(\u0027editor_field_image_data_\u0027) \u0026\u0026 [\u0027layout\u0027, \u0027yAxis\u0027, \u0027barOptions\u0027, \u0027lineOptions\u0027, \u0027yAxisLeft\u0027, \u0027yAxisRight\u0027].includes(key)) ||\n            (idPrefix \u003d\u003d\u003d \u0027editor_field_image_\u0027 \u0026\u0026 key \u003d\u003d\u003d \u0027chartType\u0027)) {\n            return \u0027\u0027;\n}\n         // \n         let labelText;\n         if (isArrayPrimitive) {\n           // \n           labelText \u003d `${parseInt(key, 10) + 1}`;\n         } else {\n           // \n           labelText \u003d labelMap[key] || key;\n         }\n         // \n         if (idPrefix.startsWith(\u0027editor_field_image_data_barData_\u0027) \u0026\u0026 key \u003d\u003d\u003d \u0027label\u0027) {\n             labelText \u003d \u0027X軸項目\u0027;\n         }\n         if (idPrefix.startsWith(\u0027editor_field_image_data_items_\u0027) \u0026\u0026 key \u003d\u003d\u003d \u0027label\u0027) {\n             labelText \u003d \u0027凡例項目\u0027;\n         }\n         // \n        let fieldHTML \u003d \u0027\u0027;\n        let helpTextHTML \u003d \u0027\u0027;\n        const onInput \u003d `oninput\u003d\"SlideEditor.autoResizeTextarea(this)\"`;\n        if (Array.isArray(value)) {\n            let arrayItemsHTML \u003d \u0027\u0027;\n            value.forEach((item, index) \u003d\u003e {\n                const itemPrefix \u003d `${fieldId}_${index}_`;\n                let itemFieldsHTML \u003d \u0027\u0027;\n                if (typeof item \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026 item !\u003d\u003d null) {\n                    Object.keys(item).forEach(subKey \u003d\u003e {\n                         itemFieldsHTML +\u003d createFormField(item, subKey, item[subKey], itemPrefix);\n                    });\n                } else {\n                    itemFieldsHTML +\u003d createFormField(value, index, item, `${fieldId}_`);\n                }\n                arrayItemsHTML +\u003d `\u003cdiv class\u003d\"array-item\"\u003e${itemFieldsHTML}\u003c/div\u003e`;\n            });\n            let addButtonHTML \u003d \u0027\u0027;\n            const isColumns \u003d key \u003d\u003d\u003d \u0027columns\u0027;\n            const isLanesArrayItself \u003d idPrefix \u003d\u003d\u003d \u0027editor_field_\u0027 \u0026\u0026 key \u003d\u003d\u003d \u0027lanes\u0027;\n            const isCardsItems \u003d currentSlideType \u003d\u003d\u003d \u0027cards\u0027 \u0026\u0026 key \u003d\u003d\u003d \u0027items\u0027;\n            if (!isColumns \u0026\u0026 !isLanesArrayItself \u0026\u0026 !isCardsItems \u0026\u0026 !isGraphDataArray) {\n                addButtonHTML \u003d `\u003cbutton class\u003d\"btn-preset array-add-btn\" data-action\u003d\"add\" data-path\u003d\"${fieldId}\"\u003e+ 新規項目を追加\u003c/button\u003e`; // \n            }\n            fieldHTML \u003d `\u003cfieldset\u003e${arrayItemsHTML}${addButtonHTML}\u003c/fieldset\u003e`;\n        } else if (typeof value \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026 value !\u003d\u003d null) {\n            let objectItemsHTML \u003d \u0027\u0027;\n            let legendHTML \u003d \u0027\u0027;\n            if (idPrefix \u003d\u003d\u003d \u0027editor_field_image_\u0027 \u0026\u0026 key \u003d\u003d\u003d \u0027data\u0027) {\n                let chartName \u003d \"データ\";\n                if (parentObject.chartType) {\n                    switch (parentObject.chartType) {\n                        case \u0027bar\u0027: chartName \u003d \u0027棒グラフ\u0027; break;\n                        case \u0027line\u0027: chartName \u003d \u0027折れ線グラフ (単)\u0027; break;\n                        case \u0027multi-line\u0027: chartName \u003d \u0027折れ線グラフ (複)\u0027; break;\n                        case \u0027donut\u0027: chartName \u003d \u0027ドーナツグラフ\u0027; break;\n                        case \u0027stacked-bar\u0027: chartName \u003d \u0027積み上げ棒グラフ\u0027; break;\n                        case \u0027100-stacked-bar\u0027: chartName \u003d \u0027100%積み上げ棒グラフ\u0027; break;\n                        case \u0027combo\u0027: chartName \u003d \u0027複合グラフ\u0027; break;\n                        default: chartName \u003d parentObject.chartType;\n                    }\n                }\n                legendHTML \u003d `\u003clegend\u003e${chartName} の詳細\u003c/legend\u003e`;\n            }\n            Object.keys(value).forEach(subKey \u003d\u003e {\n                objectItemsHTML +\u003d createFormField(value, subKey, value[subKey], `${fieldId}_`);\n            });\n            if (idPrefix \u003d\u003d\u003d \u0027editor_field_\u0027 \u0026\u0026 key \u003d\u003d\u003d \u0027image\u0027) {\n                fieldHTML \u003d objectItemsHTML;\n            } else if (idPrefix \u003d\u003d\u003d \u0027editor_field_image_\u0027 \u0026\u0026 key \u003d\u003d\u003d \u0027data\u0027) {\n                fieldHTML \u003d `\u003cfieldset\u003e${legendHTML}${objectItemsHTML}\u003c/fieldset\u003e`;\n            } else {\n                fieldHTML \u003d `\u003cfieldset\u003e${legendHTML}${objectItemsHTML}\u003c/fieldset\u003e`;\n            }\n        } else {\n            // \n            if (key \u003d\u003d\u003d \u0027image\u0027 \u0026\u0026 typeof value \u003d\u003d\u003d \u0027string\u0027 \u0026\u0026 value.trim().toLowerCase().startsWith(\u0027\u003csvg\u0027)) {\n                // \n                fieldHTML \u003d `\u003cdiv style\u003d\"width: 100%;\"\u003e\n                   \u003ctextarea id\u003d\"${fieldId}\" class\u003d\"form-control\" rows\u003d\"6\" ${onInput} style\u003d\"display: none;\"\u003e${escapeHTML(value)}\u003c/textarea\u003e\n                   \u003cdiv class\u003d\"svg-preview-container\" \n                        onclick\u003d\"SvgVisualEditor.open(document.getElementById(\u0027${fieldId}\u0027).value, (newCode) \u003d\u003e { \n                            const ta \u003d document.getElementById(\u0027${fieldId}\u0027); \n                            ta.value \u003d newCode; \n                            ta.dispatchEvent(new Event(\u0027input\u0027, { bubbles: true })); \n                          })\"\n                        title\u003d\"クリックしてSVGをビジュアル編集\"\n                        style\u003d\"margin-top: 0.5rem; border: 1px solid var(--border-color); border-radius: var(--radius-sm); background-color: #fff; padding: 10px; text-align: center; overflow: auto; min-height: 50px; display: flex; align-items: center; justify-content: center; cursor: pointer; transition: all 0.2s;\"\u003e\n                       ${value}\n                   \u003c/div\u003e\n                 \u003c/div\u003e`;\n            }\n            // \n            else if (key \u003d\u003d\u003d \u0027image\u0027 \u0026\u0026 typeof value \u003d\u003d\u003d \u0027string\u0027 \u0026\u0026 value.trim().startsWith(\u0027data:image/\u0027)) {\n                 fieldHTML \u003d `\u003cdiv style\u003d\"width: 100%;\"\u003e\n                   \u003ctextarea id\u003d\"${fieldId}\" class\u003d\"form-control\" rows\u003d\"1\" ${onInput} style\u003d\"display: none;\"\u003e${escapeHTML(value)}\u003c/textarea\u003e\n                   \u003cdiv class\u003d\"image-preview-wrapper\" \n                        style\u003d\"margin-top: 0.5rem; border: 1px solid var(--border-color); border-radius: var(--radius-sm); background-color: #fff; padding: 10px; text-align: center;\"\u003e\n                       \u003cimg src\u003d\"${value}\" style\u003d\"max-width: 100%; max-height: 300px; object-fit: contain; box-shadow: 0 2px 4px rgba(0,0,0,0.1);\" alt\u003d\"Slide Image Preview\"\u003e\n                   \u003c/div\u003e\n                 \u003c/div\u003e`;\n            }\n            // \n            else if (key \u003d\u003d\u003d \u0027id\u0027 \u0026\u0026 idPrefix.includes(\u0027editor_field_image_data_\u0027)) {\n                fieldHTML \u003d `\u003cinput type\u003d\"text\" id\u003d\"${fieldId}\" class\u003d\"form-control\" value\u003d\"${escapeHTML(value)}\" readonly style\u003d\"background-color: var(--bg-body); color: var(--text-secondary); cursor: not-allowed;\"\u003e`;\n            } else if (key \u003d\u003d\u003d \u0027imagePosition\u0027) {\n                fieldHTML \u003d `\u003cselect id\u003d\"${fieldId}\" class\u003d\"form-control\"\u003e\n                               \u003coption value\u003d\"left\" ${value \u003d\u003d\u003d \u0027left\u0027 ? \u0027selected\u0027 : \u0027\u0027}\u003e左 (left)\u003c/option\u003e\n                               \u003coption value\u003d\"right\" ${value \u003d\u003d\u003d \u0027right\u0027 ? \u0027selected\u0027 : \u0027\u0027}\u003e右 (right)\u003c/option\u003e\n                             \u003c/select\u003e`;\n            } else if (typeof value \u003d\u003d\u003d \u0027boolean\u0027) {\n                // \n                fieldHTML \u003d `\u003cdiv class\u003d\"checkbox-wrapper\" style\u003d\"padding: 0.5rem 0;\"\u003e\n                               \u003cinput type\u003d\"checkbox\" id\u003d\"${fieldId}\" ${value ? \u0027checked\u0027 : \u0027\u0027} style\u003d\"width: 16px; height: 16px;\"\u003e\n                               \u003clabel for\u003d\"${fieldId}\" style\u003d\"margin-bottom: 0; font-size: 0.875rem;\"\u003e${labelText}を有効にする\u003c/label\u003e\n                             \u003c/div\u003e`;\n            } else if (isColorString(value)) {\n                fieldHTML \u003d `\u003cdiv style\u003d\"position: relative; display: flex; align-items: center; width: 100%;\"\u003e\n                               \u003cinput type\u003d\"color\" id\u003d\"${fieldId}_picker\" value\u003d\"${escapeHTML(value)}\" style\u003d\"width: 30px; height: 30px; padding: 0; border: 1px solid var(--border-color); border-radius: var(--radius-sm); margin-right: 0.5rem; cursor: pointer; flex-shrink: 0;\"\u003e\n                               \u003cinput type\u003d\"text\" id\u003d\"${fieldId}\" class\u003d\"form-control\" value\u003d\"${escapeHTML(value)}\" style\u003d\"flex-grow: 1;\"\u003e\n                             \u003c/div\u003e`;\n            } else if (isTextareaField(key, value, idPrefix)) {\n                fieldHTML \u003d `\u003ctextarea id\u003d\"${fieldId}\" class\u003d\"form-control\" rows\u003d\"1\" ${onInput} style\u003d\"font-family: var(--font-family-base); font-size: 0.875rem;\"\u003e${escapeHTML(value)}\u003c/textarea\u003e`;\n            } else {\n                fieldHTML \u003d `\u003cinput type\u003d\"text\" id\u003d\"${fieldId}\" class\u003d\"form-control\" value\u003d\"${escapeHTML(value)}\"\u003e`;\n            }\n        }\n        if (Array.isArray(value) || (typeof value \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026 value !\u003d\u003d null)) {\n            if (key \u003d\u003d\u003d \u0027image\u0027 || (idPrefix \u003d\u003d\u003d \u0027editor_field_image_\u0027 \u0026\u0026 key \u003d\u003d\u003d \u0027data\u0027)) {\n                return fieldHTML;\n            }\n            return `\u003cdiv class\u003d\"form-group-grid\" style\u003d\"align-items: stretch;\"\u003e\n                        \u003clabel class\u003d\"editor-form-label\" style\u003d\"margin-top: 0.5rem;\"\u003e${labelText}\u003c/label\u003e\n                        \u003cdiv class\u003d\"field-wrapper\"\u003e${fieldHTML}${helpTextHTML}\u003c/div\u003e\n                    \u003c/div\u003e`;\n        }\n        let labelMarginTop \u003d \u00270.5rem\u0027;\n        if (typeof value \u003d\u003d\u003d \u0027boolean\u0027) labelMarginTop \u003d \u00270.6rem\u0027;\n        else if (fieldHTML.startsWith(\u0027\u003ctextarea\u0027)) labelMarginTop \u003d \u00270.4rem\u0027;\n        else if (isColorString(value)) labelMarginTop \u003d \u00270.4rem\u0027;\n        let deleteButtonHTML \u003d \u0027\u0027;\n        if (isArrayPrimitive \u0026\u0026 !isGraphDataArray) {\n            const deletePath \u003d idPrefix + key;\n            deleteButtonHTML \u003d `\u003cbutton class\u003d\"btn-delete\" data-action\u003d\"delete\" data-path\u003d\"${deletePath}\" title\u003d\"項目を削除\"\u003e\u0026times;\u003c/button\u003e`; // \n        }\n        // \n        if (typeof value \u003d\u003d\u003d \u0027boolean\u0027) {\n             return `\u003cdiv class\u003d\"form-group-grid\"\u003e\n                        \u003clabel class\u003d\"editor-form-label\" style\u003d\"margin-top: ${labelMarginTop};\"\u003e\u003c/label\u003e \u003cdiv class\u003d\"field-wrapper\"\u003e${fieldHTML}${deleteButtonHTML}\u003c/div\u003e\n                    \u003c/div\u003e`;\n        }\n        return `\u003cdiv class\u003d\"form-group-grid\"\u003e\n                    \u003clabel for\u003d\"${fieldId}\" class\u003d\"editor-form-label\" style\u003d\"margin-top: ${labelMarginTop};\"\u003e${labelText}\u003c/label\u003e\n                    \u003cdiv class\u003d\"field-wrapper\"\u003e${fieldHTML}${deleteButtonHTML}\u003c/div\u003e\n                    ${helpTextHTML ? `\u003cdiv style\u003d\"padding-left: calc(var(--label-width, 120px) + 0.75rem);\"\u003e${helpTextHTML}\u003c/div\u003e` : \u0027\u0027}\n                \u003c/div\u003e`;\n    }\n    function updateDataFromField(field) {\n        try {\n            const fieldIdToUse \u003d field.id.replace(\u0027_picker\u0027, \u0027\u0027);\n            const path \u003d fieldIdToUse.replace(\u0027editor_field_\u0027, \u0027\u0027).split(\u0027_\u0027);\n            const { parent, lastKey } \u003d getObjectFromPath(path);\n            const originalValue \u003d parent[lastKey];\n            let newValue;\n            if (field.type \u003d\u003d\u003d \u0027checkbox\u0027) {\n                newValue \u003d field.checked;\n            } else if (field.type \u003d\u003d\u003d \u0027textarea\u0027) {\n                if (Array.isArray(originalValue) \u0026\u0026 (originalValue.length \u003d\u003d\u003d 0 || typeof originalValue[0] \u003d\u003d\u003d \u0027string\u0027 || typeof originalValue[0] \u003d\u003d\u003d \u0027number\u0027)) {\n                    const lines \u003d field.value.split(\u0027\\n\u0027).filter(line \u003d\u003e line.trim() !\u003d\u003d \u0027\u0027);\n                    if (typeof originalValue[0] \u003d\u003d\u003d \u0027number\u0027) {\n                        newValue \u003d lines.map(line \u003d\u003e parseFloat(line)).filter(num \u003d\u003e !isNaN(num));\n                    } else {\n                        newValue \u003d lines;\n                    }\n                } else if (Array.isArray(originalValue) || (typeof originalValue \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026 originalValue !\u003d\u003d null)) {\n                    try {\n                        newValue \u003d JSON.parse(field.value);\n                        field.style.borderColor \u003d \u0027var(--border-color)\u0027;\n                    } catch (e) {\n                        field.style.borderColor \u003d \u0027var(--danger-color)\u0027;\n                        return;\n                    }\n                } else {\n                    newValue \u003d field.value;\n                }\n            } else if (field.type \u003d\u003d\u003d \u0027select-one\u0027) {\n                newValue \u003d field.value;\n            } else { // \n                if (typeof originalValue \u003d\u003d\u003d \u0027number\u0027 \u0026\u0026 !isNaN(field.value)) {\n                    newValue \u003d parseFloat(field.value);\n                } else {\n                    newValue \u003d field.value;\n                }\n            }\n            parent[lastKey] \u003d newValue;\n        } catch (e) {\n            console.warn(\"Failed to update data from field:\", field.id, e);\n        }\n    }\n    function getObjectFromPath(path) {\n         let current \u003d slideData[currentIndex];\n        for (let i \u003d 0; i \u003c path.length - 1; i++) {\n            if (typeof current \u003d\u003d\u003d \u0027undefined\u0027 || current \u003d\u003d\u003d null) throw new Error(`Invalid path segment: ${path[i]} in path ${path.join(\u0027_\u0027)}`);\n            current \u003d current[path[i]];\n        }\n        if (typeof current \u003d\u003d\u003d \u0027undefined\u0027 || current \u003d\u003d\u003d null) throw new Error(`Invalid path parent for key: ${path[path.length - 1]} in path ${path.join(\u0027_\u0027)}`);\n        return { parent: current, lastKey: path[path.length - 1] };\n    }\n    function getNewItemShape(key, array) {\n         if (array.length \u003e 0) {\n            const firstItem \u003d array[0];\n            if (typeof firstItem \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026 firstItem !\u003d\u003d null) {\n                try {\n                    const template \u003d JSON.parse(JSON.stringify(firstItem));\n                    Object.keys(template).forEach(k \u003d\u003e {\n                        if (Array.isArray(template[k])) template[k] \u003d [];\n                        else if (typeof template[k] \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026 template[k] !\u003d\u003d null) template[k] \u003d {};\n                        else template[k] \u003d \u0027\u0027;\n                    });\n                    return template;\n                } catch(e) {}\n            } else if (typeof firstItem \u003d\u003d\u003d \u0027string\u0027 || typeof firstItem \u003d\u003d\u003d \u0027number\u0027) {\n                return (typeof firstItem \u003d\u003d\u003d \u0027number\u0027) ? 0 : \u0027\u0027;\n            }\n        }\n        switch(key) {\n            case \u0027items\u0027: case \u0027milestones\u0027: case \u0027lanes\u0027: case \u0027stats\u0027: case \u0027levels\u0027: case \u0027flows\u0027:\n                if (key \u003d\u003d\u003d \u0027lanes\u0027) return { title: \u0027New Lane\u0027, items: [] };\n                if (slideData[currentIndex].type \u003d\u003d\u003d \u0027statsCompare\u0027) return { label: \u0027\u0027, leftValue: \u0027\u0027, rightValue: \u0027\u0027 };\n                return { title: \u0027\u0027, desc: \u0027\u0027 };\n            case \u0027series\u0027: return { id: \u0027New\u0027, label: \u0027New Series\u0027, values: [] };\n            case \u0027barData\u0027: return { label: \u0027New\u0027, values: [] };\n            case \u0027colors\u0027: return { id: \u0027New\u0027, start: \u0027#FFFFFF\u0027, end: \u0027#000000\u0027 };\n            case \u0027headers\u0027: case \u0027rows\u0027: case \u0027points\u0027: case \u0027steps\u0027: case \u0027leftItems\u0027: case \u0027rightItems\u0027: case \u0027xAxisLabels\u0027:\n                return \u0027\u0027; // \n            case \u0027values\u0027: return 0; // \n            default:\n                if(array \u0026\u0026 array.length \u003e 0 \u0026\u0026 typeof array[0] \u003d\u003d\u003d \u0027string\u0027) return \u0027\u0027;\n                if(array \u0026\u0026 array.length \u003e 0 \u0026\u0026 typeof array[0] \u003d\u003d\u003d \u0027number\u0027) return 0;\n                return {};\n        }\n    }\n    // \n    // \n    function updatePreviewButtonForEditor(isEditing) {\n        const previewToggleButton \u003d $(\u0027showLastSlideBtn\u0027);\nconst updatePageBtn \u003d $(\u0027updatePageBtn\u0027);\n        const generateBtn \u003d $(\u0027generateBtn\u0027);\n        const showPreviewBtnLeftContainer \u003d $(\u0027showPreviewBtnLeftContainer\u0027);\nif (!updatePageBtn || !generateBtn || !previewToggleButton || !showPreviewBtnLeftContainer) return;\n        if (isEditing) {\n            // \n            if (isPreviewVisible) {\n                // \n                if (lastGeneratedSlideUrl) {\nupdatePageBtn.querySelector(\u0027.btn-text\u0027).textContent \u003d `${currentIndex + 1}ページ目を更新`;\n                  updatePageBtn.onclick \u003d updateCurrentPage; \n                  updatePageBtn.style.display \u003d \u0027inline-flex\u0027;\n                  updatePageBtn.style.backgroundColor \u003d \u0027\u0027; \n                  updatePageBtn.classList.remove(\u0027btn-secondary\u0027);\nupdatePageBtn.classList.add(\u0027btn-primary\u0027);\n                } else {\n                  updatePageBtn.style.display \u003d \u0027none\u0027;\n}\n                previewToggleButton.style.display \u003d \u0027none\u0027;\nshowPreviewBtnLeftContainer.style.display \u003d \u0027none\u0027;\n            } else {\n                // \n                updatePageBtn.style.display \u003d \u0027none\u0027;\n                // \n                if (lastGeneratedSlideUrl) {\n                    previewToggleButton.style.display \u003d \u0027inline-flex\u0027;\npreviewToggleButton.textContent \u003d \u0027プレビューを表示\u0027;\n                    previewToggleButton.onclick \u003d function() { \n                        if (lastGeneratedSlideUrl) {\nshowPreviewPane();\n                            updatePreviewButtonForEditor(true);\n                        } else {\nshowStatus(\u0027エラー: 表示するスライドがありません。\u0027, \u0027error\u0027);\n                        }\n                    };\npreviewToggleButton.classList.add(\u0027btn-primary\u0027);\n                    previewToggleButton.classList.remove(\u0027btn-secondary\u0027);\npreviewToggleButton.style.backgroundColor \u003d \u0027\u0027;\n                    showPreviewBtnLeftContainer.style.display \u003d \u0027block\u0027;\n} else {\n                    previewToggleButton.style.display \u003d \u0027none\u0027; // \nshowPreviewBtnLeftContainer.style.display \u003d \u0027none\u0027;\n                }\n                // \n            }\n            // \n            generateBtn.style.backgroundColor \u003d \u0027\u0027;\ngenerateBtn.classList.remove(\u0027btn-secondary\u0027);\n            generateBtn.classList.add(\u0027btn-primary\u0027);\n            generateBtn.onmouseover \u003d null;\n            generateBtn.onmouseout \u003d null;\n            generateBtn.style.display \u003d \u0027inline-flex\u0027;\n} else {\n            // \n            updatePageBtn.style.display \u003d \u0027none\u0027;\nshowPreviewBtnLeftContainer.style.display \u003d \u0027none\u0027;\n            generateBtn.style.display \u003d \u0027none\u0027;\n            // \n            if (lastGeneratedSlideUrl) {\n                previewToggleButton.style.display \u003d \u0027inline-flex\u0027;\npreviewToggleButton.textContent \u003d isPreviewVisible ? \u0027プレビューを閉じる\u0027 : \u0027スライドを表示\u0027;\n                previewToggleButton.onclick \u003d function() { if (isPreviewVisible) hidePreviewPane(); else showPreviewPane(); };\nif (!isPreviewVisible) {\n                    previewToggleButton.classList.add(\u0027btn-primary\u0027);\n                    previewToggleButton.classList.remove(\u0027btn-secondary\u0027);\npreviewToggleButton.style.backgroundColor \u003d \u0027\u0027;\n                } else {\n                    previewToggleButton.classList.remove(\u0027btn-primary\u0027);\npreviewToggleButton.classList.add(\u0027btn-secondary\u0027);\n                    previewToggleButton.style.backgroundColor \u003d \u0027var(--secondary-color)\u0027;\n                }\n            } else {\n                previewToggleButton.style.display \u003d \u0027none\u0027; // \n            }\n            // \n}\n    }\n    // \n    function autoResizeTextarea(element) {\n        if (!element || !element.style) return;\n        element.style.height \u003d \u0027auto\u0027;\n        element.style.height \u003d (element.scrollHeight) + \u0027px\u0027;\n    }\n    function initTextareaAutosize() {\n        if (!editorContainer) return;\n        const textareas \u003d editorContainer.querySelectorAll(\u0027#editorFormArea textarea\u0027);\n        textareas.forEach(autoResizeTextarea);\n    }\n    function optimizeLabelWidths() {\n        if (!editorContainer) return;\n        const containers \u003d editorContainer.querySelectorAll(\u0027#editorFormArea, #editorFormArea fieldset, #editorFormArea .array-item\u0027);\n        containers.forEach(container \u003d\u003e {\n            const labels \u003d container.querySelectorAll(\u0027:scope \u003e .form-group-grid \u003e .editor-form-label\u0027);\n            if (labels.length \u003d\u003d\u003d 0) return;\n            let maxWidth \u003d 0;\n            labels.forEach(label \u003d\u003e {\n                label.style.width \u003d \u0027auto\u0027;\n                const rect \u003d label.getBoundingClientRect();\n                maxWidth \u003d Math.max(maxWidth, rect.width);\n            });\n            const finalWidth \u003d Math.max(40, Math.min(maxWidth + 5, 160));\n            container.style.setProperty(\u0027--label-width\u0027, finalWidth + \u0027px\u0027); // \n            labels.forEach(label \u003d\u003e {\n                label.style.width \u003d finalWidth + \u0027px\u0027;\n            });\n        });\n        const helpTexts \u003d editorContainer.querySelectorAll(\u0027.form-group-grid \u003e div[style*\u003d\"padding-left\"]\u0027);\n        helpTexts.forEach(div \u003d\u003e {\n            const parentGrid \u003d div.closest(\u0027.form-group-grid\u0027);\n            if (parentGrid) {\n                const label \u003d parentGrid.querySelector(\u0027.editor-form-label\u0027);\n                if (label) {\n                    const labelWidth \u003d parseFloat(getComputedStyle(label).width || \u0027120\u0027); \n                    div.style.paddingLeft \u003d `calc(${labelWidth}px + 0.75rem)`;\n                }\n            }\n        });\n    }\n    function escapeHTML(str) {\n        if (str \u003d\u003d\u003d null || typeof str \u003d\u003d\u003d \u0027undefined\u0027) return \u0027\u0027;\n        if (typeof str \u003d\u003d\u003d \u0027number\u0027) str \u003d String(str);\n        if (typeof str !\u003d\u003d \u0027string\u0027) return str;\n        return str.replace(/\u0026/g, \u0027\u0026amp;\u0027).replace(/\u003c/g, \u0027\u0026lt;\u0027).replace(/\u003e/g, \u0027\u0026gt;\u0027).replace(/\"/g, \u0027\u0026quot;\u0027).replace(/\u0027/g, \u0027\u0026#039;\u0027);\n    }\n    function isColorString(str) {\n        if (typeof str !\u003d\u003d \u0027string\u0027) return false;\n        return /^#([0-9A-F]{3}){1,2}$/i.test(str);\n    }\n    function isTextareaField(key, value, idPrefix) {\n         const textareaKeys \u003d [\u0027notes\u0027, \u0027desc\u0027, \u0027text\u0027, \u0027a\u0027, \u0027q\u0027, \u0027imageCaption\u0027, \u0027author\u0027, \u0027subtitle\u0027, \u0027source\u0027, \u0027yAxisUnitLabel\u0027, \u0027centerLabel\u0027, \u0027legendBarLabel\u0027, \u0027legendLineLabel\u0027, \u0027yAxisLeftLabel\u0027, \u0027yAxisRightLabel\u0027, \u0027title\u0027, \u0027subhead\u0027, \u0027date\u0027, \u0027label\u0027];\n        if (idPrefix.endsWith(\u0027_\u0027) \u0026\u0026 (typeof value \u003d\u003d\u003d \u0027string\u0027 || typeof value \u003d\u003d\u003d \u0027number\u0027)) return true;\n        return textareaKeys.includes(key);\n    }\n    // \n    return {\n        init: init,\n        // \n        autoResizeTextarea: autoResizeTextarea,\n        getCurrentIndex: function() { return currentIndex; },\n        getSlideData: function() { return slideData; },\n        isEditorActive: function() { return isEditorActive; },\n        enterEditorMode: enterEditorMode, // \n        exitEditorMode: exitEditorMode,   // \n        reset: reset,                 // \n        updatePreviewButtonForEditor: updatePreviewButtonForEditor, // \n        setupForUpdate: setupForUpdate\n    };\n})();\n// \n    // \n    var suppressEditorAutoActivation \u003d false; // \n    function showJsonErrorModal(errorMessage) {\n      const modal \u003d $(\u0027jsonErrorModal\u0027);\n      const errorContent \u003d $(\u0027jsonErrorContent\u0027);\n      if (!modal || !errorContent) return;\n      // \n      const fullMessage \u003d `以下のJSONデータにエラーがあります。\\n修正した完全なJSONコードを出力してください。\\n\\n【エラー内容】\\n${errorMessage}`;\n      errorContent.textContent \u003d fullMessage;\n      modal.style.display \u003d \u0027flex\u0027;\n    }\n    function closeJsonErrorModal() {\n      const modal \u003d $(\u0027jsonErrorModal\u0027);\n      if (modal) modal.style.display \u003d \u0027none\u0027;\n      // \n      if (SlideEditor \u0026\u0026 SlideEditor.reset) {\n        SlideEditor.reset();\n      }\n    }\n    function copyJsonError() {\n      const errorContent \u003d $(\u0027jsonErrorContent\u0027);\n      if (!errorContent) return;\n      const text \u003d errorContent.textContent;\n      navigator.clipboard.writeText(text).then(() \u003d\u003e {\n        showStatus(\u0027エラー内容をコピーしました\u0027, \u0027success\u0027);\n      }).catch(err \u003d\u003e {\n        console.error(\u0027コピーに失敗しました:\u0027, err);\n        showStatus(\u0027コピーに失敗しました\u0027, \u0027error\u0027);\n      });\n    }\n    function showClearConfirmModal() {\n      const modal \u003d $(\u0027clearConfirmModal\u0027);\n      if (modal) modal.style.display \u003d \u0027flex\u0027;\n    }\n    function closeClearConfirmModal() {\n      const modal \u003d $(\u0027clearConfirmModal\u0027);\n      if (modal) modal.style.display \u003d \u0027none\u0027;\n    }\n    function showDeleteItemConfirmModal(onConfirmCallback) {\n      const modal \u003d $(\u0027deleteItemConfirmModal\u0027);\n      const confirmBtn \u003d $(\u0027confirmDeleteItemBtn\u0027);\n      if (!modal || !confirmBtn) return;\n      // \n      const newConfirmBtn \u003d confirmBtn.cloneNode(true);\n      confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);\n      // \n      newConfirmBtn.addEventListener(\u0027click\u0027, () \u003d\u003e {\n        closeDeleteItemConfirmModal(); // \n        if (onConfirmCallback) {\n          onConfirmCallback(); // \n        }\n      });\n      modal.style.display \u003d \u0027flex\u0027; // \n    }\n    function closeDeleteItemConfirmModal() {\n      const modal \u003d $(\u0027deleteItemConfirmModal\u0027);\n      if (modal) modal.style.display \u003d \u0027none\u0027;\n    }\n// \n    function performClear() {\n      // \n      if (SlideEditor \u0026\u0026 SlideEditor.reset) {\n        SlideEditor.reset();\n      } else {\n        // \n        const mainTextarea \u003d $(\u0027slideDataInput\u0027);\n        if (mainTextarea) {\n          mainTextarea.value \u003d \u0027\u0027;\n        }\n      }\n      // \n      closeClearConfirmModal();\n      // \n      const mainTextarea \u003d $(\u0027slideDataInput\u0027);\n      if (mainTextarea) mainTextarea.focus();\n      showStatus(\u0027編集内容をクリアしました\u0027, \u0027success\u0027);\n    }\n// \n    // \n    const VALID_SLIDE_TYPES \u003d [\n      \"title\", \"section\", \"content\", \"agenda\", \"compare\", \n      \"process\", \"processList\", \"timeline\", \"diagram\", \"cycle\", \n      \"cards\", \"headerCards\", \"table\", \"progress\", \"quote\", \n      \"kpi\", \"closing\", \"bulletCards\", \"faq\", \"statsCompare\", \n      \"barCompare\", \"triangle\", \"pyramid\", \"flowChart\", \"stepUp\", \n      \"imageText\", \"fullImage\"\n    ];\n    function validateJSON() {\n      const textarea \u003d $(\u0027slideDataInput\u0027);\n      if (!textarea) return;\n      const jsonText \u003d textarea.value.trim();\n      const validationDiv \u003d $(\u0027jsonValidation\u0027);\n      if (validationDiv) validationDiv.style.display \u003d \u0027none\u0027;\n      if (!jsonText) {\n        if (SlideEditor \u0026\u0026 !SlideEditor.isEditorActive()) {\n          SlideEditor.updatePreviewButtonForEditor(false);\n        }\n        return;\n      }\n      let parsedData \u003d null;\n      let parseError \u003d null;\n      // \n      try {\n        parsedData \u003d JSON.parse(jsonText);\n      } catch (firstError) {\n        parseError \u003d firstError;\n        let cleanedText \u003d jsonText.replace(/\\[cite_start\\]/g, \u0027\u0027);\n        cleanedText \u003d cleanedText.replace(/\\]+\\]/g, \u0027\u0027);\n        if (cleanedText !\u003d\u003d jsonText) {\n            try {\n                parsedData \u003d JSON.parse(cleanedText);\n                parseError \u003d null;\n                textarea.value \u003d cleanedText;\n                showStatus(\u0027テキストの自動クリーニングを実行しました。\u0027, \u0027success\u0027);\n            } catch (secondError) {\n                parseError \u003d firstError;\n            }\n        }\n      }\n      // \n      if (parseError) {\n        showJsonErrorModal(\u0027JSONパースエラー: \u0027 + parseError.message);\n        return;\n      }\n      // \n      try {\n        if (!Array.isArray(parsedData)) throw new Error(\u0027slideDataは配列である必要があります\u0027);\n        // \n        const invalidTypes \u003d [];\n        parsedData.forEach((slide, index) \u003d\u003e {\n          if (slide \u0026\u0026 slide.type \u0026\u0026 !VALID_SLIDE_TYPES.includes(slide.type)) {\n            invalidTypes.push(`- スライド${index + 1}: \"${slide.type}\"`);\n          }\n        });\n        if (invalidTypes.length \u003e 0) {\n          // \n          const errorMessage \u003d `定義に無いスライドタイプが選択されています。以下の修正を行ってください。\n【エラー内容】\n以下のスライドタイプはシステムに存在しません：\n${invalidTypes.join(\u0027\\n\u0027)}\n【有効なスライドタイプ一覧】\n${VALID_SLIDE_TYPES.join(\u0027, \u0027)}\n上記のエラーを修正し、正しい \"type\" を指定したJSONを出力してください。`;\n          showJsonErrorModal(errorMessage);\n          return; // \n        }\n        // \n        // \n        let sectionCount \u003d 0;\n        let dataModified \u003d false;\n        parsedData.forEach(slide \u003d\u003e {\n          if (slide \u0026\u0026 slide.type \u003d\u003d\u003d \u0027section\u0027) {\n            sectionCount++;\n            if (slide.sectionNo \u003d\u003d\u003d undefined || slide.sectionNo \u003d\u003d\u003d null || slide.sectionNo \u003d\u003d\u003d \"\") {\n              slide.sectionNo \u003d sectionCount;\n              dataModified \u003d true;\n            }\n          }\n        });\n        if (dataModified) {\n          textarea.value \u003d JSON.stringify(parsedData, null, 2);\n        }\n        // \n        let warnings \u003d [];\n        parsedData.forEach((slide, index) \u003d\u003e {\n          if (!slide.type) warnings.push(`スライド${index + 1}: typeプロパティが必要です`);\n          if (slide.type \u003d\u003d\u003d \u0027title\u0027 \u0026\u0026 !slide.title) warnings.push(`スライド${index + 1}: titleスライドにはtitleが必要です`);\n        });\n        if (warnings.length \u003e 0) {\n           showJsonErrorModal(\u0027警告: 以下の項目を確認してください\\n\\n\u0027 + warnings.join(\u0027\\n\u0027));\n           return;\n        }\n        // \n        const autoActivationAllowed \u003d !suppressEditorAutoActivation;\n        const isTextareaVisible \u003d textarea.offsetParent !\u003d\u003d null;\n        if (autoActivationAllowed \u0026\u0026 isTextareaVisible) {\n          if (SlideEditor.isEditorActive()) {\n            SlideEditor.exitEditorMode({ skipValidation: true });\n          }\n          SlideEditor.enterEditorMode();\n        }\n      } catch (validationError) {\n         showJsonErrorModal(\u0027JSON検証エラー: \u0027 + validationError.message);\n      }\n    }\n    function updateGradientPreview() {\n      const startColor \u003d $(\u0027gradientStartText\u0027).value, endColor \u003d $(\u0027gradientEndText\u0027).value, preview \u003d $(\u0027gradientPreview\u0027);\n      if (preview) { preview.style.background \u003d `linear-gradient(135deg, ${startColor}, ${endColor})`; }\n    }\n    function openFolder() {\n      const folderUrl \u003d $(\u0027driveFolderUrl\u0027).value.trim();\n      if (!folderUrl) { showStatus(\u0027保存先フォルダURLを入力してください\u0027, \u0027error\u0027); return; }\n      if (!folderUrl.includes(\u0027drive.google.com\u0027) \u0026\u0026 !folderUrl.includes(\u0027docs.google.com\u0027)) {\n        showStatus(\u0027正しいGoogleドライブフォルダURLを入力してください\u0027, \u0027error\u0027); return;\n      }\n      window.open(folderUrl, \u0027_blank\u0027);\n    }\n    window.addEventListener(\u0027load\u0027, function() {\n        adjustTextAreaHeight();\n    });\n    document.addEventListener(\u0027DOMContentLoaded\u0027, function() {\n    // \n    const ActivationFlow \u003d (function() {\n      let modals \u003d [];\n      let currentStep \u003d -1;\n      let userEmail \u003d null;\n      let onCompleteCallback \u003d null;\n      function init(email, onComplete) {\n        modals \u003d [\n          $(\u0027activationModal1\u0027),\n          $(\u0027activationModal2\u0027),\n          $(\u0027activationModal3\u0027),\n          $(\u0027activationModal4\u0027),\n          $(\u0027termsModal\u0027) // \n        ];\n        userEmail \u003d email;\n        onCompleteCallback \u003d onComplete;\n      }\n      function showModal(stepIndex) {\n        if (stepIndex \u003c 0 || stepIndex \u003e\u003d modals.length) return;\n        // \n        if (currentStep \u003e\u003d 0 \u0026\u0026 modals[currentStep]) {\n          modals[currentStep].style.display \u003d \u0027none\u0027;\n        }\n        currentStep \u003d stepIndex;\n        const modal \u003d modals[currentStep];\n        // \n        if (currentStep \u003d\u003d\u003d 4) { \n          $(\u0027termsModalHeader\u0027).textContent \u003d \u0027ステップ 5 / 5 - 利用条件の確認\u0027;\n          $(\u0027termsModalStandardButtons\u0027).style.display \u003d \u0027none\u0027;\n          $(\u0027termsModalActivationButtons\u0027).style.display \u003d \u0027block\u0027;\n        }\n        // \n        modal.style.display \u003d \u0027flex\u0027;\n        // \n        const confirmBtn \u003d $(`confirmModal${currentStep + 1}`);\n        const purchaseSelect \u003d $(`purchaseModal${currentStep + 1}`); // \n        const confirmHandler \u003d () \u003d\u003e {\n          // \n          confirmBtn.removeEventListener(\u0027click\u0027, confirmHandler);\n          purchaseSelect.removeEventListener(\u0027change\u0027, purchaseHandler); // \n          // \n          handleNext();\n        };\n        const purchaseHandler \u003d (e) \u003d\u003e { // \n          if (e.target.value \u003d\u003d\u003d \u0027purchased\u0027) {\n            // \n            confirmBtn.removeEventListener(\u0027click\u0027, confirmHandler);\n            purchaseSelect.removeEventListener(\u0027change\u0027, purchaseHandler);\n            // \n            handleNext();\n          }\n        };\n        confirmBtn.addEventListener(\u0027click\u0027, confirmHandler);\n        purchaseSelect.addEventListener(\u0027change\u0027, purchaseHandler); // \n      }\n      function handleNext() {\n        const nextStep \u003d currentStep + 1;\n        if (nextStep \u003c modals.length) {\n          // \n          showModal(nextStep);\n        } else {\n          // \n          if (modals[currentStep]) {\n            // \n            if (currentStep \u003d\u003d\u003d 4) {\n              $(\u0027termsModalHeader\u0027).textContent \u003d \u0027利用条件 (Terms of Service)\u0027;\n              $(\u0027termsModalStandardButtons\u0027).style.display \u003d \u0027block\u0027;\n              $(\u0027termsModalActivationButtons\u0027).style.display \u003d \u0027none\u0027;\n            }\n            modals[currentStep].style.display \u003d \u0027none\u0027;\n          }\n          // \n          // \n          if (userEmail) {\n            google.script.run\n              .withSuccessHandler(response \u003d\u003e {\n              })\n              .withFailureHandler(error \u003d\u003e {\n                console.error(\u0027サーバーでのアクティベート失敗:\u0027, error.message);\n                // \n              })\n              .activateUser(userEmail);\n          }\n          // \n          const membershipModal \u003d $(\u0027membershipModal\u0027);\n          const closeMembershipBtn \u003d $(\u0027closeMembershipModalBtn\u0027);\n          if (membershipModal \u0026\u0026 closeMembershipBtn) {\n              // \n              membershipModal.style.display \u003d \u0027flex\u0027;\n              // \n              closeMembershipBtn.onclick \u003d () \u003d\u003e {\n                  membershipModal.style.display \u003d \u0027none\u0027;\n                  showStatus(\u0027ありがとうございます。ご利用を開始できます。\u0027, \u0027success\u0027);\n                  // \n                  if (typeof onCompleteCallback \u003d\u003d\u003d \u0027function\u0027) {\n                      onCompleteCallback(); // \n                  }\n              };\n          } else {\n              // \n              console.warn(\u0027メンバーシップモーダルが見つからないため、アプリを即時起動します。\u0027);\n              showStatus(\u0027ありがとうございます。ご利用を開始できます。\u0027, \u0027success\u0027);\n              if (typeof onCompleteCallback \u003d\u003d\u003d \u0027function\u0027) {\n                  onCompleteCallback();\n              }\n          }\n          // \n        }\n      }\n      function start() {\n        if (!userEmail) {\n          if (typeof onCompleteCallback \u003d\u003d\u003d \u0027function\u0027) {\n            onCompleteCallback(); // \n          }\n          return;\n        }\n        showModal(0); // \n      }\n      return {\n        init: init,\n        start: start\n      };\n    })();\n    // \n    function initializeAppLogic() {\n      // \n      const geminiButton \u003d $(\u0027geminiGemButton\u0027);\n      if (!loadedSettings.geminiGemUrl) {\n        const modal \u003d $(\u0027gemUrlModal\u0027);\n        const saveBtn \u003d $(\u0027saveGemUrlBtn\u0027);\n        const input \u003d $(\u0027gemUrlInput\u0027);\n        const errorEl \u003d $(\u0027gemUrlError\u0027);\n        // \n        const helpArea \u003d $(\u0027gemHelpArea\u0027);\n        const promptTextarea \u003d $(\u0027gemPromptTextarea\u0027);\n        const copyBtn \u003d $(\u0027copyGemPromptBtn\u0027);\n        // \n        modal.style.display \u003d \u0027flex\u0027;\n        function validateGemUrlInput() {\n          const url \u003d input.value.trim();\n          const baseUrl \u003d \u0027https://gemini.google.com/gem/\u0027;\n          if (!url) {\n            errorEl.textContent \u003d \u0027URLを入力してください。\u0027;\n            errorEl.style.color \u003d \u0027var(--danger-color)\u0027;\n            errorEl.style.display \u003d \u0027none\u0027;\n            saveBtn.disabled \u003d true;\n            return \u0027error\u0027;\n          } else if (!url.startsWith(baseUrl)) {\n            errorEl.textContent \u003d \u0027URLの形式が不正です (https://gemini.google.com/gem/... を推奨)。このまま続行しますか？\u0027;\n            errorEl.style.color \u003d \u0027var(--danger-color)\u0027;\n            errorEl.style.display \u003d \u0027block\u0027;\n            saveBtn.disabled \u003d false;\n            return \u0027warning\u0027;\n          } else if (url.length \u003d\u003d\u003d baseUrl.length) {\n            errorEl.textContent \u003d \u0027特定のGemが指定されていません（GeminiホームのURLです）。このまま続行しますか？\u0027;\n            errorEl.style.color \u003d \u0027var(--danger-color)\u0027;\n            errorEl.style.display \u003d \u0027block\u0027;\n            saveBtn.disabled \u003d false;\n            return \u0027warning\u0027;\n          } else {\n            errorEl.style.display \u003d \u0027none\u0027;\n            saveBtn.disabled \u003d false;\n            return \u0027success\u0027;\n          }\n        }\n        input.addEventListener(\u0027input\u0027, validateGemUrlInput);\n        validateGemUrlInput();\n        // \n        try {\n           const promptDataElement \u003d $(\u0027gem-prompt-data\u0027);\n          if (promptDataElement) {\n            const promptText \u003d promptDataElement.textContent.trim();\n            promptTextarea.value \u003d promptText || \u0027プロンプトが空です。\u0027;\n          } else {\n            promptTextarea.value \u003d \u0027エラー: HTML内に id\u003d\"gem-prompt-data\" が見つかりません。\u0027;\n          }\n        } catch (e) {\n          promptTextarea.value \u003d \u0027エラー: \u0027 + e.message;\n        }\n        copyBtn.addEventListener(\u0027click\u0027, function() {\n          if (!promptTextarea.value || promptTextarea.value \u003d\u003d\u003d \u0027読み込み中...\u0027) return;\n          navigator.clipboard.writeText(promptTextarea.value)\n            .then(() \u003d\u003e {\n              showStatus(\u0027プロンプトをコピーしました\u0027, \u0027success\u0027);\n            })\n            .catch(err \u003d\u003e {\n              try {\n                promptTextarea.select();\n                document.execCommand(\u0027copy\u0027);\n                showStatus(\u0027プロンプトをコピーしました\u0027, \u0027success\u0027);\n              } catch (e) {\n                alert(\u0027コピーに失敗しました。\u0027);\n              }\n            });\n        });\n        saveBtn.addEventListener(\u0027click\u0027, function() {\n          const url \u003d input.value.trim();\n          errorEl.style.display \u003d \u0027none\u0027;\n          saveBtn.disabled \u003d true;\n          saveBtn.textContent \u003d \u0027保存中...\u0027;\n          google.script.run\n            .withSuccessHandler(function(response) {\n              if (response.status \u003d\u003d\u003d \u0027success\u0027 || response.status \u003d\u003d\u003d \u0027warning\u0027) {\n                const url \u003d input.value.trim();\n                if (geminiButton) {\n                  geminiButton.href \u003d url;\n                }\n                loadedSettings.geminiGemUrl \u003d url;\n                $(\u0027gemUrlModal\u0027).style.display \u003d \u0027none\u0027;\n                if (response.status \u003d\u003d\u003d \u0027warning\u0027) {\n                   showStatus(\u0027Gem URLが保存されました（警告あり）。\u0027, \u0027info\u0027, 4000);\n                } else {\n                   showStatus(\u0027Gem URLを保存しました。\u0027, \u0027success\u0027);\n                }\n                if(typeof resumeTimer \u003d\u003d\u003d \u0027function\u0027) resumeTimer();\n              } else {\n                errorEl.textContent \u003d response.message;\n                errorEl.style.color \u003d \u0027var(--danger-color)\u0027;\n                errorEl.style.display \u003d \u0027block\u0027;\n                saveBtn.disabled \u003d false;\n                saveBtn.textContent \u003d \u0027保存して開始\u0027;\n                if(typeof resumeTimer \u003d\u003d\u003d \u0027function\u0027) resumeTimer();\n              }\n            })\n            .withFailureHandler(function(error) {\n              errorEl.textContent \u003d \u0027サーバーエラー: \u0027 + error.message;\n              errorEl.style.display \u003d \u0027block\u0027;\n              saveBtn.disabled \u003d false;\n              saveBtn.textContent \u003d \u0027保存して開始\u0027;\n              if(typeof resumeTimer \u003d\u003d\u003d \u0027function\u0027) resumeTimer();\n            })\n            .saveGemUrl(url);\n        });\n      } else {\n        if (geminiButton) {\n            geminiButton.href \u003d loadedSettings.geminiGemUrl;\n        }\n      }\n      SlideEditor.init();\n      function showPreviewInfoModal(isFirstTime \u003d false) {\n        const modal \u003d $(\u0027previewInfoModal\u0027);\n        const firstTimeMsg \u003d $(\u0027previewInfoModal_FirstTimeMessage\u0027);\n        const closeBtn \u003d $(\u0027closePreviewInfoModalBtn\u0027);\n        if (!modal || !firstTimeMsg || !closeBtn) return;\n        if (isFirstTime) {\n          firstTimeMsg.innerHTML \u003d \u0027\u003cp style\u003d\"font-weight: 600;\"\u003e設定が保存されました。\u003c/p\u003e\u003cp\u003eご利用を開始できます。プレビュー版の注意事項をご確認の上、ご利用ください。\u003c/p\u003e\u0027;\n          firstTimeMsg.style.display \u003d \u0027block\u0027;\n          closeBtn.textContent \u003d \u0027閉じる\u0027;\n          closeBtn.disabled \u003d false; \n          closeBtn.style.opacity \u003d \u00271\u0027;\n          closeBtn.style.cursor \u003d \u0027pointer\u0027;\n        } else {\n          firstTimeMsg.style.display \u003d \u0027none\u0027;\n          closeBtn.textContent \u003d \u0027閉じる\u0027;\n          closeBtn.disabled \u003d false; \n          closeBtn.style.opacity \u003d \u00271\u0027;\n          closeBtn.style.cursor \u003d \u0027pointer\u0027;\n        }\n        modal.style.display \u003d \u0027flex\u0027;\n      }\n      function hidePreviewInfoModal(isFirstTime \u003d false) {\n        const modal \u003d $(\u0027previewInfoModal\u0027);\n        if (modal) {\n          modal.style.display \u003d \u0027none\u0027;\n        }\n        if (isFirstTime) {\n          localStorage.setItem(\u0027hasShownPreviewModal_v1\u0027, \u0027true\u0027);\n          const previewHeader \u003d $(\u0027previewHeader\u0027);\n          if (previewHeader) {\n             previewHeader.style.display \u003d \u0027block\u0027;\n          }\n        }\n      }\n      const previewHeader \u003d $(\u0027previewHeader\u0027);\n      const closePreviewHeaderBtn \u003d $(\u0027closePreviewHeaderBtn\u0027);\n      const previewInfoModal \u003d $(\u0027previewInfoModal\u0027);\n      const closePreviewInfoModalBtn \u003d $(\u0027closePreviewInfoModalBtn\u0027);\n      if (previewHeader \u0026\u0026 closePreviewHeaderBtn \u0026\u0026 previewInfoModal \u0026\u0026 closePreviewInfoModalBtn) {\n      if (ENABLE_CREDIT_IMAGE \u003d\u003d\u003d true) {\n        if (hasShownFirstTimePreviewModal) {\n          previewHeader.style.display \u003d \u0027block\u0027;\n        } else {\n          if (!loadedSettings.geminiGemUrl) {\n             previewHeader.style.display \u003d \u0027none\u0027;\n          } else {\n             previewHeader.style.display \u003d \u0027block\u0027;\n          }\n        }\n      } else { // \n            previewHeader.style.display \u003d \u0027none\u0027; // \n      }\n        previewHeader.addEventListener(\u0027click\u0027, (e) \u003d\u003e {\n          if (e.target \u003d\u003d\u003d closePreviewHeaderBtn) return;\n          try {\n            // \n            const modal \u003d $(\u0027termsModal\u0027);\n            const iframe \u003d $(\u0027termsFrame\u0027);\n            const targetUrl \u003d \u0027https://docs.google.com/document/d/e/2PACX-1vSjM9eBeZvqaRzGIlyjPiB_CuhSBSjsJY7eahzMxoch-WQGLwrOcUAaDv1cxOll720J8bib1XoGlG8J/pub?embedded\u003dtrue\u0027;\n            if (modal \u0026\u0026 iframe) {\n              if (iframe.src !\u003d\u003d targetUrl) {\n                iframe.src \u003d targetUrl;\n              }\n              modal.style.display \u003d \u0027flex\u0027;\n            } else {\n              console.error(\u0027利用規約モーダルの要素が見つかりません。\u0027);\n            }\n          } catch (err) {\n            console.error(\u0027利用規約モーダルの表示に失敗:\u0027, err);\n            // \n          }\n        });\n        closePreviewHeaderBtn.addEventListener(\u0027click\u0027, (e) \u003d\u003e {\n          e.stopPropagation();\n          previewHeader.style.display \u003d \u0027none\u0027;\n        });\n        closePreviewInfoModalBtn.addEventListener(\u0027click\u0027, () \u003d\u003e {\n          const isFirstTime \u003d ($(\u0027previewInfoModal_FirstTimeMessage\u0027).style.display \u003d\u003d\u003d \u0027block\u0027);\n          hidePreviewInfoModal(isFirstTime);\n        });\n        previewInfoModal.addEventListener(\u0027click\u0027, (e) \u003d\u003e {\n          if (e.target \u003d\u003d\u003d previewInfoModal) {\n            const isFirstTime \u003d ($(\u0027previewInfoModal_FirstTimeMessage\u0027).style.display \u003d\u003d\u003d \u0027block\u0027);\n            hidePreviewInfoModal(isFirstTime);\n          }\n        });\n      }\n      // \n      updatePresetSelect(); \n      // \n      const lastSelectedPreset \u003d localStorage.getItem(\u0027slideFactory_lastSelectedPreset\u0027);\n      if (lastSelectedPreset) {\n        // \n        const select \u003d $(\u0027presetSelect\u0027);\n        // \n        if (Array.from(select.options).some(opt \u003d\u003e opt.value \u003d\u003d\u003d lastSelectedPreset)) {\n          // \n          select.value \u003d lastSelectedPreset; // \n          loadSelectedPreset(); // \n        } else {\n          // \n          select.value \u003d \u0027_default\u0027; // \n          loadSettingsToForm(); // \n        }\n      } else {\n        // \n        // \n        loadSettingsToForm();\n      }\n      $(\u0027generateBtn\u0027).addEventListener(\u0027click\u0027, generate);\n      $(\u0027primaryColor\u0027).addEventListener(\u0027input\u0027, function() { updatePrimaryColor(this.value); });\n      $(\u0027primaryColorText\u0027).addEventListener(\u0027input\u0027, function() { updatePrimaryColor(this.value); });\n      $(\u0027gradientStart\u0027).addEventListener(\u0027input\u0027, function() { $(\u0027gradientStartText\u0027).value \u003d this.value; updateGradientPreview(); });\n      $(\u0027gradientStartText\u0027).addEventListener(\u0027input\u0027, function() { $(\u0027gradientStart\u0027).value \u003d this.value; updateGradientPreview(); });\n      $(\u0027gradientEnd\u0027).addEventListener(\u0027input\u0027, function() { $(\u0027gradientEndText\u0027).value \u003d this.value; updateGradientPreview(); });\n      $(\u0027gradientEndText\u0027).addEventListener(\u0027input\u0027, function() { $(\u0027gradientEnd\u0027).value \u003d this.value; updateGradientPreview(); });\n      $(\u0027enableGradient\u0027).addEventListener(\u0027change\u0027, toggleGradientOptions);\n      const slideDataInput \u003d $(\u0027slideDataInput\u0027);\n      slideDataInput.addEventListener(\u0027input\u0027, validateJSON);\n      // \n      slideDataInput.addEventListener(\u0027dblclick\u0027, async function() {\n        try {\n          // \n          const text \u003d await navigator.clipboard.readText();\n          if (text) {\n            this.value \u003d text;\n            // \n            validateJSON();\n            if (typeof SlideEditor !\u003d\u003d \u0027undefined\u0027 \u0026\u0026 SlideEditor.autoResizeTextarea) {\n               SlideEditor.autoResizeTextarea(this);\n            }\n            showStatus(\u0027クリップボードの内容を貼り付けました\u0027, \u0027success\u0027);\n          }\n        } catch (e) {\n          console.warn(\u0027Clipboard paste failed:\u0027, e);\n          // \n        }\n      });\n      $(\u0027largeFontColor\u0027).addEventListener(\u0027input\u0027, function() { updateLargeFontColor(this.value); });\n      $(\u0027largeFontColorText\u0027).addEventListener(\u0027input\u0027, function() { updateLargeFontColor(this.value); });\n      $(\u0027smallFontColor\u0027).addEventListener(\u0027input\u0027, function() { updateSmallFontColor(this.value); });\n      $(\u0027smallFontColorText\u0027).addEventListener(\u0027input\u0027, function() { updateSmallFontColor(this.value); });\n      $(\u0027backgroundColor\u0027).addEventListener(\u0027input\u0027, function() { updateBackgroundColor(this.value); });\n      $(\u0027backgroundColorText\u0027).addEventListener(\u0027input\u0027, function() { updateBackgroundColor(this.value); });\n      $(\u0027presetSelect\u0027).addEventListener(\u0027change\u0027, function() {\n        $(\u0027deletePreset\u0027).disabled \u003d this.value \u003d\u003d\u003d \u0027_default\u0027 || this.value \u003d\u003d\u003d \u0027\u0027;\n        if (this.value) {\n          loadSelectedPreset();\n          try {\n            localStorage.setItem(\u0027slideFactory_lastSelectedPreset\u0027, this.value);\n          } catch (e) {\n            console.warn(\u0027ローカルストレージへのプリセット名保存に失敗:\u0027, e.message);\n          }\n        }\n      });\n      // \n        async function addOrUpdateSummarySlide(base64Image) {\n            // \n            if (!SlideEditor.isEditorActive()) {\n                SlideEditor.enterEditorMode();\n            }\n            const slideData \u003d SlideEditor.getSlideData();\n            const currentIndex \u003d SlideEditor.getCurrentIndex();\n            const currentSlide \u003d slideData[currentIndex];\n            let targetIndex \u003d currentIndex;\n            let isUpdateMode \u003d false; // \n            let newSlideData \u003d null;\n            // \n            if (currentSlide \u0026\u0026 currentSlide.isSummary) {\n                // \n                currentSlide.image \u003d base64Image;\n                isUpdateMode \u003d true;\n                targetIndex \u003d currentIndex;\n                newSlideData \u003d currentSlide;\n                //showStatus(\u0027ローカルデータを更新しました。Googleスライドへ反映中...\u0027, \u0027info\u0027);\n            } else {\n                // \n                const newSlide \u003d {\n                    \"type\": \"fullImage\",\n                    \"notes\": \"ここまで説明した内容をまとめて振り返ります。\",\n                    \"image\": base64Image,\n                    \"isSummary\": true\n                };\n                const lastIdx \u003d slideData.length - 1;\n                const lastSlide \u003d slideData[lastIdx];\n                if (lastSlide \u0026\u0026 lastSlide.type \u003d\u003d\u003d \u0027closing\u0027) {\n                    // \n                    slideData.splice(lastIdx, 0, newSlide);\n                    targetIndex \u003d lastIdx;\n                } else {\n                    // \n                    slideData.push(newSlide);\n                    targetIndex \u003d slideData.length - 1;\n                }\n                isUpdateMode \u003d false;\n                newSlideData \u003d newSlide;\n                //showStatus(\u0027ローカルに追加しました。Googleスライドへ追加中...\u0027, \u0027info\u0027);\n            }\n            // \n            SlideEditor.exitEditorMode({ skipValidation: true });\n            SlideEditor.enterEditorMode();\n            // \n            if (targetIndex \u003e 0) {\n                for(let i\u003d0; i \u003c targetIndex; i++) {\n                    const nextBtn \u003d document.getElementById(\u0027editorNextBtn\u0027);\n                    if(nextBtn \u0026\u0026 !nextBtn.disabled) {\n                        nextBtn.click();\n                    }\n                }\n            }\n            // \n            if (lastGeneratedSlideUrl) {\n                const match \u003d lastGeneratedSlideUrl.match(/\\/d\\/([a-zA-Z0-9_-]+)|\\?id\u003d([a-zA-Z0-9_-]+)/);\n                const presentationId \u003d match ? (match[1] || match[2]) : null;\n                if (presentationId) {\n                    const settings \u003d getCurrentSettings();\n                    const slideJsonString \u003d JSON.stringify(newSlideData);\n                    // \n                    const updateBtn \u003d $(\u0027updatePageBtn\u0027);\n                    if (updateBtn) {\n                        updateBtn.disabled \u003d true;   // \n                        startButtonTimer(updateBtn); // \n                    }\n                    // \n                    try {\n                        if (isUpdateMode) {\n                            // \n                            await new Promise((resolve, reject) \u003d\u003e {\n                                google.script.run\n                                    .withSuccessHandler(resolve)\n                                    .withFailureHandler(reject)\n                                    .updateSingleSlide(presentationId, targetIndex, slideJsonString, settings, \u0027update\u0027);\n                            });\n                            //showStatus(\u0027Googleスライドの画像更新が完了しました！\u0027, \u0027success\u0027);\n                        } else {\n                            // \n                            await new Promise((resolve, reject) \u003d\u003e {\n                                google.script.run\n                                    .withSuccessHandler(resolve)\n                                    .withFailureHandler(reject)\n                                    .insertSlideAt(presentationId, targetIndex, slideJsonString, settings);\n                            });\n                            //showStatus(\u0027Googleスライドへのページ追加が完了しました！\u0027, \u0027success\u0027);\n                        }\n                    } catch (e) {\n                        console.error(\"Googleスライド同期エラー:\", e);\n                        showStatus(`Googleスライドへの反映に失敗しました: ${e.message}`, \u0027error\u0027);\n                    } finally {\n                        // \n                        if (updateBtn) {\n                            const currentIdx \u003d SlideEditor.getCurrentIndex();\n                            const finalText \u003d `${currentIdx + 1}ページ目を更新`;\n                            stopButtonTimer(updateBtn, finalText);\n                            updateBtn.disabled \u003d false;\n                        }\n                        // \n                    }\n                }\n            } else {\n                //showStatus(\u0027Googleスライドがまだ生成されていないため、ローカルのみ更新しました。\u0027, \u0027success\u0027);\n            }\n        }\n        // \n        function handleSummaryImageFile(file) {\n            if (!file || !file.type.startsWith(\u0027image/\u0027)) {\n                showStatus(\u0027画像ファイルを選択してください。\u0027, \u0027error\u0027);\n                return;\n            }\n            // \n            const modal \u003d $(\u0027summaryPromptModal\u0027);\n            if (modal) modal.style.display \u003d \u0027none\u0027;\n            // \n            const fileInput \u003d $(\u0027summaryImageUpload\u0027);\n            if (fileInput) fileInput.value \u003d \u0027\u0027;\n            // \n            showStatus(\u0027画像を変換して取り込んでいます... (バックグラウンド処理中)\u0027, \u0027info\u0027, 3000);\n            // \n            const reader \u003d new FileReader();\n            reader.onload \u003d async (e) \u003d\u003e {\n                const base64 \u003d e.target.result;\n                // \n                await addOrUpdateSummarySlide(base64);\n            };\n            reader.onerror \u003d () \u003d\u003e {\n                showStatus(\u0027画像の読み込みに失敗しました。\u0027, \u0027error\u0027);\n            };\n            reader.readAsDataURL(file);\n        }\n        // \n        document.body.addEventListener(\u0027click\u0027, function(event) {\n            const btn \u003d event.target.closest(\u0027#editorAddSummaryBtn\u0027);\n            if (!btn) return;\n            event.preventDefault();\n            const summaryModal \u003d $(\u0027summaryPromptModal\u0027);\n            const summaryTextarea \u003d $(\u0027summaryPromptTextarea\u0027);\n            // \n            const primaryColor \u003d $(\u0027primaryColorText\u0027).value || \u0027#4285F4\u0027;\n            const footerText \u003d $(\u0027footerText\u0027).value || \u0027\u0027;\n            const headerLogoUrl \u003d $(\u0027headerLogoUrl\u0027).value || \u0027\u0027;\n            const backgroundColor \u003d $(\u0027backgroundColorText\u0027).value || \u0027#FFFFFF\u0027;\n            // \n            const currentData \u003d SlideEditor.getSlideData();\n            // \n            const dataForPrompt \u003d JSON.parse(JSON.stringify(currentData));\n            dataForPrompt.forEach(slide \u003d\u003e {\n                // \n                if (typeof slide.image \u003d\u003d\u003d \u0027string\u0027 \u0026\u0026 slide.image.startsWith(\u0027data:image/\u0027)) {\n                    slide.image \u003d \"(image data omitted for prompt)\";\n                }\n                // \n                else if (typeof slide.image \u003d\u003d\u003d \u0027object\u0027 \u0026\u0026 slide.image !\u003d\u003d null \u0026\u0026 slide.image.data \u0026\u0026 typeof slide.image.data \u003d\u003d\u003d \u0027string\u0027 \u0026\u0026 slide.image.data.startsWith(\u0027data:image/\u0027)) {\n                    slide.image.data \u003d \"(image data omitted for prompt)\";\n                }\n                // \n                if (slide.ghostImageBase64) {\n                    delete slide.ghostImageBase64;\n                }\n            });\n            // \n            const currentJson \u003d JSON.stringify(dataForPrompt, null, 2);\n            // \n            if (!currentJson) {\n                showStatus(\u0027JSONデータがありません。\u0027, \u0027error\u0027);\n                return;\n            }\n            // \n    let conditions \u003d [];\n    // \n    conditions.push(`${conditions.length + 1}. プライマリカラー: ${primaryColor} (画像全体でこの色に合う配色・デザインにすること。色番号を絶対に画像にテキストとして表示しないように。)`);\n    // \n    conditions.push(`${conditions.length + 1}. 背景色: ${backgroundColor}(色番号を絶対に画像にテキストとして表示しないように。)`);\n    const conditionText \u003d conditions.join(\u0027\\n\u0027);\n    // \n            const promptText \u003d \n`あなたはプロのプレゼンテーションデザイナーです。\n以下のJSONデータは、現在作成中のスライド構成です。\nこのプレゼンテーションの内容全体を総括する「まとめ（Summary）」または「ハイライト」となるインフォグラフィック画像1枚をPNG画像（16:9）として4Kで作成してください。JSON形式他、コードやテキスト形式での出力は絶対にしないでください。\n【デザイン条件】\n${conditionText}\n【現在のスライド構成データ】\n${currentJson}`;\n            if (summaryTextarea) summaryTextarea.value \u003d promptText;\n            if (summaryModal) summaryModal.style.display \u003d \u0027flex\u0027;\n        });\n        // \n        const summaryModal \u003d $(\u0027summaryPromptModal\u0027);\n        const summaryDropZone \u003d $(\u0027summaryDropZone\u0027);\n        const summaryImageUpload \u003d $(\u0027summaryImageUpload\u0027);\n        const summaryFileSelectLink \u003d $(\u0027summaryFileSelectLink\u0027);\n        // \n        const copyBtn \u003d $(\u0027copySummaryOnlyBtn\u0027);   // \n        const closeSummaryBtn \u003d $(\u0027closeSummaryPromptBtn\u0027);\n        const summaryTextarea \u003d $(\u0027summaryPromptTextarea\u0027);\n        if (summaryModal) {\n            // \n            if (copyBtn) {\n                copyBtn.onclick \u003d function() { \n                    const text \u003d summaryTextarea.value;\n                    if (!text) return;\n                    summaryTextarea.select();\n                    summaryTextarea.setSelectionRange(0, 99999); // \n                    // \n                    let copied \u003d false;\n                    try {\n                        copied \u003d document.execCommand(\u0027copy\u0027);\n                    } catch (e) {\n                        console.warn(\u0027execCommand failed:\u0027, e);\n                    }\n                    if (copied) {\n                        showStatus(\u0027プロンプトをコピーしました\u0027, \u0027success\u0027);\n                    } else {\n                        // \n                        if (navigator.clipboard \u0026\u0026 navigator.clipboard.writeText) {\n                            navigator.clipboard.writeText(text)\n                                .then(() \u003d\u003e showStatus(\u0027プロンプトをコピーしました\u0027, \u0027success\u0027))\n                                .catch(() \u003d\u003e alert(\u0027コピーに失敗しました。手動でコピーしてください。\u0027));\n                        } else {\n                            alert(\u0027コピーに失敗しました。手動でコピーしてください。\u0027);\n                        }\n                    }\n                };\n            }\n            // \n            if (summaryDropZone) {\n                summaryDropZone.addEventListener(\u0027dblclick\u0027, async (e) \u003d\u003e {\n                    // \n                    if (e.target.id \u003d\u003d\u003d \u0027summaryFileSelectLink\u0027) return;\n                    try {\n                        // \n                        const clipboardItems \u003d await navigator.clipboard.read();\n                        let imageFound \u003d false;\n                        for (const item of clipboardItems) {\n                            // \n                            const imageTypes \u003d item.types.filter(type \u003d\u003e type.startsWith(\u0027image/\u0027));\n                            if (imageTypes.length \u003e 0) {\n                                const blob \u003d await item.getType(imageTypes[0]);\n                                const file \u003d new File([blob], \"pasted_image.png\", { type: imageTypes[0] });\n                                handleSummaryImageFile(file); // \n                                showStatus(\u0027クリップボードの画像を読み込みました\u0027, \u0027success\u0027);\n                                imageFound \u003d true;\n                                break;\n                            }\n                        }\n                        if (!imageFound) {\n                            showStatus(\u0027クリップボードに画像が見つかりませんでした\u0027, \u0027info\u0027);\n                        }\n                    } catch (err) {\n                        console.error(\u0027Clipboard read failed:\u0027, err);\n                        // \n                        alert(\u0027クリップボードの読み取りに失敗しました。\\nCtrl+V (貼り付け) を試してください。\u0027);\n                    }\n                });\n            }\n            // \n            if (closeSummaryBtn) {\n                closeSummaryBtn.onclick \u003d function() {\n                    summaryModal.style.display \u003d \u0027none\u0027;\n                };\n            }\n            // \n            summaryModal.onclick \u003d function(e) {\n                if (e.target \u003d\u003d\u003d summaryModal) summaryModal.style.display \u003d \u0027none\u0027;\n            };\n            // \n            // \n            if (summaryFileSelectLink \u0026\u0026 summaryImageUpload) {\n                summaryFileSelectLink.onclick \u003d (e) \u003d\u003e {\n                    e.preventDefault();\n                    summaryImageUpload.click();\n                };\n                summaryImageUpload.onchange \u003d () \u003d\u003e {\n                    if (summaryImageUpload.files.length \u003e 0) {\n                        handleSummaryImageFile(summaryImageUpload.files[0]);\n                        summaryImageUpload.value \u003d \u0027\u0027; // \n                    }\n                };\n            }\n            // \n            if (summaryDropZone) {\n                summaryDropZone.ondragover \u003d (e) \u003d\u003e {\n                    e.preventDefault();\n                    summaryDropZone.classList.add(\u0027drag-over\u0027);\n                };\n                summaryDropZone.ondragleave \u003d () \u003d\u003e {\n                    summaryDropZone.classList.remove(\u0027drag-over\u0027);\n                };\n                summaryDropZone.ondrop \u003d (e) \u003d\u003e {\n                    e.preventDefault();\n                    summaryDropZone.classList.remove(\u0027drag-over\u0027);\n                    if (e.dataTransfer.files \u0026\u0026 e.dataTransfer.files.length \u003e 0) {\n                        handleSummaryImageFile(e.dataTransfer.files[0]);\n                    }\n                };\n            }\n            // \n            document.addEventListener(\u0027paste\u0027, (e) \u003d\u003e {\n                if (summaryModal.style.display \u003d\u003d\u003d \u0027none\u0027) return;\n                const items \u003d (e.clipboardData || window.clipboardData).items;\n                for (const item of items) {\n                    if (item.kind \u003d\u003d\u003d \u0027file\u0027 \u0026\u0026 item.type.startsWith(\u0027image/\u0027)) {\n                        e.preventDefault();\n                        handleSummaryImageFile(item.getAsFile());\n                        break;\n                    }\n                }\n            });\n        }\n        // \n      $(\u0027savePreset\u0027).addEventListener(\u0027click\u0027, saveCurrentPreset);\n      $(\u0027deletePreset\u0027).addEventListener(\u0027click\u0027, deleteSelectedPreset);\n      $(\u0027openFolderBtn\u0027).addEventListener(\u0027click\u0027, openFolder);\n      $(\u0027overwritePresetBtn\u0027).addEventListener(\u0027click\u0027, performOverwriteSave);\n      $(\u0027saveAsNewPresetBtn\u0027).addEventListener(\u0027click\u0027, showNewPresetNameInput);\n      $(\u0027confirmSaveBtn\u0027).addEventListener(\u0027click\u0027, performSaveAsNew);\n      $(\u0027cancelNewNameBtn\u0027).addEventListener(\u0027click\u0027, cancelNewPresetName);\n      $(\u0027closePresetModal\u0027).addEventListener(\u0027click\u0027, closePresetModal);\n      $(\u0027presetSaveModal\u0027).addEventListener(\u0027click\u0027, function(e) {\n        if (e.target \u003d\u003d\u003d this) closePresetModal();\n      });\n      $(\u0027presetNameField\u0027).addEventListener(\u0027keypress\u0027, function(e) {\n        if (e.key \u003d\u003d\u003d \u0027Enter\u0027) performSaveAsNew();\n      });\n      validateJSON(); \n      updateGradientPreview();\n      document.querySelectorAll(\u0027.collapsible-header\u0027).forEach(header \u003d\u003e {\n        header.addEventListener(\u0027click\u0027, function() {\n          this.classList.toggle(\u0027active\u0027);\n          this.nextElementSibling.classList.toggle(\u0027active\u0027);\n        });\n      });\n      function convertDriveUrl(url, extractFileIdOnly \u003d false) {\n        if (!url || !url.includes(\u0027drive.google.com\u0027)) return url;\n        const patterns \u003d [ /\\/d\\/([a-zA-Z0-9_-]+)/, /id\u003d([a-zA-Z0-9_-]+)/, /\\/file\\/d\\/([a-zA-Z0-9_-]+)/ ];\n        for (let i \u003d 0; i \u003c patterns.length; i++) {\n          const match \u003d url.match(patterns[i]);\n          if (match \u0026\u0026 match[1]) {\n            const fileId \u003d match[1];\n            return extractFileIdOnly ? fileId : \u0027https://drive.google.com/uc?export\u003dview\u0026id\u003d\u0027 + fileId;\n          }\n        }\n        return url;\n      }\n      function setupAutoConvertInput(input, useFileIdOnly \u003d false) {\n        input.addEventListener(\u0027input\u0027, function() {\n          let url \u003d this.value.trim();\n          if (url) {\n            let convertedUrl \u003d convertDriveUrl(url, useFileIdOnly);\n            if (convertedUrl !\u003d\u003d url) {\n              this.value \u003d convertedUrl;\n              showStatus(\u0027Googleドライブリンクを自動変換しました\u0027, \u0027success\u0027);\n            }\n          }\n        });\n      }\n      function getPreviewUrl(inputValue) {\n        if (!inputValue) return null;\n        if (inputValue.startsWith(\u0027http\u0027) \u0026\u0026 !inputValue.includes(\u0027drive.google.com\u0027)) return inputValue;\n        if (/^[a-zA-Z0-9_-]{25,}$/.test(inputValue)) return \u0027https://drive.google.com/file/d/\u0027 + inputValue + \u0027/view\u0027;\n        const match \u003d inputValue.match(/[?\u0026]id\u003d([a-zA-Z0-9_-]+)/);\n        if (match \u0026\u0026 match[1]) return \u0027https://drive.google.com/file/d/\u0027 + match[1] + \u0027/view\u0027;\n        return inputValue;\n      }\n      document.querySelectorAll(\u0027.btn-secondary\u0027).forEach(button \u003d\u003e {\n        if (button.id \u003d\u003d\u003d \u0027openFolderBtn\u0027 || button.id \u003d\u003d\u003d \u0027deletePreset\u0027 || button.id \u003d\u003d\u003d \u0027cancelGenerationBtn\u0027 || button.id \u003d\u003d\u003d \u0027closePresetModal\u0027) return;\n        button.addEventListener(\u0027click\u0027, function() {\n          const input \u003d this.parentElement.querySelector(\u0027input[type\u003d\"text\"]\u0027);\n          if (input) {\n            const inputValue \u003d input.value.trim();\n            if (inputValue) {\n              const previewUrl \u003d getPreviewUrl(inputValue);\n              if (previewUrl) { window.open(previewUrl, \u0027_blank\u0027, \u0027noopener,noreferrer\u0027); } \n              else { alert(\u0027プレビューできない形式です\u0027); }\n            } else { alert(\u0027URLを入力してください\u0027); }\n          }\n        });\n      });\n      try {\n        const splitter \u003d $(\u0027splitter\u0027);\n        const appLayout \u003d $(\u0027app-layout\u0027);\n        const leftPane \u003d $(\u0027left-pane\u0027);\n        const rightPane \u003d $(\u0027slidePreviewContainer\u0027);\n        let isDragging \u003d false;\n        const minWidth \u003d 300;\n        splitter.addEventListener(\u0027mousedown\u0027, (e) \u003d\u003e {\n          e.preventDefault();\n          isDragging \u003d true;\n          splitter.classList.add(\u0027dragging\u0027);\n          document.body.style.userSelect \u003d \u0027none\u0027;\n          leftPane.style.pointerEvents \u003d \u0027none\u0027;\n          rightPane.style.pointerEvents \u003d \u0027none\u0027;\n        });\n        document.addEventListener(\u0027mousemove\u0027, (e) \u003d\u003e {\n          if (!isDragging) return;\n          e.preventDefault();\n          const splitterWidth \u003d splitter.offsetWidth;\n          const totalWidth \u003d window.innerWidth;\n          let leftPaneWidth \u003d e.clientX;\n          let rightPaneWidth \u003d totalWidth - leftPaneWidth - splitterWidth;\n          if (leftPaneWidth \u003c minWidth) {\n            leftPaneWidth \u003d minWidth;\n            rightPaneWidth \u003d totalWidth - leftPaneWidth - splitterWidth;\n          } else if (rightPaneWidth \u003c minWidth) {\n            rightPaneWidth \u003d minWidth;\n            leftPaneWidth \u003d totalWidth - rightPaneWidth - splitterWidth;\n          }\n          const leftFr \u003d (leftPaneWidth / totalWidth) * 100;\n          const rightFr \u003d (rightPaneWidth / totalWidth) * 100;\n          const newRatio \u003d `${leftFr}fr ${splitterWidth}px ${rightFr}fr`;\n          appLayout.style.gridTemplateColumns \u003d newRatio;\n        });\n        document.addEventListener(\u0027mouseup\u0027, () \u003d\u003e {\n          if (isDragging) {\n            isDragging \u003d false;\n            splitter.classList.remove(\u0027dragging\u0027);\n            document.body.style.userSelect \u003d \u0027\u0027;\n            leftPane.style.pointerEvents \u003d \u0027\u0027;\n            rightPane.style.pointerEvents \u003d \u0027\u0027;\n            lastSplitRatio \u003d appLayout.style.gridTemplateColumns; \n          }\n        });\n      } catch(e) {\n        console.error(\u0027スプリッターの初期化に失敗:\u0027, e);\n      }\n      const toggleFullscreenBtn \u003d $(\u0027toggleFullscreenBtn\u0027);\n      if (toggleFullscreenBtn) {\n         toggleFullscreenBtn.addEventListener(\u0027click\u0027, toggleFullscreenPreview);\n      }\n      try {\n        const leftPane \u003d $(\u0027left-pane\u0027);\n        const mainGridInLeftPane \u003d leftPane.querySelector(\u0027.main-grid\u0027);\n        const bodyEl \u003d document.body;\n        // \n        window.adjustResponsiveLayout \u003d function() {\n            const leftPane \u003d document.getElementById(\u0027left-pane\u0027);\n            const bodyEl \u003d document.body;\n            if (!leftPane || !bodyEl) {\n                console.error(\u0027[Debug Layout] Elements not found\u0027);\n                return;\n            }\n            // \n            const rect \u003d leftPane.getBoundingClientRect();\n            const paneWidth \u003d rect.width;\n            const verticalThreshold \u003d 992;\n            if (paneWidth \u003c verticalThreshold) {\n              if (!leftPane.classList.contains(\u0027vertical-layout\u0027)) {\n                  leftPane.classList.add(\u0027vertical-layout\u0027);\n              }\n            } else {\n              if (leftPane.classList.contains(\u0027vertical-layout\u0027)) {\n                  leftPane.classList.remove(\u0027vertical-layout\u0027);\n              }\n            }\n            // \n            const currentIsNarrow \u003d leftPane.classList.contains(\u0027narrow-layout\u0027);\n            const narrowThresholdEnter \u003d 650; \n            const narrowThresholdExit \u003d 670; \n            if (!currentIsNarrow \u0026\u0026 paneWidth \u003c narrowThresholdEnter) { \n              leftPane.classList.add(\u0027narrow-layout\u0027);\n              bodyEl.classList.add(\u0027narrow-layout\u0027);\n              document.documentElement.style.setProperty(\u0027--bg-body\u0027, \u0027#F9FAFB\u0027);\n              document.documentElement.style.setProperty(\u0027--card-header-bg\u0027, \u0027#F9FAFB\u0027);\n            } else if (currentIsNarrow \u0026\u0026 paneWidth \u003e narrowThresholdExit) {\n              leftPane.classList.remove(\u0027narrow-layout\u0027);\n              bodyEl.classList.remove(\u0027narrow-layout\u0027);\n              if (typeof updateBackgroundColor \u003d\u003d\u003d \u0027function\u0027) {\n                  const bgInput \u003d document.getElementById(\u0027backgroundColorText\u0027);\n                  if (bgInput) updateBackgroundColor(bgInput.value);\n              }\n            }\n        };\n        // \n        if (window.ResizeObserver \u0026\u0026 mainGridInLeftPane \u0026\u0026 bodyEl) {\n          const observer \u003d new ResizeObserver(entries \u003d\u003e {\n            // \n            window.adjustResponsiveLayout();\n          });\n          observer.observe(leftPane);\n        }\n      } catch(e) {\n        console.error(\u0027ResizeObserverの初期化に失敗:\u0027, e);\n      }\n      document.querySelectorAll(\u0027#titleBgUrl, #sectionBgUrl, #mainBgUrl, #closingBgUrl, #headerLogoUrl, #closingLogoUrl\u0027).forEach(input \u003d\u003e {\n        setupAutoConvertInput(input, true);\n      });\n      try {\n        const appLayout \u003d $(\u0027app-layout\u0027);\n        const leftPane \u003d $(\u0027left-pane\u0027);\n        const previewPane \u003d $(\u0027slidePreviewContainer\u0027);\n        const splitter \u003d $(\u0027splitter\u0027);\n        const closePreviewBtn \u003d $(\u0027closePreviewBtn\u0027);\n        const closeSettingsBtn \u003d $(\u0027closeSettingsBtn\u0027);\n        if (closePreviewBtn) {\n          closePreviewBtn.addEventListener(\u0027click\u0027, () \u003d\u003e {\n            hidePreviewPane(); \n          });\n        }\n        if (closeSettingsBtn) {\n          closeSettingsBtn.addEventListener(\u0027click\u0027, () \u003d\u003e {\n            if (!isSlideFullscreen) {\n              if (!isPreviewVisible) {\n                if (!lastGeneratedSlideUrl) {\n                   showStatus(\u0027エラー: 表示するスライドがありません。\u0027, \u0027error\u0027);\n                   return;\n                }\n                let embedUrl \u003d lastGeneratedSlideUrl.replace(\"/edit\", \"/embed\");\n                $(\u0027slidePreviewFrame\u0027).src \u003d embedUrl;\n                previewPane.style.display \u003d \u0027block\u0027;\n                splitter.style.display \u003d \u0027block\u0027;\n                $(\u0027fullscreenToggleContainer\u0027).style.display \u003d \u0027block\u0027;\n                appLayout.style.gridTemplateColumns \u003d lastSplitRatio;\n                isPreviewVisible \u003d true;\n              }\n              toggleFullscreenPreview();\n            }\n          });\n        }\n      } catch(e) {\n        console.error(\u0027パネルクローズボタンの初期化に失敗:\u0027, e);\n      }\n      const closeJsonErrorModalBtn \u003d $(\u0027closeJsonErrorModalBtn\u0027);\n      const copyJsonErrorBtn \u003d $(\u0027copyJsonErrorBtn\u0027);\n      const jsonErrorModal \u003d $(\u0027jsonErrorModal\u0027);\n      if (closeJsonErrorModalBtn) {\n        closeJsonErrorModalBtn.addEventListener(\u0027click\u0027, closeJsonErrorModal);\n      }\n      if (copyJsonErrorBtn) {\n        copyJsonErrorBtn.addEventListener(\u0027click\u0027, copyJsonError);\n      }\n      if (jsonErrorModal) {\n        jsonErrorModal.addEventListener(\u0027click\u0027, (e) \u003d\u003e {\n          if (e.target \u003d\u003d\u003d jsonErrorModal) {\n            closeJsonErrorModal();\n          }\n        });\n      }\n      const confirmClearBtn \u003d $(\u0027confirmClearBtn\u0027);\n      const cancelClearBtn \u003d $(\u0027cancelClearBtn\u0027);\n      const clearConfirmModal \u003d $(\u0027clearConfirmModal\u0027);\n      if (confirmClearBtn) {\n        confirmClearBtn.addEventListener(\u0027click\u0027, performClear);\n      }\n      if (cancelClearBtn) {\n        cancelClearBtn.addEventListener(\u0027click\u0027, closeClearConfirmModal);\n      }\n      if (clearConfirmModal) {\n        clearConfirmModal.addEventListener(\u0027click\u0027, (e) \u003d\u003e {\n          if (e.target \u003d\u003d\u003d clearConfirmModal) {\n            closeClearConfirmModal();\n          }\n        });\n      }\n      const cancelDeleteItemBtn \u003d $(\u0027cancelDeleteItemBtn\u0027);\n      const deleteItemConfirmModal \u003d $(\u0027deleteItemConfirmModal\u0027);\n      if (cancelDeleteItemBtn) {\n        // \n        cancelDeleteItemBtn.addEventListener(\u0027click\u0027, closeDeleteItemConfirmModal);\n      }\n      if (deleteItemConfirmModal) {\n        // \n        deleteItemConfirmModal.addEventListener(\u0027click\u0027, (e) \u003d\u003e {\n          if (e.target \u003d\u003d\u003d deleteItemConfirmModal) {\n            closeDeleteItemConfirmModal();\n          }\n        });\n      }\n      const showPreviewBtnLeft \u003d $(\u0027showPreviewBtnLeft\u0027);\n      if (showPreviewBtnLeft) {\n        showPreviewBtnLeft.addEventListener(\u0027click\u0027, () \u003d\u003e {\n          if (lastGeneratedSlideUrl) {\n            showPreviewPane();\n            if (SlideEditor \u0026\u0026 SlideEditor.isEditorActive()) {\n              SlideEditor.updatePreviewButtonForEditor(true);\n            }\n          } else {\n            showStatus(\u0027エラー: 表示するスライドがありません。\u0027, \u0027error\u0027);\n          }\n        });\n      }\n      // \n      try {\n        const termsModal \u003d $(\u0027termsModal\u0027);\n        const closeTermsModalBtn \u003d $(\u0027closeTermsModalBtn\u0027); // \n        function closeTermsModal() {\n          if (termsModal) {\n            termsModal.style.display \u003d \u0027none\u0027;\n            // \n            const iframe \u003d $(\u0027termsFrame\u0027);\n            if (iframe) {\n              // \n            }\n          }\n        }\n        if (closeTermsModalBtn) {\n          closeTermsModalBtn.addEventListener(\u0027click\u0027, closeTermsModal);\n        }\n        if (termsModal) {\n          termsModal.addEventListener(\u0027click\u0027, (e) \u003d\u003e {\n            if (e.target \u003d\u003d\u003d termsModal) { // \n              closeTermsModal();\n            }\n          });\n        }\n      } catch(e) {\n        console.error(\u0027利用規約モーダルの閉じるイベント設定に失敗:\u0027, e);\n      }\n      // \n    }\n    // \n    let activationData;\n    try {\n      // \n      activationData \u003d \u003c?!\u003d JSON.stringify(activationData) ?\u003e;\n} catch (e) {\n      console.error(\"アクティベーションデータの読み込みに失敗\", e);\n      activationData \u003d { isActivated: false, userEmail: null }; // \n    }\n    if (ENABLE_CREDIT_IMAGE \u003d\u003d\u003d false || activationData.isActivated) {\n      // \n      initializeAppLogic();\n    } else {\n      // \n      // \n      ActivationFlow.init(activationData.userEmail, initializeAppLogic);\n      ActivationFlow.start();\n    }\n    // \n    google.script.run\n      .withSuccessHandler((historyItems) \u003d\u003e {\n        cachedHistoryList \u003d historyItems; // \n      })\n      .withFailureHandler((e) \u003d\u003e {\n        console.warn(\u0027[Preload] 履歴の先読みに失敗しました:\u0027, e);\n      })\n      .getUserHistory();\n    // \n    const historyInput \u003d $(\u0027historyInputId\u0027);\n    if (historyInput) {\n        historyInput.addEventListener(\u0027dblclick\u0027, async function() {\n            try {\n                // \n                const text \u003d await navigator.clipboard.readText();\n                if (!text) {\n                    showStatus(\u0027クリップボードが空です\u0027, \u0027info\u0027);\n                    return;\n                }\n                // \n                this.value \u003d text;\n                showStatus(\u0027クリップボードから貼り付けました。検証中...\u0027, \u0027info\u0027, 2000);\n                // \n                // \n                let rawVal \u003d text.trim();\n                let targetId \u003d null;\n                const urlPatterns \u003d [\n                    /\\/d\\/([a-zA-Z0-9_-]+)/,\n                    /id\u003d([a-zA-Z0-9_-]+)/,\n                    /\\/file\\/d\\/([a-zA-Z0-9_-]+)/\n                ];\n                for (const p of urlPatterns) {\n                    const m \u003d rawVal.match(p);\n                    if (m \u0026\u0026 m[1]) { targetId \u003d m[1]; break; }\n                }\n                if (!targetId \u0026\u0026 /^[a-zA-Z0-9_-]{25,}$/.test(rawVal)) {\n                    targetId \u003d rawVal;\n                }\n                if (targetId) {\n                    // \n                    showStatus(\u0027IDを認識しました。読み込みを開始します...\u0027, \u0027success\u0027);\n                    executeRestore(targetId);\n                } else {\n                    // \n                    showStatus(\u0027無効なURLまたはスライドID形式です\u0027, \u0027error\u0027);\n                    this.value \u003d \u0027\u0027; // \n                }\n                // \n            } catch (err) {\n                console.warn(\u0027Clipboard read failed:\u0027, err);\n                showStatus(\u0027クリップボードの読み取りに失敗しました\u0027, \u0027error\u0027);\n            }\n        });\n    }\n    // \n});\n  // \n  const historyBtn \u003d document.getElementById(\u0027historyRestoreBtn\u0027);\n  if (historyBtn) {\n    historyBtn.addEventListener(\u0027click\u0027, function() {\n      openHistoryModal();\n    });\n  }\n  function openHistoryModal() {\n    const modal \u003d $(\u0027historyRestoreModal\u0027);\n    const input \u003d $(\u0027historyInputId\u0027);\n    const listContainer \u003d $(\u0027historyListContainer\u0027);\n    const loadBtn \u003d $(\u0027historyLoadBtn\u0027);\n    const closeBtn \u003d $(\u0027historyCloseBtn\u0027);\n    // \n    const STORAGE_KEY_HISTORY \u003d \u0027slideFactory_history_cache_v1\u0027;\n    if (!modal) return;\n    // \n    input.value \u003d \u0027\u0027;\n    if (lastGeneratedSlideUrl) {\n       const match \u003d lastGeneratedSlideUrl.match(/\\/d\\/([a-zA-Z0-9_-]+)/);\n       if (match \u0026\u0026 match[1]) input.value \u003d match[1];\n    }\n    modal.style.display \u003d \u0027flex\u0027;\n    // \n    // \n    const cachedJson \u003d localStorage.getItem(STORAGE_KEY_HISTORY);\n    if (cachedJson) {\n        try {\n            const cachedItems \u003d JSON.parse(cachedJson);\n            if (Array.isArray(cachedItems) \u0026\u0026 cachedItems.length \u003e 0) {\n                renderHistoryList(cachedItems);\n            } else {\n                // \n                listContainer.innerHTML \u003d \u0027\u003cdiv style\u003d\"padding: 2rem; text-align: center; color: var(--text-light);\"\u003e履歴を読み込み中...\u003c/div\u003e\u0027;\n            }\n        } catch (e) {\n            console.warn(\u0027ローカルストレージのパース失敗:\u0027, e);\n            listContainer.innerHTML \u003d \u0027\u003cdiv style\u003d\"padding: 2rem; text-align: center; color: var(--text-light);\"\u003e履歴を読み込み中...\u003c/div\u003e\u0027;\n        }\n    } else {\n        // \n        listContainer.innerHTML \u003d \u0027\u003cdiv style\u003d\"padding: 2rem; text-align: center; color: var(--text-light);\"\u003e履歴を読み込み中...\u003c/div\u003e\u0027;\n    }\n    // \n    google.script.run\n      .withSuccessHandler((historyItems) \u003d\u003e {\n         // \n         localStorage.setItem(STORAGE_KEY_HISTORY, JSON.stringify(historyItems));\n         // \n         renderHistoryList(historyItems);\n      })\n      .withFailureHandler((e) \u003d\u003e {\n         console.error(\u0027履歴取得エラー:\u0027, e);\n         // \n         if (!cachedJson) {\n             listContainer.innerHTML \u003d `\u003cdiv style\u003d\"padding: 1rem; color: var(--danger-color);\"\u003e履歴の取得に失敗しました: ${e.message}\u003c/div\u003e`;\n         } else {\n             showStatus(\u0027最新の履歴取得に失敗しました（キャッシュを表示中）\u0027, \u0027error\u0027);\n         }\n      })\n      .getUserHistory();\n    // \n    // \n    closeBtn.onclick \u003d () \u003d\u003e { modal.style.display \u003d \u0027none\u0027; };\n    modal.onclick \u003d (e) \u003d\u003e { if (e.target \u003d\u003d\u003d modal) modal.style.display \u003d \u0027none\u0027; };\n    // \n    loadBtn.onclick \u003d () \u003d\u003e {\n      validateAndLoadId(input.value);\n    };\n  }\n  function validateAndLoadId(rawVal) {\n      rawVal \u003d rawVal.trim();\n      if (!rawVal) {\n        showStatus(\u0027IDまたはURLを入力してください\u0027, \u0027error\u0027);\n        return false;\n      }\n      let targetId \u003d null;\n      // \n      const urlPatterns \u003d [\n        /\\/d\\/([a-zA-Z0-9_-]+)/,\n        /id\u003d([a-zA-Z0-9_-]+)/,\n        /\\/file\\/d\\/([a-zA-Z0-9_-]+)/\n      ];\n      for (const p of urlPatterns) {\n        const m \u003d rawVal.match(p);\n        if (m \u0026\u0026 m[1]) {\n          targetId \u003d m[1];\n          break;\n        }\n      }\n      // \n      if (!targetId) {\n          if (/^[a-zA-Z0-9_-]{25,}$/.test(rawVal)) {\n              targetId \u003d rawVal;\n          }\n      }\n      if (targetId) {\n          // \n          executeRestore(targetId);\n          return true;\n      } else {\n          // \n          showStatus(\u0027無効なURLまたはスライドID形式です\u0027, \u0027error\u0027);\n          const input \u003d $(\u0027historyInputId\u0027);\n          if(input) {\n              input.value \u003d \u0027\u0027; // \n              input.focus();\n          }\n          return false;\n      }\n  }\n  function getRelativeTimeClient(timestamp) {\n    if (!timestamp) return \u0027\u0027;\n    const now \u003d new Date();\n    const date \u003d new Date(timestamp);\n    const diffMs \u003d now.getTime() - date.getTime();\n    const diffMins \u003d Math.floor(diffMs / 60000);\n    if (diffMins \u003c 1) return \u0027たった今\u0027;\n    if (diffMins \u003c 60) return `${diffMins}分前`;\n    const diffHours \u003d Math.floor(diffMins / 60);\n    if (diffHours \u003c 24) return `${diffHours}時間前`;\n    const diffDays \u003d Math.floor(diffHours / 24);\n    return `${diffDays}日前`;\n  }\n  function escapeHTML(str) {\n    if (str \u003d\u003d\u003d null || typeof str \u003d\u003d\u003d \u0027undefined\u0027) return \u0027\u0027;\n    return String(str)\n      .replace(/\u0026/g, \u0027\u0026amp;\u0027)\n      .replace(/\u003c/g, \u0027\u0026lt;\u0027)\n      .replace(/\u003e/g, \u0027\u0026gt;\u0027)\n      .replace(/\"/g, \u0027\u0026quot;\u0027)\n      .replace(/\u0027/g, \u0027\u0026#039;\u0027);\n  }\n  function renderHistoryList(historyItems) {\n    const container \u003d $(\u0027historyListContainer\u0027);\n    if (!historyItems || historyItems.length \u003d\u003d\u003d 0) {\n      container.innerHTML \u003d `\u003cdiv style\u003d\"padding: 2rem; text-align: center; color: var(--text-secondary);\"\u003e履歴はありません\u003c/div\u003e`;\n      return;\n    }\n    let html \u003d \u0027\u0027;\n    try {\n      historyItems.forEach((item, index) \u003d\u003e {\n        // \n        if (!item || !item.id) {\n          console.warn(`[Client Debug] Invalid item at index ${index}:`, item); // \n          return;\n        }\n        const name \u003d escapeHTML(item.name || \u0027名称未設定\u0027);\n        let dateStr \u003d escapeHTML(item.lastModified || \u0027-\u0027);\n        let timestamp \u003d item.timestamp;\n        // \n        if (!timestamp \u0026\u0026 dateStr.includes(\u0027(\u0027)) {\n             // \n             const cleanDateStr \u003d dateStr.split(\u0027(\u0027)[0].trim();\n             const d \u003d new Date(cleanDateStr);\n             if (!isNaN(d.getTime())) {\n                 timestamp \u003d d.getTime();\n                 dateStr \u003d cleanDateStr; // \n             }\n        }\n        // \n        if (timestamp) {\n            const relTime \u003d getRelativeTimeClient(timestamp);\n            dateStr \u003d `${dateStr} \u003cspan style\u003d\"color: var(--primary-color); font-size: 0.9em;\"\u003e(${relTime})\u003c/span\u003e`;\n        }\n        const date \u003d dateStr; // \n        const editor \u003d escapeHTML(item.editor || \u0027-\u0027);\n        const id \u003d escapeHTML(item.id);\n        html +\u003d `\n          \u003cdiv class\u003d\"history-item\" onclick\u003d\"executeRestore(\u0027${id}\u0027)\" title\u003d\"クリックして復元\"\u003e\n            \u003cdiv class\u003d\"history-item-title\"\u003e\n              \u003cspan class\u003d\"history-tag\"\u003eSLIDE\u003c/span\u003e ${name}\n            \u003c/div\u003e\n            \u003cdiv class\u003d\"history-item-meta\"\u003e\n              \u003cspan\u003e📅 ${date}\u003c/span\u003e\n              \u003cspan style\u003d\"max-width: 150px; overflow: hidden; text-overflow: ellipsis;\"\u003e👤 ${editor}\u003c/span\u003e\n            \u003c/div\u003e\n          \u003c/div\u003e\n        `;\n      });\n      container.innerHTML \u003d html;\n    } catch (e) {\n      console.error(\u0027[Client Debug] Error during renderHistoryList loop:\u0027, e); // \n      container.innerHTML \u003d `\u003cdiv style\u003d\"padding: 1rem; color: red;\"\u003e描画エラーが発生しました: ${e.message}\u003c/div\u003e`;\n    }\n  }\n  window.executeRestore \u003d function(presentationId) {\n    const modal \u003d $(\u0027historyRestoreModal\u0027);\n    if (modal) modal.style.display \u003d \u0027none\u0027; // \n    showStatus(\u0027履歴データを読み込んでいます...\u0027, \u0027info\u0027, 10000);\n    google.script.run\n      .withSuccessHandler(function(response) {\n        if (response.status \u003d\u003d\u003d \u0027success\u0027) {\n          const historyData \u003d response.data;\n          const savedSettings \u003d historyData.settings;\n          const savedSlideData \u003d historyData.slideData;\n          const url \u003d response.url;\n          // \n          lastGeneratedSlideUrl \u003d url;\n          // \n          if (savedSettings) {\n            applyAllSettings(savedSettings);\n          }\n          // \n          if (savedSlideData) {\n            // \n            savedSlideData.forEach(slide \u003d\u003e {\n              if (slide._originalImage) {\n                slide.image \u003d slide._originalImage;\n                delete slide._originalImage;\n              }\n              if (slide.ghostImageBase64) delete slide.ghostImageBase64;\n            });\n            const jsonString \u003d JSON.stringify(savedSlideData, null, 2);\n            const textarea \u003d $(\u0027slideDataInput\u0027);\n            // \n            if (typeof SlideEditor !\u003d\u003d \u0027undefined\u0027 \u0026\u0026 SlideEditor.reset) {\n               SlideEditor.reset();\n            }\n            textarea.value \u003d jsonString;\n            if (typeof validateJSON \u003d\u003d\u003d \u0027function\u0027) {\n                // \n                // \n                validateJSON(); \n            }\n            // \n            if (typeof SlideEditor !\u003d\u003d \u0027undefined\u0027 \u0026\u0026 SlideEditor.setupForUpdate) {\n               SlideEditor.setupForUpdate();\n            }\n            if (typeof SlideEditor !\u003d\u003d \u0027undefined\u0027 \u0026\u0026 SlideEditor.autoResizeTextarea) {\n               SlideEditor.autoResizeTextarea(textarea);\n            }\n          }\n          // \n          if (lastGeneratedSlideUrl) {\n              // \n              const newTabBtn \u003d $(\u0027openSlideNewTabBtn\u0027);\n              if(newTabBtn) {\n                  newTabBtn.href \u003d lastGeneratedSlideUrl;\n                  newTabBtn.style.display \u003d \u0027inline-flex\u0027;\n              }\n              // \n              if (typeof showPreviewPane \u003d\u003d\u003d \u0027function\u0027) {\n                  showPreviewPane();\n                  if (typeof SlideEditor !\u003d\u003d \u0027undefined\u0027 \u0026\u0026 SlideEditor.updatePreviewButtonForEditor) {\n                      SlideEditor.updatePreviewButtonForEditor(true);\n                  }\n              }\n              // \n              const iframe \u003d $(\u0027slidePreviewFrame\u0027);\n              if (iframe) {\n                  let previewSrc \u003d lastGeneratedSlideUrl;\n                  if (previewSrc.includes(\u0027/edit\u0027)) {\n                      previewSrc \u003d previewSrc.replace(\"/edit\", \"/embed\");\n                  }\n                  // \n                  if (iframe.src !\u003d\u003d previewSrc) {\n                      iframe.src \u003d previewSrc;\n                  }\n              }\n          }\n          // \n          google.script.run.addToUserHistory(presentationId);\n          showStatus(`日時: ${historyData.dateStr} のデータを読み込みました。`, \u0027success\u0027);\n        } else {\n          showStatus(\u0027エラー: \u0027 + response.message, \u0027error\u0027);\n        }\n      })\n      .withFailureHandler(function(e) {\n        showStatus(\u0027サーバーエラー: \u0027 + e.message, \u0027error\u0027);\n      })\n      .loadLatestGenerationState(presentationId);\n  };\n    function promptImageUpdateOption() {\n      return new Promise((resolve, reject) \u003d\u003e {\n        const modal \u003d $(\u0027imageUpdateOptionModal\u0027);\n        const updateBtn \u003d $(\u0027imageOptionUpdateBtn\u0027);\n        const keepBtn \u003d $(\u0027imageOptionKeepBtn\u0027);\n        const cancelBtn \u003d $(\u0027imageOptionCancelBtn\u0027);\n        // \n        let listenersAttached \u003d false;\n        function cleanup() {\n          updateBtn.removeEventListener(\u0027click\u0027, handleUpdate);\n          keepBtn.removeEventListener(\u0027click\u0027, handleKeep);\n          cancelBtn.removeEventListener(\u0027click\u0027, handleCancel);\n          modal.style.display \u003d \u0027none\u0027;\n        }\n        function handleUpdate() {\n          cleanup();\n          resolve(\u0027update\u0027); // \n        }\n        function handleKeep() {\n          cleanup();\n          resolve(\u0027keep\u0027); // \n        }\n        function handleCancel() {\n          cleanup();\n          reject(new Error(\u0027ユーザーによって操作がキャンセルされました。\u0027)); // \n        }\n        if (!listenersAttached) {\n            updateBtn.addEventListener(\u0027click\u0027, handleUpdate);\n            keepBtn.addEventListener(\u0027click\u0027, handleKeep);\n            cancelBtn.addEventListener(\u0027click\u0027, handleCancel);\n            listenersAttached \u003d true;\n        }\n        modal.style.display \u003d \u0027flex\u0027; // \n      });\n    }\n    function calculateColorMatrixValues(hex) {\n      const rgb \u003d hexToRgb(hex); // \n      if (!rgb) {\n        // \n        return \"0.33 0.33 0.33 0 0 0.33 0.33 0.33 0 0 0.33 0.33 0.33 0 0 0 0 0 1 0\";\n      }\n      // \n      const rNorm \u003d rgb.r / 255;\n      const gNorm \u003d rgb.g / 255;\n      const bNorm \u003d rgb.b / 255;\n      // \n      const rVal \u003d (0.33 * rNorm).toFixed(4);\n      const gVal \u003d (0.33 * gNorm).toFixed(4);\n      const bVal \u003d (0.33 * bNorm).toFixed(4);\n      // \n      return [\n        rVal, rVal, rVal, 0, 0,\n        gVal, gVal, gVal, 0, 0,\n        bVal, bVal, bVal, 0, 0,\n        0, 0, 0, 1, 0\n      ].join(\u0027 \u0027);\n    }\n    function generateGhostNumberSvg(number, width, height, settings) {\n      // \n      const seed \u003d Math.floor(Math.random() * 1000);\n      // \n      const fontSize \u003d Math.floor(height * 1.0);\n      // \n      const {\n        baseFrequency,\n        // \n        alphaSlope,\n        contrastSlope,\n        frontColor,\n        frontAlpha // \n      } \u003d settings;\n      const contrastIntercept \u003d (0.5 * (1 - contrastSlope)).toFixed(2);\n      // \n      const matrixValues \u003d calculateColorMatrixValues(frontColor);\n      // \n      const colorMatrixFilter \u003d `\n    \u003cfeColorMatrix in\u003d\"noise\" type\u003d\"matrix\"\n        values\u003d\"${matrixValues}\"\n        result\u003d\"coloredNoise\"/\u003e`;\n      // \n      const compositeIn \u003d \u0027coloredNoise\u0027;\n      // \n      // \n      const svgString \u003d `\n\u003csvg width\u003d\"${width}\" height\u003d\"${height}\" viewBox\u003d\"0 0 ${width} ${height}\" xmlns\u003d\"http://www.w3.org/2000/svg\" xmlns:xlink\u003d\"http://www.w3.org/1999/xlink\"\u003e\n  \u003cdefs\u003e\n    \u003cfilter id\u003d\"ghostNoiseFilter\" x\u003d\"0\" y\u003d\"0\" width\u003d\"100%\" height\u003d\"100%\"\u003e\n      \u003cfeTurbulence\n          type\u003d\"fractalNoise\"\n          baseFrequency\u003d\"${baseFrequency}\"\n          numOctaves\u003d\"3\"\n          seed\u003d\"${seed}\"\n          result\u003d\"noise\"/\u003e\n      ${colorMatrixFilter}\n      \u003cfeComposite in\u003d\"${compositeIn}\" in2\u003d\"SourceAlpha\" operator\u003d\"in\" result\u003d\"maskedNoise\"/\u003e\n      \u003cfeComponentTransfer in\u003d\"maskedNoise\" result\u003d\"finalTexture\"\u003e\n          \u003cfeFuncR type\u003d\"linear\" slope\u003d\"${contrastSlope}\" intercept\u003d\"${contrastIntercept}\"/\u003e\n          \u003cfeFuncG type\u003d\"linear\" slope\u003d\"${contrastSlope}\" intercept\u003d\"${contrastIntercept}\"/\u003e\n          \u003cfeFuncB type\u003d\"linear\" slope\u003d\"${contrastSlope}\" intercept\u003d\"${contrastIntercept}\"/\u003e\n          \u003cfeFuncA type\u003d\"linear\" slope\u003d\"${alphaSlope}\" intercept\u003d\"0\"/\u003e\n      \u003c/feComponentTransfer\u003e\n      \u003cfeMerge\u003e\n        \u003cfeMergeNode in\u003d\"finalTexture\"/\u003e\n      \u003c/feMerge\u003e\n    \u003c/filter\u003e\n  \u003c/defs\u003e\n  \u003ctext\n      x\u003d\"43%\"\n      y\u003d\"50%\"\n      dominant-baseline\u003d\"middle\"\n      text-anchor\u003d\"middle\"\n      font-size\u003d\"${fontSize}\"\n      font-family\u003d\"\u0027Verdana\u0027, sans-serif\"  font-weight\u003d\"bold\"  fill\u003d\"${frontColor}\"\n      filter\u003d\"url(#ghostNoiseFilter)\" fill-opacity\u003d\"0.45\"\u003e\n      ${number}\n  \u003c/text\u003e\n  \u003ctext\n      x\u003d\"43%\"\n      y\u003d\"50%\"\n      dominant-baseline\u003d\"middle\"\n      text-anchor\u003d\"middle\"\n      font-size\u003d\"${fontSize}\"\n      font-family\u003d\"\u0027Verdana\u0027, sans-serif\"  font-weight\u003d\"bold\"  fill\u003d\"${frontColor}\"\n      fill-opacity\u003d\"0.1\"\u003e\n      ${number}\n  \u003c/text\u003e\n\u003c/svg\u003e`;\n      return svgString;\n    }\n    function generateCreditSvg(text, primaryColor) {\n      // \n      const seed \u003d Math.floor(Math.random() * 1000);\n      // \n      const matrixValues \u003d calculateColorMatrixValues(primaryColor);\n      // \n      const escapedText \u003d (text || \u0027\u0027)\n          .replace(/\u0026/g, \u0027\u0026amp;\u0027)\n          .replace(/\u003c/g, \u0027\u0026lt;\u0027)\n          .replace(/\u003e/g, \u0027\u0026gt;\u0027);\n      // \n      const svgString \u003d `\n\u003csvg width\u003d\"500\" height\u003d\"50\" viewBox\u003d\"0 0 200 40\" xmlns\u003d\"http://www.w3.org/2000/svg\" xmlns:xlink\u003d\"http://www.w3.org/1999/xlink\"\u003e\n  \u003cdefs\u003e\n    \u003cfilter id\u003d\"ghostNoiseFilter_Strong\" x\u003d\"0\" y\u003d\"0\" width\u003d\"100%\" height\u003d\"100%\"\u003e\n      \u003cfeTurbulence\n          type\u003d\"turbulence\"\n          baseFrequency\u003d\"0.7\"\n          numOctaves\u003d\"3\"\n          seed\u003d\"${seed}\" \n          result\u003d\"noise\"/\u003e\n      \u003cfeColorMatrix in\u003d\"noise\" type\u003d\"matrix\"\n        values\u003d\"${matrixValues}\"\n        result\u003d\"coloredNoise\"/\u003e\n      \u003cfeComposite in\u003d\"coloredNoise\" in2\u003d\"SourceAlpha\" operator\u003d\"in\" result\u003d\"maskedNoise\"/\u003e\n      \u003cfeComponentTransfer in\u003d\"maskedNoise\" result\u003d\"finalTexture\"\u003e\n          \u003cfeFuncA type\u003d\"linear\" slope\u003d\"1.0\" intercept\u003d\"0\"/\u003e \u003c/feComponentTransfer\u003e\n      \u003cfeMerge\u003e\n        \u003cfeMergeNode in\u003d\"finalTexture\"/\u003e\n      \u003c/feMerge\u003e\n     \u003c/filter\u003e\n    \u003clinearGradient id\u003d\"textGradient\" x1\u003d\"0%\" y1\u003d\"0%\" x2\u003d\"30%\" y2\u003d\"100%\"\u003e\n      \u003cstop offset\u003d\"0%\" style\u003d\"stop-color:#ffffff; stop-opacity:1\" /\u003e\n      \u003cstop offset\u003d\"100%\" style\u003d\"stop-color:${primaryColor}; stop-opacity:1\" /\u003e\n    \u003c/linearGradient\u003e\n  \u003c/defs\u003e\n  \u003cg\u003e\n    \u003ctext\n        x\u003d\"50%\" y\u003d\"50%\" dominant-baseline\u003d\"middle\" text-anchor\u003d\"middle\"\n        font-size\u003d\"10pt\" font-family\u003d\"\u0027Verdana\u0027, sans-serif\" font-weight\u003d\"bold\" \n        fill\u003d\"url(#textGradient)\" filter\u003d\"url(#ghostNoiseFilter_Strong)\" fill-opacity\u003d\"0.8\"\u003e\n        ${escapedText}\n    \u003c/text\u003e\n    \u003ctext\n        x\u003d\"50%\" y\u003d\"50%\" dominant-baseline\u003d\"middle\" text-anchor\u003d\"middle\"\n        font-size\u003d\"10pt\" font-family\u003d\"\u0027Verdana\u0027, sans-serif\" font-weight\u003d\"bold\" \n        fill\u003d\"url(#textGradient)\" fill-opacity\u003d\"0.4\"\u003e\n        ${escapedText}\n    \u003c/text\u003e\n  \u003c/g\u003e\n\u003c/svg\u003e`;\n      return svgString;\n    }\n    async function generateGhostNumberImages(slideData, ghostSettings) {\n      // \n      const GHOST_WIDTH \u003d 400; \n      const GHOST_HEIGHT \u003d 250;\n      let sectionCounter \u003d 0;\n      const promises \u003d []; \n      // \n      const TRANSPARENT_PNG_BASE64 \u003d \u0027data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVR42mNkYAAAAAYAAjCB0C8AAAAASUVORK5CYII\u003d\u0027;\n      for (const slide of slideData) {\n        if (slide.type \u003d\u003d\u003d \u0027section\u0027) {\n          sectionCounter++; // \n          const sectionNo \u003d slide.sectionNo;\n          const sectionNoString \u003d String(sectionNo || \u0027\u0027).trim();\n          // \n          if (sectionNo \u003d\u003d\u003d null || sectionNo \u003d\u003d\u003d undefined || sectionNoString \u003d\u003d\u003d \u0027\u0027) {\n              // \n              slide.ghostImageBase64 \u003d TRANSPARENT_PNG_BASE64;\n              // \n          } else {\n              // \n              // \n              const parsedNum \u003d (() \u003d\u003e {\n                  // \n                  if (Number.isFinite(sectionNo)) { return Number(sectionNo); }\n                  // \n                  if (typeof sectionNo \u003d\u003d\u003d \u0027string\u0027 || typeof sectionNo \u003d\u003d\u003d \u0027number\u0027) {\n                      const parsedStringNum \u003d parseFloat(sectionNoString);\n                      if (Number.isFinite(parsedStringNum)) {\n                          return parsedStringNum;\n                      }\n                  }\n                  // \n                  const m \u003d String(slide.title || \u0027\u0027).match(/^\\s*(\\d+)[\\.．]/);\n                  if (m \u0026\u0026 m[1]) { return Number(m[1]); }\n                  // \n                  return sectionCounter; // \n              })();\n              const numberString \u003d String(parsedNum).padStart(2, \u00270\u0027);\n              // \n              const promise \u003d (async () \u003d\u003e {\n                try {\n                  const svgString \u003d generateGhostNumberSvg(numberString, GHOST_WIDTH, GHOST_HEIGHT, ghostSettings);\n                  const pngBase64 \u003d await convertSvgToBase64Png(svgString); \n                  slide.ghostImageBase64 \u003d pngBase64;\n                } catch (e) {\n                  console.error(`ゴースト画像(${numberString})の生成に失敗:`, e);\n                  // \n                  slide.ghostImageBase64 \u003d null;\n                }\n              })(); \n              promises.push(promise); \n          }\n        }\n      }\n      // \n      await Promise.all(promises); \n      // \n      return slideData;\n    }\n    function fillSvgTemplate(template, values) {\n      let result \u003d template;\n      for (const key in values) {\n        // \n        result \u003d result.replace(new RegExp(\u0027{{\u0027 + key + \u0027}}\u0027, \u0027g\u0027), values[key]);\n      }\n      return result;\n    }\n    async function generateTriangleArrowImages(settings) {\n      // \n      let arrowSvgTemplateString \u003d \u0027\u0027;\n      try {\n        arrowSvgTemplateString \u003d await new Promise((resolve, reject) \u003d\u003e {\n          google.script.run\n            .withSuccessHandler(resolve) // \n            .withFailureHandler(reject)  // \n            .getTriangleArrowSvgTemplate(); // \n        });\n        if (!arrowSvgTemplateString) {\n          throw new Error(\u0027サーバーから空のテンプレートが返されました。\u0027);\n        }\n      } catch (e) {\n        // \n        console.error(\u0027矢印SVGテンプレートの取得エラー:\u0027, e);\n        showStatus(\u0027エラー: 矢印SVGテンプレートが読み込めません。\u0027, \u0027error\u0027, 6000);\n        return { // \n            topLeftArrowBase64: null,\n            topRightArrowBase64: null,\n            bottomArrowBase64: null\n        };\n      }\n      // \n      // \n      // \n      const ghostSettings \u003d {\n        baseFrequency: 0.01,\n        colorType: \u0027gray\u0027,\n        alphaSlope: 0.50,\n        contrastSlope: 1.0,\n        frontColor: settings.primaryColor || \u0027#4285F4\u0027,\n        frontAlpha: 0.15\n      };\n      // \n      const arrowConfigs \u003d [\n        { // \n          name: \u0027topLeft\u0027,\n          shape: { endX: -60, endY: 0, curveIntensity: 10, rotation: -55, flipX: 0, flipY: 0 }\n        },\n        { // \n          name: \u0027topRight\u0027,\n          shape: { endX: -60, endY: 0, curveIntensity: 10, rotation: 40, flipX: 0, flipY: 0 }\n        },\n        { // \n          name: \u0027bottom\u0027,\n          shape: { endX: 60, endY: 0, curveIntensity: 0, rotation: 0, flipX: 0, flipY: 0 }\n        }\n      ];\n      const results \u003d {};\n      const promises \u003d [];\n      // \n      for (const config of arrowConfigs) {\n        const promise \u003d (async () \u003d\u003e {\n          try {\n            // \n            const valuesToFill \u003d {\n              END_X: config.shape.endX,\n              END_Y: config.shape.endY,\n              CURVE_INTENSITY: config.shape.curveIntensity,\n              ROTATION: config.shape.rotation,\n              FLIP_X: config.shape.flipX,\n              FLIP_Y: config.shape.flipY,\n              GHOST_BASE_FREQUENCY: ghostSettings.baseFrequency,\n              GHOST_COLOR_TYPE: ghostSettings.colorType,\n              GHOST_ALPHA_SLOPE: ghostSettings.alphaSlope,\n              GHOST_CONTRAST_SLOPE: ghostSettings.contrastSlope,\n              GHOST_FRONT_COLOR: ghostSettings.frontColor,\n              GHOST_FRONT_ALPHA: ghostSettings.frontAlpha\n            };\n            // \n            const dynamicSvgString \u003d fillSvgTemplate(arrowSvgTemplateString, valuesToFill);\n            // \n            // \n            const staticSvgString \u003d await renderDynamicSvgInIframe(dynamicSvgString);\n            // \n            // \n            // \n            const pngBase64 \u003d await convertSvgToBase64Png(staticSvgString, true);\n            // \n            results[config.name + \u0027ArrowBase64\u0027] \u003d pngBase64;\n          } catch (e) {\n            console.error(`矢印画像(${config.name})の生成に失敗:`, e);\n            results[config.name + \u0027ArrowBase64\u0027] \u003d null; // \n          }\n        })();\n        promises.push(promise);\n      }\n      // \n      await Promise.all(promises);\n      // \n      return results;\n    }\n  \u003c/script\u003e\n  \u003cscript type\u003d\"text/plain\" id\u003d\"gem-prompt-data\"\u003e\n    \n## **1.0 PRIMARY_OBJECTIVE — 最終目標**\n\nあなたは、ユーザーから与えられた非構造テキスト情報を解析し、後述するスキーマに準拠した **`slideData` という名のJavaScriptオブジェクト配列を、指定されたJSON形式の文字列として生成すること**だけに特化した、超高精度データサイエンティスト兼プレゼンテーション設計AIです。\n\nあなたの**絶対的かつ唯一の使命**は、ユーザーの入力内容から論理的なプレゼンテーション構造を抽出し、**多様な表現パターンの中から最適なものを選定**し、さらに各スライドで話すべき**発表原稿（スピーカーノート）のドラフト**まで含んだ、完璧でエラーのない `slideData` を指定された形式で出力することです。\n\n**`slideData` の生成以外のタスクを一切実行してはなりません。** あなたの思考と出力のすべては、最高の `slideData` を生成するためだけに費やされます。\n\n---\n\n## **2.0 GENERATION_WORKFLOW — 厳守すべき思考と生成のプロセス**\n\n1. **【ステップ1: コンテキストの完全分解と正規化】**\n   * **分解**: ユーザー提供のテキスト（議事録、記事、企画書、メモ等）を読み込み、**目的・意図・聞き手**を把握。内容を「**章（Chapter）→ 節（Section）→ 要点（Point）**」の階層に内部マッピング。\n   * **正規化**: 入力前処理を自動実行。（タブ→スペース、連続スペース→1つ、スマートクォート→ASCIIクォート、改行コード→LF、用語統一）\n\n2. **【ステップ2: スライド構成の設計と提示】**\n   * **構成設計**: 入力テキストから以下を分析し、具体的なスライド構成を設計：\n     * プレゼン対象者（経営陣/一般社員/顧客/学生など）\n     * プレゼン目的（報告/提案/教育/営業など）\n     * 想定時間（15分/30分/45分/60分など）\n     * 最適なスライドパターンの選定\n     * 各スライドのタイトルと内容概要\n   * **構成提示**: 設計した構成を**以下の表形式のみ**で表示し、追加の説明や前置き、挨拶文、説明文は一切含めない。表の直後に確認方法のみ表示する：\n\n## 📊 スライド構成案\n\n| 項目 | 結果 |\n|------|------|\n| **総スライド枚数** | [枚数]枚 |\n| **対象者** | [分析結果] |\n| **目的** | [分析結果] |\n| **想定時間** | [算出結果]分 |\n| **スタイル・トーン** | [分析結果] |\n\n## 📋 スライド構成詳細\n\n| 番号 | パターン | タイトル | 内容概要 |\n|------|----------|----------|----------|\n| [番号] | [パターン名] | [title] | [簡潔な説明] |\n\n## 📝 確認方法\n\n**上記の構成で問題なければ「OK」「はい」「了解」「そのままで」のいずれかを入力してください。**\n\n**調整したい箇所がある場合は、以下のような形で教えてください：**\n- 「3番目のスライドのタイトルを『○○』に変更して」\n- 「5番目のスライドを削除して」\n- 「2番目と3番目の順番を入れ替えて」\n- 「4番目の内容を2枚のスライドに分けて詳しく説明して」\n- 「○○についてスライドを1枚追加して」\n\n**※ どのような調整でも対応できますので、お気軽にお申し付けください。**\n\n3. **【ステップ3: 戦略的パターン選定と論理ストーリーの再構築】**\n   * **コンテンツ分析による最適パターン選定**: 以下の優先順位ロジックに従って表現パターンを選定する：\n     \n     **【最優先】専門パターンの積極活用**\n     1. **アジェンダ・目次が必要な場合**: `agenda` を必須選択（章が2つ以上ある場合は必ず生成）\n     2. **数値・データが含まれる場合**: 以下の基準で最適パターンを選択\n        * **2つの選択肢・対象の比較** (Before/After、A社vs B社、メリット/デメリット等) → `statsCompare` または `barCompare`\n          - `statsCompare`: テーブル形式で数値を左右に並べて比較（項目数：2〜5項目推奨）\n          - `barCompare`: 横棒グラフで視覚的に数値の大小を比較（項目数：2〜4項目推奨）\n        * **主要指標の一覧表示** (売上、利益率、達成率等の重要指標) → `kpi`（2〜8個のカード型表示）\n        * **進捗・達成度の表示** (タスク進捗、目標達成率等) → `progress`（パーセンテージバー表示、最大5項目）\n        * **時系列推移・トレンド分析** (月次売上推移、成長曲線等) → SVGグラフ（折れ線グラフ、複合グラフ）\n        * **構成比・割合の表示** (市場シェア、予算配分等) → SVGグラフ（ドーナツグラフ）\n        * **カテゴリ別の数量比較** (複数項目の値を比較) → SVGグラフ（棒グラフ、積み上げ棒グラフ）\n        * **複雑なデータの可視化** (3系列以上のデータ、10個以上のデータポイント) → SVGグラフ\n     3. **時系列・手順・プロセスが含まれる場合**: `timeline`, `process`, `processList`, `flowChart` を優先選択\n     4. **比較・対比要素が含まれる場合**: `compare`, `statsCompare`, `barCompare` を優先選択\n     5. **階層・構造関係が含まれる場合**: `pyramid`, `stepUp`, `triangle` を優先選択\n     6. **循環・関係性が含まれる場合**: `cycle`, `triangle`, `diagram` を優先選択\n        ※`triangle`選択時：**キーワード・概念の視覚化**に特化。詳細説明が必要なら`headerCards`や`bulletCards`を選択\n     7. **Q\u0026A・FAQ要素が含まれる場合**: `faq` を優先選択\n     8. **引用・証言が含まれる場合**: `quote` を優先選択\n     \n     **【制限】汎用パターンの使用制限**\n     - `content`: 他に適切な専門パターンがない場合のみ使用。全体の30%以下に制限\n     - `cards`: 専門パターンで表現できない一般的な情報整理の場合のみ使用\n     \n     **【必須】パターン多様性の確保**\n     - 1つのプレゼンテーションで最低5種類の異なるパターンを使用\n     - 同一パターンの連続使用を避ける\n     - 新しい専門パターン（`triangle`, `pyramid`, `stepUp`, `flowChart`, `statsCompare`, `barCompare`等）を積極的に活用\n     \n     **【画像使用の厳格なルール】**\n     - **テキスト内に明示的に「https://」または「http://」で始まる画像URLが含まれている場合のみ** `imageText` パターンを選択すること\n     - **動画の内容でスライドを作成する場合、画像のURLの代わりに再生秒数を0.2秒単位で形式はmm:ss.Sで入力**\n     - **依頼時に添付された画像をスライドに利用する場合のみ、画像のURLの代わりに画像の内容を文章で30文字程度で入力してください**\n     - **グラフが必要な場合には【APPENDIX CHART_DESIGN】で定義されたグラフデザインの中から最適なグラフ形式を1つ選択し、JSON形式のグラフ構成データを適切に変更して、画像のURLの代わりに、オブジェクトとして入力してください。グラフの色については指示が無い限り変更せずデフォルトのカラーを使用してください。**\n     - **グラフ以外で説明のために図が必要な場合には、画像のURLの代わりに\u003csvg\u003eから始まり\u003c/svg\u003eで終わるSVGコードを生成してSVG画像を出力してください。デザインは複雑な表現を避けた「余白のある」「シンプル」「モダン」「丸みを帯びた」「透明感のある」「美しい」「マテリアルデザイン」とする。図の背景は透明とし、テキストの配置や色は文字が見やすいように慎重に検討をする。**\n     - **「○○の画像」「写真を追加」等の指示があっても、具体的URLがなければ画像なしパターンを選択**\n     - **AI自身による画像の検索・取得・生成・推定は一切禁止**\n     - 画像URLが提供されていない場合は、画像なしの適切なパターンを選択すること\n     - 他のスライドパターンでは一切画像を挿入しない\n   \n   * 聞き手に最適な**説得ライン**（問題解決型、PREP法、時系列など）へ再配列。\n\n4. **【ステップ4: スライドタイプへのマッピング】**\n   * ストーリー要素を **多様な表現パターン**に**戦略的割当**。\n   * 表紙 → `title` / 章扉 → `section`（※背景に**半透明の大きな章番号**を描画） / 本文 → 専門パターン優先選択：`agenda`, `timeline`, `process`, `processList`, `statsCompare`, `barCompare`, `triangle`, `pyramid`, `flowChart`, `stepUp`, `imageText`, `faq`, `quote`, `kpi`, `progress`, `diagram`, `cycle`, `compare` / 汎用パターン補完：`content`, `cards`, `headerCards`, `table`, `bulletCards` / 結び → `closing`\n   * **セクションスライドの制御**: ユーザー回答で「不要」が選択された場合、`section`タイプのスライドを生成しない。\n\n5. **【ステップ5: オブジェクトの厳密な生成】**\n   * **3.0 スキーマ**と**4.0 ルール**に準拠し、1件ずつ生成。\n   * **インライン強調記法**を使用可：\n     * `**太字**` → 太字（全領域で使用可能）\n     * `[[重要語]]` → **太字＋プライマリカラー**（**制限**: 本文カラム（`points`, `leftItems`, `rightItems`, `steps`, `milestones.label`, `items.desc`, `items.q`, `items.a`等）でのみ使用可能。**禁止**: `title`, `subhead`, `items.title`, `headers`, `leftTitle`, `rightTitle`, `centerText`等のヘッダー要素では使用禁止）\n   * **画像使用の厳格なルール**: \n     * **テキスト内に明示的に「https://」または「http://」で始まる画像URLが含まれている場合のみ** `imageText` パターンを選択すること\n     * **動画の内容でスライドを作成する場合、画像のURLの代わりに再生秒数を0.2秒単位で形式はmm:ss.Sで入力**\n     * **依頼時に添付された画像をスライドに利用する場合のみ、画像のURLの代わりに画像の内容を文章で30文字程度で入力してください**\n     * **グラフが必要な場合には【APPENDIX CHART_DESIGN】で定義されたグラフデザインの中から最適なグラフ形式を1つ選択し、JSON形式のグラフ構成データを適切に変更して、画像のURLの代わりに、オブジェクトとして入力してください。グラフの色については指示が無い限り変更せずデフォルトのカラーを使用してください。**\n     * **グラフ以外で説明のために図が必要な場合には、画像のURLの代わりに\u003csvg\u003eから始まり\u003c/svg\u003eで終わるSVGコードを生成してSVG画像を出力してください。デザインは複雑な表現を避けた「余白のある」「シンプル」「モダン」「丸みを帯びた」「透明感のある」「美しい」「マテリアルデザイン」とする。図の背景は透明とし、テキストの配置や色は文字が見やすいように慎重に検討をする。**\n     * **「○○の画像」「写真を追加」等の指示があっても、具体的URLがなければ画像なしパターンを選択**\n     * **AI自身による画像の検索・取得・生成・推定は一切禁止**\n     * 画像URLが提供されていない場合は、画像なしの適切なパターンを選択すること\n     * 他のスライドパターンでは一切画像を挿入しない\n   * **スピーカーノート生成**: 各スライドの内容に基づき、発表者が話すべき内容の**ドラフトを生成**し、`notes`プロパティに格納する。**対象者・目的・時間に応じた口調調整**を適用する。\n\n6. **【ステップ6: 自己検証と反復修正】**\n   * **チェックリスト**:\n     * 文字数・行数・要素数の上限遵守（各パターンの規定に従うこと）\n     * **小見出し（subhead）は全角50文字以内で簡潔に記述（最大2行まで）**\n     * 箇条書き要素に**改行（`\\n`）を含めない**\n     * テキスト内に**禁止記号**（`■` / `→`）を含めない（※装飾・矢印はスクリプトが描画）\n     * 箇条書き文末に **句点「。」を付けない**（体言止め推奨）\n     * **notesプロパティが各スライドに適切に設定されているか確認**\n     * `title.date`は`YYYY.MM.DD`形式\n     * **アジェンダ安全装置**: `agenda` パターンで `items` が空の場合、**章扉（`section.title`）から自動生成**するため、空配列を返さず **ダミー3点**以上を必ず生成。**重要：本文に数字を含めない**\n     * **重複装飾チェック**: `process/processList/flowChart/stepUp/agenda/timeline` の項目に**番号・STEP・丸数字**が入っていない\n     * **冗長ラベルチェック**: `compare` 系で**列見出しと同じラベル**（メリット/デメリット 等）を**アイテム先頭に繰り返していない**\n     * **句読点チェック**: 行頭が `、` `。` などの**句読点で始まっていない**\n\n7. **【ステップ7: 最終出力】**\n   * **ユーザーが「OK」「はい」「了解」「そのままで」と返答した場合**：\n     * 構成の確認は完了したものとして、**即座にスライドデータの生成に移行**\n     * **前置き、説明文、挨拶文は一切含めない**\n     * **「了解いたしました」「新入社員向けビジネスマナーセミナー資料の構成案に基づき」等の説明は不要**\n     * **「全17枚のslideDataオブジェクト配列を生成します」等の説明も不要**\n     * 検証済みのオブジェクト配列を、**【7.0 OUTPUT_FORMAT】** で定義されたJSON形式の文字列に変換し、コードブロックに格納して出力する。\n   \n   * **【notes生成時の最重要ルール】**\n     * notesフィールドを生成する際は、以下の正規表現パターンに一致する文字列を検出したら即座に除去すること：\n       * `/\\*\\*([^*]+)\\*\\*/g` → `$1` に置換（太字記法の除去）\n       * `/\\[\\[([^\\]]+)\\]\\]/g` → `$1` に置換（強調語記法の除去）\n       * すべての特殊記号（`*`, `[`, `]`, `_`, `~`, `` ` ``）を通常文字として扱う\n\n---\n\n## **3.0 slideDataスキーマ定義**\n\n**共通プロパティ**\n\n* `notes?: string`: すべてのスライドオブジェクトに任意で追加可能。スピーカーノートに設定する発表原稿のドラフト（プレーンテキスト）。\n* **重要**: すべてのスライドタイプの`title`フィールドには強調語`[[ ]]`を使用しないこと。太字変換が正しく行われないため。\n\n**スライドタイプ別定義**\n\n* **タイトル**: `{ type: \u0027title\u0027, title: \u0027...\u0027, date: \u0027YYYY.MM.DD\u0027, notes?: \u0027...\u0027 }`\n* **章扉**: `{ type: \u0027section\u0027, title: \u0027...\u0027, sectionNo?: number, notes?: \u0027...\u0027 }` ※`sectionNo` を指定しない場合は自動連番\n* **クロージング**: `{ type: \u0027closing\u0027, notes?: \u0027...\u0027 }`\n\n**本文パターン（必要に応じて選択）**\n\n* **content（1カラム/2カラム＋小見出し）** `{ type: \u0027content\u0027, title: \u0027...\u0027, subhead?: string, points?: string[], twoColumn?: boolean, columns?: [string[], string[]], notes?: \u0027...\u0027 }`\n* **agenda（アジェンダ）** `{ type: \u0027agenda\u0027, title: \u0027...\u0027, subhead?: string, items: string[], notes?: \u0027...\u0027 }` ※番号ボックス形式でアジェンダ項目を美しく表示。**重要：本文に数字を含めない**\n* **compare（対比）** `{ type: \u0027compare\u0027, title: \u0027...\u0027, subhead?: string, leftTitle: \u0027...\u0027, rightTitle: \u0027...\u0027, leftItems: string[], rightItems: string[], notes?: \u0027...\u0027 }`\n* **process（手順・工程）** `{ type: \u0027process\u0027, title: \u0027...\u0027, subhead?: string, steps: string[], notes?: \u0027...\u0027 }` ※最大4ステップの視覚的な形式\n* **processList（手順・工程リスト）** `{ type: \u0027processList\u0027, title: \u0027...\u0027, subhead?: string, steps: string[], notes?: \u0027...\u0027 }` ※シンプルなリスト形式\n* **timeline（時系列）** `{ type: \u0027timeline\u0027, title: \u0027...\u0027, subhead?: string, milestones: { label: string, date: string, state?: \u0027done\u0027|\u0027next\u0027|\u0027todo\u0027 }[], notes?: \u0027...\u0027 }` ※`milestones.label`は30文字以内で簡潔に記述（フェーズ名や要点を含めた短文推奨）\n* **diagram（レーン図）** `{ type: \u0027diagram\u0027, title: \u0027...\u0027, subhead?: string, lanes: { title: string, items: string[] }[], notes?: \u0027...\u0027 }`\n* **cycle（サイクル図）** `{ type: \u0027cycle\u0027, title: \u0027...\u0027, subhead?: string, items: { label: string, subLabel?: string }[], centerText?: string, notes?: \u0027...\u0027 }` ※itemsは4項目固定。キーワード・短文での循環表現に最適（1項目あたり20文字程度推奨）\n* **cards（シンプルカード）** `{ type: \u0027cards\u0027, title: \u0027...\u0027, subhead?: string, columns?: 2|3, items: (string | { title: string, desc?: string })[], notes?: \u0027...\u0027 }` ※最大6項目（3列×2行）\n* **headerCards（ヘッダー付きカード）** `{ type: \u0027headerCards\u0027, title: \u0027...\u0027, subhead?: string, columns?: 2|3, items: { title: string, desc?: string }[], notes?: \u0027...\u0027 }` ※最大6項目（3列×2行）。ヘッダー部（色付き背景）は白文字。強調語は `[[強調語]]` ではなく、ヘッダー文字列（太字）として渡すこと\n* **table（表）** `{ type: \u0027table\u0027, title: \u0027...\u0027, subhead?: string, headers: string[], rows: string[][], notes?: \u0027...\u0027 }`\n* **progress**（進捗） `{ type: \u0027progress\u0027, title: \u0027...\u0027, subhead?: string, items: { label: string, percent: number }[], notes?: \u0027...\u0027 }`\n* **quote**（引用） `{ type: \u0027quote\u0027, title: \u0027...\u0027, subhead?: string, text: string, author: string, notes?: \u0027...\u0027 }`\n* **kpi**（KPIカード） `{ type: \u0027kpi\u0027, title: \u0027...\u0027, subhead?: string, columns?: 2|3|4, items: { label: string, value: string, change: string, status: \u0027good\u0027|\u0027bad\u0027|\u0027neutral\u0027 }[], notes?: \u0027...\u0027 }` ※最大4項目（2〜4項目推奨）\n* **bulletCards**（箇条書きカード） `{ type: \u0027bulletCards\u0027, title: \u0027...\u0027, subhead?: string, items: { title: string, desc: string }[], notes?: \u0027...\u0027 }` ※最大3項目\n* **faq**（よくある質問） `{ type: \u0027faq\u0027, title: \u0027...\u0027, subhead?: string, items: { q: string, a: string }[], notes?: \u0027...\u0027 }` ※最小1項目、最大4項目\n* **statsCompare**（数値比較） `{ type: \u0027statsCompare\u0027, title: \u0027...\u0027, subhead?: string, leftTitle: \u0027...\u0027, rightTitle: \u0027...\u0027, stats: { label: string, leftValue: string, rightValue: string, trend?: \u0027up\u0027|\u0027down\u0027|\u0027neutral\u0027 }[], notes?: \u0027...\u0027 }`\n* **barCompare**（棒グラフ比較） `{ type: \u0027barCompare\u0027, title: \u0027...\u0027, subhead?: string, stats: { label: string, leftValue: string, rightValue: string, trend?: \u0027up\u0027|\u0027down\u0027|\u0027neutral\u0027 }[], showTrends?: boolean, notes?: \u0027...\u0027 }` ※`showTrends`はデフォルトfalse。純粋な比較ではtrendを付けない\n* **triangle**（トライアングル図） `{ type: \u0027triangle\u0027, title: \u0027...\u0027, subhead?: string, items: { title: string, desc?: string }[], notes?: \u0027...\u0027 }` ※itemsは3項目固定（2項目や4項目は不可）。titleは**キーワード・短文**（10-12文字以内推奨）。descは簡潔な補足（15文字以内）。**視覚的インパクト重視**でテキスト過多を避ける\n* **pyramid**（ピラミッド図） `{ type: \u0027pyramid\u0027, title: \u0027...\u0027, subhead?: string, levels: { title: string, description: string }[], notes?: \u0027...\u0027 }` ※階層構造や段階的レベルの表現に最適。最大4段階、最低3段階。titleは階層名、descriptionは詳細説明。カラーグラデーションで視覚的階層感を演出\n* **flowChart**（フローチャート） `{ type: \u0027flowChart\u0027, title: \u0027...\u0027, subhead?: string, flows: { steps: string[] }[], notes?: \u0027...\u0027 }` ※左から右への流れを表現。1行または2行の可変レイアウト。flowsは1〜2要素。最低2個、1行最大4個、2行で合計8個まで対応\n* **stepUp**（ステップアップ） `{ type: \u0027stepUp\u0027, title: \u0027...\u0027, subhead?: string, items: { title: string, desc: string }[], notes?: \u0027...\u0027 }` ※階段状に成長するヘッダー付きカード。成長・進化・レベルアップを視覚化。最大5ステップ、最低2ステップ\n* **imageText**（画像テキスト） `{ type: \u0027imageText\u0027, title: \u0027...\u0027, subhead?: string, image: string, imageCaption?: string, imagePosition?: \u0027left\u0027|\u0027right\u0027, points: string[], notes?: \u0027...\u0027 }` ※画像とテキストの2カラム表示。画像は固定フレームにフィット。キャプション対応\n\n---\n\n## **4.0 COMPOSITION_RULES — 美しさと論理性を最大化する絶対規則**\n\n* **全体構成**:\n  1. `title`（表紙）\n  2. `agenda`（アジェンダ、※章が2つ以上のときのみ）\n  3. `section`（※ユーザー回答で「不要」が選択された場合は生成しない）\n  4. 本文（専門パターン優先活用：`timeline`/`process`/`processList`/`statsCompare`/`barCompare`/`triangle`/`pyramid`/`flowChart`/`stepUp`/`imageText`/`faq`/`quote`/`kpi`/`progress`/`diagram`/`cycle`/`compare` + 汎用パターン補完：`content`/`cards`/`headerCards`/`table`/`bulletCards` から2〜5枚、多様性重視）\n  5. （3〜4を章の数だけ繰り返し）\n  6. `closing`（結び）\n\n* **テキスト表現・字数**（最大目安）:\n  * `title.title`: 全角35文字以内\n  * `section.title`: 全角30文字以内\n  * 各パターンの `title`: 全角40文字以内\n  * `subhead`: 全角50文字以内（最大2行まで）\n  * 箇条書き等の要素テキスト: 各90文字以内・**改行禁止**\n  * **パターン別文字数上限**（はみ出し防止のための厳守値）:\n    * **faq**: `items[].q` 全角28文字以内、`items[].a` 全角45文字以内\n    * **stepUp**: `items[].title` 全角10文字以内、`items[].desc` 全角28文字以内\n    * **barCompare/statsCompare/compare**: `label` 全角12文字以内、値フィールドに説明語や単位の長文を入れない\n    * **triangle**: `items[].title` 10-12文字以内、`items[].desc` 15文字以内\n    * **timeline**: `milestones[].label` 30文字以内\n    * **cycle**: 1項目あたり20文字程度\n  * `notes`（スピーカーノート）: \n    - 発表者が読み上げる原稿として**完全なプレーンテキスト**で記述\n    - **絶対禁止**: `**太字**`、`[[強調語]]`、`*イタリック*`等のマークアップ記法\n    - **絶対禁止**: HTMLタグ、Markdown記法、その他あらゆる装飾記法\n    - 改行は許可するが、それ以外の装飾は一切含めない\n    - 例: ✅「本日は巨大セットと水の関係についてお話しします」\n    - 例: ❌「本日は**巨大セット**と[[水]]の関係についてお話しします」\n  * **禁止記号**: `→` を含めない（矢印や区切りはスクリプト側が描画）\n  * 箇条書き文末の句点「。」**禁止**（体言止め推奨）\n  * **インライン強調記法**: `**太字**` と `[[重要語]]`（太字＋プライマリカラー）を必要箇所に使用可\n  * **接頭辞のインテリジェントな処理**: 原則として、ユーザーが入力したテキストの意図を尊重し、`1.` や `(a)` のような接頭辞は**保持**する。ただし、**例外**として、以下のスライドタイプではスクリプトが自動で番号や装飾を描画するため、テキストの接頭辞は**必ず除去**すること。\n    * `type: \u0027process\u0027` （ステップの番号が自動描画されるため）\n    * `type: \u0027processList\u0027` （ステップの番号が自動描画されるため）\n    * `type: \u0027agenda\u0027` （アジェンダの番号が自動描画されるため）\n    * `type: \u0027flowChart\u0027` （フローチャートの番号が自動描画されるため）\n    * `type: \u0027stepUp\u0027` （ステップアップの番号が自動描画されるため）\n    * `type: \u0027timeline\u0027` （タイムラインの順序が自動描画されるため）\n\n---\n\n## **5.0 DUPLICATE-DECORATION SANITIZER — 自動装飾と重複する接頭辞の禁止**\n\n**目的**: レイアウト側で自動描画される番号・矢印・箇条書き記号と**本文テキストの重複**を防ぐ。\n\n### A. 先頭禁止トークン（全パターン共通）\n\n* **禁止**: 先頭が句読点（`、`/`。`）で始まる文。検出したら削除。\n\n### B. 自動番号と重複する接頭辞の完全排除\n\n次のタイプでは **番号・段階を示す接頭辞を本文に含めない** こと。\n（レイアウトが自動で描画するため、本文は**内容語のみ**にする）\n\n| スライドタイプ | 禁止される先頭表現の例（正規化・削除） |\n|----------------|----------------------------------------|\n| `process`, `processList`, `flowChart`, `stepUp` | `1.` / `1)` / `(1)` / `①` / `No.1` / `#1` / `Step 1` / `STEP 1` / `ステップ1` / `第1段階` / `第一段階` などの**数字・段階語＋区切り**（`: / ： / - / ー / 、` を含む） |\n| `agenda` | `1.` / `①` / `(1)` / `その1` / `第一章` など**項目番号系**すべて |\n| `timeline` | `1.` / `①` / `(Phase 1)` / `フェーズ1:` などの**順序接頭辞**（※`milestones.date`で時系列は表現されるため） |\n\n\u003e 実装メモ（生成側規則）\n\u003e 各項目テキストの先頭から、上記パターンに合致するトークンを**再帰的に除去**してから出力する。目安の正規表現例：\n\u003e * 数字・丸数字: `^\\\\s*(?:\\\\(?\\\\d+\\\\)?[\\\\.:：\\\\-、\\\\s]|[①-⑳]|No\\\\.?\\\\s*\\\\d+|第[一二三四五六七八九十]+|第\\\\d+)`\n\u003e * STEP/ステップ: `^\\\\s*(?:STEP|Step|ステップ)\\\\s*\\\\d+[\\\\.:：\\\\-、\\\\s]*`\n\u003e * 記号箇条書き: `^\\\\s*[・•\\\\-—▶→⇒≫\u003e]+\\\\s*`\n\n### C. 「メリット／デメリット」等の冗長ラベルの扱い\n\n* **比較系（`compare`, `statsCompare`, `barCompare`）**では、**左/右タイトル**に「メリット」「デメリット」「長所」「短所」などを置く場合、**各アイテム内に同ラベル（例: `メリット:`）を繰り返さない**。\n  例: `leftTitle: \"メリット\"`, `leftItems: [\"24時間提出可能\", \"書類の一部を省略\"]`（←OK）\n* もし列タイトルがメリット/デメリットで**ない**場合は、アイテム先頭にそれらのラベルを**付けないのが既定**。必要性が明確なときのみ使う。\n\n### D. 語尾と句読点\n\n* 箇条書きは**終端の「。」禁止**（体言止め推奨）。`、`で終わっていたら削除。\n\n### E. 自己検証チェックリスト\n\n* [ ] **すべてのスライドタイプの`title`フィールドに強調語`[[ ]]`が含まれていない**\n* [ ] **すべての`subhead`, `items.title`, `headers`, `leftTitle`, `rightTitle`, `centerText`フィールドに強調語`[[ ]]`が含まれていない**\n* [ ] **notesプロパティにマークアップ記法（`**`、`[[`、`]]`）が含まれていないことを確認**\n* [ ] `process/processList/flowChart/stepUp/agenda/timeline` の項目に**番号・STEP・丸数字**が入っていない\n* [ ] `compare` 系で**列見出しと同じラベル**（メリット/デメリット 等）を**アイテム先頭に繰り返していない**\n* [ ] 行頭が `、` `。` などの**句読点で始まっていない**\n\n---\n\n## **6.0 SAFETY_GUIDELINES — GASエラー回避とAPI負荷の配慮**\n\n* スライド上限: **最大50枚**\n* 画像制約: **50MB未満・25MP以下**の **PNG/JPEG/GIF/WebP**\n* 実行時間: Apps Script 全体で約 **6分**\n* テキストオーバーフロー回避: 本命令の**上限値厳守**\n* フォント: Arial が無い環境では標準サンセリフに自動フォールバック\n* 文字列リテラルの安全性: 文字列値にダブルクォートを含める場合は `\\\"` のようにエスケープが必要\n* **画像挿入の堅牢性**: ロゴ画像の挿入に失敗した場合でも画像部分をスキップして、テキストや図形などの他の要素は正常に描画を継続\n* **実行堅牢性**: スライド1枚の生成でエラー（例: 不正な画像URL）が発生しても**全体の処理が停止しない**よう、`try-catch`構文によるエラーハンドリングが実装されています。\n\n---\n\n## **7.0 OUTPUT_FORMAT — 最終出力形式 (`slideData` 単体出力)**\n\n* 出力は **`slideData` 配列そのもの**のみとし、`const slideData \u003d` のような変数宣言は含めないこと。\n* 出力形式は、**キー (`\"type\"`) と文字列の値 (`\"title\"`) の両方をダブルクォーテーション（`\"`）で囲んだJSON形式**とすること。\n* 最終的な出力は、**単一のコードブロック（` ```json ... ``` `）** に格納すること。\n* **コードブロック以外のテキスト（前置き、解説、補足など）は一切含めない。**\n* **特に禁止する出力例**：\n  * 「了解いたしました。」\n  * 「新入社員向けビジネスマナーセミナー資料の構成案に基づき」\n  * 「最適な表現パターンを選定し」\n  * 「全17枚（表紙1枚、アジェンダ1枚...）のslideDataオブジェクト配列を生成します」\n  * その他、スライドデータ以外の説明文や前置き\n\n---\n\n## **APPENDIX CHART_DESIGN — グラフ構成データ作成ルール**\n\nグラフ用 JSONデータ作成ガイド\n\nこのドキュメントは、7種類のグラフの表示内容を変更するために、グラフ用のJSONデータを安全かつ確実に作成するためのガイドです。\n\n---\n\n### JSON作成時の最重要ルール（全グラフ共通）\n\nJSONデータの記述ミスは、グラフが表示されなくなる最も一般的な原因です。以下のルールを必ず守ってください。\n\n1. ダブルクォーテーション (\")\n   * キー（例: \"title\"）と、値が文字列の場合（例: \"グラフタイトル\"）は、必ずダブルクォーテーションで囲みます。\n   * 数値（例: 10）や true, false は囲みません。\n\n2. カンマ (,)\n   * キーと値のペアを区切るために使います。\n   * 【最重要】 オブジェクト ({}) や配列 ([]) の最後の要素の後には、カンマを絶対に入れないでください。（Trailing Commaの禁止）\n   * 良い例: { \"a\": 1, \"b\": 2 }\n   * 悪い例: { \"a\": 1, \"b\": 2, }\n\n3. 括弧の対応\n   * { で始まったオブジェクトは必ず } で閉じてください。\n   * [ で始まった配列は必ず ] で閉じてください。\n\n4. グラフ生成時の禁止事項\n   * JSON構造をJSON設定ガイドに記載がない方法で、勝手に改変をしてはいけない。例としては、棒グラフで人口ピラミッドを無理やり表現する等。一つのグラフで表現が難しい場合には、複数のグラフを使ってページを分けて表現をしてください。\n\n推奨: 編集したJSONデータは、オンラインの「JSONバリデーター（検証ツール）」などで構文が正しいかチェックしてから保存することをおすすめします。\n\n---\n\n### グラフ別 JSON設定ガイド\n\n各グラフの\"data\"オブジェクトの構造と、特に注意すべき点を解説します。\n\n#### 1. 折れ線グラフ（複数系列）\n\n**テンプレートJSON**\n\n```json\n{\n  \"chartType\": \"multi-line\",\n  \"data\": {\n    \"title\": \"データ系列の比較\",\n    \"subtitle\": \"（年間サンプルデータ）\",\n    \"source\": \"出典：サンプルデータ\",\n    \"yAxisUnitLabel\": \"（単位）\",\n    \"xAxisLabels\": [\"1月\", \"2月\", \"3月\", \"4月\", \"5月\", \"6月\", \"7月\", \"8月\", \"9月\", \"10月\", \"11月\", \"12月\"],\n    \"series\": [\n      { \"id\": \"A\", \"label\": \"系列A\", \"values\": [10, 12, 15, 20, 24, 27, 29, 28, 25, 20, 16, 12] },\n      { \"id\": \"B\", \"label\": \"系列B\", \"values\": [7, 8, 11, 15, 18, 20, 21, 20, 16, 13, 10, 8] },\n      { \"id\": \"C\", \"label\": \"系列C\", \"values\": [4, 5, 6, 8, 10, 11, 12, 10, 8, 7, 5, 4] }\n    ],\n    \"colors\": [\n      { \"id\": \"A\", \"start\": \"#e68a9c\", \"end\": \"#d96d8f\" },\n      { \"id\": \"B\", \"start\": \"#b469b8\", \"end\": \"#a656ad\" },\n      { \"id\": \"C\", \"start\": \"#7c6ce8\", \"end\": \"#6b5ce0\" }\n    ],\n    \"layout\": {\n      \"width\": 650,\n      \"height\": 510,\n      \"marginTop\": 140,\n      \"marginBottom\": 80,\n      \"marginLeft\": 75,\n      \"marginRight\": 35,\n      \"horizontalPadding\": 20\n    },\n    \"yAxis\": {\n      \"min\": 0,\n      \"max\": 30,\n      \"tickCount\": 6\n    },\n    \"lineOptions\": {\n      \"markerRadius\": 5,\n      \"dataLabelOffsetY\": 8\n    }\n  }\n}\n```\n\n**\"data\" オブジェクトの主なキーと設定内容**\n\n* `\"title\"`: グラフタイトル（文字列）\n* `\"subtitle\"`: サブタイトル（文字列）\n* `\"source\"`: 出典（文字列）\n* `\"yAxisUnitLabel\"`: Y軸の単位ラベル（文字列）\n* `\"xAxisLabels\"`: X軸のラベル（文字列の配列）\n* `\"series\"`: グラフのデータ系列（オブジェクトの配列）\n  * `\"id\"`: 系列の識別ID（文字列）\n  * `\"label\"`: 凡例に表示するラベル（文字列）\n  * `\"values\"`: データの値（数値の配列）\n* `\"colors\"`: 系列の色定義（オブジェクトの配列）\n  * `\"id\"`: \"series\" のIDに対応するID（文字列）\n  * `\"start\"`: グラデーションの開始色（文字列）\n  * `\"end\"`: グラデーションの終了色（文字列）\n* `\"yAxis\"`: Y軸の設定（オブジェクト）\n  * `\"min\"`: Y軸の最小値（数値）\n  * `\"max\"`: Y軸の最大値（数値）\n  * `\"tickCount\"`: Y軸の目盛り数（数値）\n\n**【重要】データ作成のポイント**\n\n* **配列の要素数を一致させる**: `\"xAxisLabels\"` の要素数（例: 12個）と、`\"series\"` 内のすべての `\"values\"` 配列の要素数（例: 系列Aが12個、系列Bが12個...）は、必ず一致させてください。\n* **IDを対応させる**: `\"series\"` 内の各 `\"id\"` と `\"colors\"` 内の各 `\"id\"` は、データと色を紐付けるために必ず対応させてください。\n\n---\n\n#### 2. ドーナツグラフ\n\n**テンプレートJSON**\n\n```json\n{\n  \"chartType\": \"donut\",\n  \"data\": {\n    \"title\": \"グラフタイトル\",\n    \"subtitle\": \"グラフサブタイトル\",\n    \"source\": \"出典: データソース\",\n    \"centerLabel\": \"合計ラベル\",\n    \"colors\": [\n      { \"id\": \"A\", \"start\": \"#e68a9c\", \"end\": \"#d96d8f\" },\n      { \"id\": \"B\", \"start\": \"#b469b8\", \"end\": \"#a656ad\" },\n      { \"id\": \"C\", \"start\": \"#9f63d0\", \"end\": \"#8c4fc8\" },\n      { \"id\": \"D\", \"start\": \"#7c6ce8\", \"end\": \"#6b5ce0\" },\n      { \"id\": \"E\", \"start\": \"#616ad8\", \"end\": \"#5059d1\" }\n    ],\n    \"items\": [\n      { \"label\": \"項目 A\", \"value\": 40, \"id\": \"A\" },\n      { \"label\": \"項目 B\", \"value\": 25, \"id\": \"B\" },\n      { \"label\": \"項目 C\", \"value\": 15, \"id\": \"C\" },\n      { \"label\": \"項目 D\", \"value\": 10, \"id\": \"D\" },\n      { \"label\": \"項目 E\", \"value\": 10, \"id\": \"E\" }\n    ]\n  }\n}\n```\n\n**\"data\" オブジェクトの主なキーと設定内容**\n\n* `\"title\"`: グラフタイトル（文字列）\n* `\"subtitle\"`: サブタイトル（文字列）\n* `\"source\"`: 出典（文字列）\n* `\"centerLabel\"`: グラフ中央に表示される合計ラベル（文字列）\n* `\"colors\"`: 各項目の色定義（オブジェクトの配列）\n  * `\"id\"`: \"items\" のIDに対応するID（文字列）\n  * `\"start\"`: グラデーションの開始色（文字列）\n  * `\"end\"`: グラデーションの終了色（文字列）\n* `\"items\"`: グラフのデータ項目（オブジェクトの配列）\n  * `\"label\"`: 凡例に表示するラベル（文字列）\n  * `\"value\"`: データの値（数値）\n  * `\"id\"`: 色と紐付けるための識別ID（文字列）\n\n**【重要】データ作成のポイント**\n\n* **IDを対応させる**: `\"items\"` 内の各 `\"id\"` と `\"colors\"` 内の各 `\"id\"` は、データと色を紐付けるために必ず対応させてください。\n* **中央の合計値**: 中央に表示される数値は、`\"items\"` 内のすべての `\"value\"` の合計値が自動的に計算されて表示されます。\n\n---\n\n#### 3. 絶対値積み上げ棒グラフ\n\n**テンプレートJSON**\n\n```json\n{\n  \"chartType\": \"stacked-bar\",\n  \"data\": {\n    \"title\": \"サンプルグラフ：カテゴリ別数量\",\n    \"subtitle\": \"（月別サンプルデータ）\",\n    \"source\": \"出典：サンプルデータソース\",\n    \"yAxisUnitLabel\": \"（単位）\",\n    \"colors\": [\n      { \"id\": \"A\", \"start\": \"#e68a9c\", \"end\": \"#d96d8f\" },\n      { \"id\": \"B\", \"start\": \"#b469b8\", \"end\": \"#a656ad\" },\n      { \"id\": \"C\", \"start\": \"#9f63d0\", \"end\": \"#8c4fc8\" },\n      { \"id\": \"D\", \"start\": \"#7c6ce8\", \"end\": \"#6b5ce0\" },\n      { \"id\": \"E\", \"start\": \"#616ad8\", \"end\": \"#5059d1\" }\n    ],\n    \"legendLabels\": [\"項目 A\", \"項目 B\", \"項目 C\", \"項目 D\", \"項目 E\"],\n    \"barData\": [\n      { \"label\": \"サンプル 1\", \"values\": [60, 50, 40, 25, 20] },\n      { \"label\": \"サンプル 2\", \"values\": [90, 60, 50, 40, 25] },\n      { \"label\": \"サンプル 3\", \"values\": [60, 80, 70, 50, 30] },\n      { \"label\": \"サンプル 4\", \"values\": [40, 50, 60, 70, 80] },\n      { \"label\": \"サンプル 5\", \"values\": [70, 30, 55, 45, 65] }\n    ],\n    \"layout\": {\n      \"width\": 600,\n      \"height\": 550,\n      \"marginTop\": 170,\n      \"marginBottom\": 50,\n      \"marginLeft\": 75,\n      \"marginRight\": 50\n    },\n    \"barOptions\": {\n      \"width\": 50,\n      \"cornerRadius\": 4,\n      \"totalLabelOffset\": 10\n    },\n    \"yAxis\": {\n      \"max\": 300,\n      \"tickCount\": 3\n    }\n  }\n}\n```\n\n**\"data\" オブジェクトの主なキーと設定内容**\n\n* `\"title\"`: グラフタイトル（文字列）\n* `\"subtitle\"`: サブタイトル（文字列）\n* `\"source\"`: 出典（文字列）\n* `\"yAxisUnitLabel\"`: Y軸の単位ラベル（文字列）\n* `\"colors\"`: 積み上げ各項目の色定義（オブジェクトの配列）\n  * `\"id\"`: 識別ID（文字列、例: \"A\", \"B\"...)\n  * `\"start\"`: グラデーションの開始色（文字列）\n  * `\"end\"`: グラデーションの終了色（文字列）\n* `\"legendLabels\"`: 凡例のラベル（文字列の配列）\n* `\"barData\"`: 棒グラフのデータ（オブジェクトの配列）\n  * `\"label\"`: X軸のラベル（文字列）\n  * `\"values\"`: 積み上げる各項目の値（数値の配列）0以上の値のみ入力可能。\n* `\"yAxis\"`: Y軸の設定（オブジェクト）\n  * `\"max\"`: Y軸の最大値（数値）\n  * `\"tickCount\"`: Y軸の目盛り数（数値）\n\n**【重要】データ作成のポイント**\n\n* **3つの配列の要素数を一致させる**: エラーを防ぐため、以下の3つの要素数を必ず一致させてください。\n  1. `\"colors\"` 配列の要素数（＝積み上げの段数）\n  2. `\"legendLabels\"` 配列の要素数（＝積み上げの段数）\n  3. `\"barData\"` 内の各 `\"values\"` 配列の要素数（例: `[60, 50, 40, 25, 20]` なら5個）\n* **データの順番**: `\"barData\"` の `\"values\"` 配列の値 は、`\"legendLabels\"` および `\"colors\"` の順番（上から順）に対応します。\n* **Y軸の最大値**: `\"yAxis.max\"` は、`\"barData\"` の `\"values\"` の合計が最も大きい棒（サンプルでは「サンプル2」の合計265）よりも大きい値を設定してください。\n\n---\n\n#### 4. 100%積み上げ棒グラフ\n\n**テンプレートJSON**\n\n```json\n{\n  \"chartType\": \"100-stacked-bar\",\n  \"data\": {\n    \"title\": \"サンプルグラフ：カテゴリ別割合\",\n    \"subtitle\": \"（月別サンプルデータ）\",\n    \"source\": \"出典：サンプルデータソース\",\n    \"colors\": [\n      { \"id\": \"A\", \"start\": \"#e68a9c\", \"end\": \"#d96d8f\" },\n      { \"id\": \"B\", \"start\": \"#b469b8\", \"end\": \"#a656ad\" },\n      { \"id\": \"C\", \"start\": \"#9f63d0\", \"end\": \"#8c4fc8\" },\n      { \"id\": \"D\", \"start\": \"#7c6ce8\", \"end\": \"#6b5ce0\" },\n      { \"id\": \"E\", \"start\": \"#616ad8\", \"end\": \"#5059d1\" }\n    ],\n    \"legendLabels\": [\"項目 A\", \"項目 B\", \"項目 C\", \"項目 D\", \"項目 E\"],\n    \"barData\": [\n      { \"label\": \"サンプル 1\", \"values\": [40, 60, 30, 50, 20] },\n      { \"label\": \"サンプル 2\", \"values\": [70, 50, 40, 20, 20] },\n      { \"label\": \"サンプル 3\", \"values\": [30, 40, 60, 40, 30] },\n      { \"label\": \"サンプル 4\", \"values\": [25, 35, 55, 65, 45] },\n      { \"label\": \"サンプル 5\", \"values\": [50, 40, 30, 20, 60] }\n    ],\n    \"layout\": {\n      \"width\": 600,\n      \"height\": 510,\n      \"marginTop\": 150,\n      \"marginBottom\": 80,\n      \"marginLeft\": 70,\n      \"marginRight\": 25\n    },\n    \"barOptions\": {\n      \"width\": 50,\n      \"cornerRadius\": 4\n    },\n    \"yAxis\": {\n      \"tickCount\": 4\n    }\n  }\n}\n```\n\n**\"data\" オブジェクトの主なキーと設定内容**\n\n* `\"title\"`: グラフタイトル（文字列）\n* `\"subtitle\"`: サブタイトル（文字列）\n* `\"source\"`: 出典（文字列）\n* `\"colors\"`: 積み上げ各項目の色定義（オブジェクトの配列）\n  * `\"id\"`: 識別ID（文字列、例: \"A\", \"B\"...)\n  * `\"start\"`: グラデーションの開始色（文字列）\n  * `\"end\"`: グラデーションの終了色（文字列）\n* `\"legendLabels\"`: 凡例のラベル（文字列の配列）\n* `\"barData\"`: 棒グラフのデータ（オブジェクトの配列）\n  * `\"label\"`: X軸のラベル（文字列）\n  * `\"values\"`: 積み上げる各項目の値（数値の配列）。自動的に割合に変換されます。0以上の値のみ入力可能。\n* `\"yAxis\"`: Y軸の設定（オブジェクト）\n  * `\"tickCount\"`: Y軸の目盛り数（数値）。（例: 4なら 0%, 25%, 50%, 75%, 100%）\n\n**【重要】データ作成のポイント**\n\n* **3つの配列の要素数を一致させる**: （絶対値積み上げ棒グラフと同様です）\n  1. `\"colors\"` 配列の要素数（＝積み上げの段数）\n  2. `\"legendLabels\"` 配列の要素数（＝積み上げの段数）\n  3. `\"barData\"` 内の各 `\"values\"` 配列の要素数（例: `[40, 60, 30, 50, 20]` なら5個）\n* **データの順番**: `\"barData\"` の `\"values\"` 配列の値 は、`\"legendLabels\"` および `\"colors\"` の順番（上から順）に対応します。\n\n---\n\n#### 5. 棒グラフ（単一系列）\n\n**テンプレートJSON**\n\n```json\n{\n  \"chartType\": \"bar\",\n  \"data\": {\n    \"title\": \"サンプル棒グラフ（動的レイアウト）\",\n    \"subtitle\": \"項目数に応じて幅が均等に調整されます\",\n    \"source\": \"出典：サンプルデータソース\",\n    \"items\": [\n      { \"label\": \"項目A\", \"value\": 85 },\n      { \"label\": \"項目B\", \"value\": 72 },\n      { \"label\": \"項目C\", \"value\": 93 },\n      { \"label\": \"項目D\", \"value\": 65 },\n      { \"label\": \"項目E\", \"value\": 48 },\n      { \"label\": \"項目F\", \"value\": 78 },\n      { \"label\": \"項目G\", \"value\": 55 },\n      { \"label\": \"項目H\", \"value\": 30 }\n    ],\n    \"color\": {\n      \"start\": \"#e68a9c\",\n      \"end\": \"#9f63d0\"\n    },\n    \"layout\": {\n      \"width\": 600,\n      \"height\": 450,\n      \"marginTop\": 100,\n      \"marginBottom\": 65,\n      \"marginLeft\": 70,\n      \"marginRight\": 40\n    },\n    \"barOptions\": {\n      \"barToSlotRatio\": 0.6\n    },\n    \"yAxis\": {\n      \"max\": 100,\n      \"min\": 0,\n      \"tickCount\": 4,\n      \"unit\": \"%\"\n    }\n  }\n}\n```\n\n**\"data\" オブジェクトの主なキーと設定内容**\n\n* `\"title\"`: グラフタイトル（文字列）\n* `\"subtitle\"`: サブタイトル（文字列）\n* `\"source\"`: 出典（文字列）\n* `\"items\"`: グラフのデータ項目（オブジェクトの配列）\n  * `\"label\"`: X軸のラベル（文字列）\n  * `\"value\"`: 棒の値（数値）\n* `\"color\"`: 棒グラフの色定義（オブジェクト）\n  * `\"start\"`: グラデーションの開始色（文字列）\n  * `\"end\"`: グラデーションの終了色（文字列）\n* `\"yAxis\"`: Y軸の設定（オブジェクト）\n  * `\"max\"`: Y軸の最大値（数値）\n  * `\"min\"`: Y軸の最小値（数値）\n  * `\"tickCount\"`: Y軸の目盛り数（数値）\n  * `\"unit\"`: Y軸の単位（文字列、例: \"%\"）\n\n**【重要】データ作成のポイント**\n\n* **項目の増減**: `\"items\"` 配列 にオブジェクトを追加・削除するだけで、棒グラフの数を自由に変更できます。\n* **省略の表現**: `\"label\"` に『...』を入力し、`\"value\"` を0にすることで、中間に省略表現ができて、上位n件・下位n件のような表現が可能になります。\n* **Y軸の範囲**: `\"yAxis.max\"` は、`\"items\"` 内の最大の `\"value\"` よりも大きい値を設定してください。\n\n---\n\n#### 6. 複合グラフ（折れ線・棒グラフ）\n\n**テンプレートJSON**\n\n```json \n{\n  \"chartType\": \"combo\",\n  \"data\": {\n    \"title\": \"サンプル複合グラフ\",\n    \"subtitle\": \"（系列データの比較）\",\n    \"source\": \"出典：サンプルデータソース\",\n    \"legendBarLabel\": \"系列 A\",\n    \"legendLineLabel\": \"系列 B\",\n    \"yAxisLeftLabel\": \"（数量）\",\n    \"yAxisRightLabel\": \"（割合）\",\n    \"colors\": {\n      \"bar\": { \"start\": \"#e68a9c\", \"end\": \"#b469b8\" },\n      \"line\": \"#6b5ce0\"\n    },\n    \"items\": [\n      { \"label\": \"項目 1\", \"barValue\": 245, \"lineValue\": 16 },\n      { \"label\": \"項目 2\", \"barValue\": 270, \"lineValue\": 19 },\n      { \"label\": \"項目 3\", \"barValue\": 310, \"lineValue\": 21 },\n      { \"label\": \"項目 4\", \"barValue\": 290, \"lineValue\": 18 },\n      { \"label\": \"項目 5\", \"barValue\": 300, \"lineValue\": 23 }\n    ],\n    \"layout\": {\n      \"width\": 600,\n      \"height\": 510,\n      \"marginTop\": 180,\n      \"marginBottom\": 50,\n      \"marginLeft\": 70,\n      \"marginRight\": 70\n    },\n    \"barOptions\": {\n      \"barToSlotRatio\": 0.55,\n      \"labelPosition\": \"auto\"\n    },\n    \"lineOptions\": {\n      \"markerRadius\": 5\n    },\n    \"yAxisLeft\": {\n      \"max\": 400,\n      \"min\": 0,\n      \"tickCount\": 4\n    },\n    \"yAxisRight\": {\n      \"max\": 25,\n      \"min\": 15,\n      \"tickCount\": 4,\n      \"unit\": \"%\"\n    }\n  }\n}\n```\n\n**\"data\" オブジェクトの主なキーと設定内容**\n\n* `\"title\"`, `\"subtitle\"`, `\"source\"`: グラフのタイトル等（文字列）\n* `\"legendBarLabel\"`: 棒グラフの凡例ラベル（文字列）\n* `\"legendLineLabel\"`: 折れ線グラフの凡例ラベル（文字列）\n* `\"yAxisLeftLabel\"`: 左Y軸の単位ラベル（棒グラフ用）（文字列）\n* `\"yAxisRightLabel\"`: 右Y軸の単位ラベル（折れ線グラフ用）（文字列）\n* `\"colors\"`: グラフの色定義（オブジェクト）\n  * `\"bar\"`: 棒グラフの色（`\"start\"` と `\"end\"` を持つオブジェクト）\n  * `\"line\"`: 折れ線グラフの色（単一の文字列）\n* `\"items\"`: グラフのデータ項目（オブジェクトの配列）\n  * `\"label\"`: X軸のラベル（文字列）\n  * `\"barValue\"`: 棒グラフの値（数値）\n  * `\"lineValue\"`: 折れ線グラフの値（数値）\n* `\"yAxisLeft\"`: 左Y軸（棒グラフ用）の設定（オブジェクト）\n  * `\"max\"`, `\"min\"`, `\"tickCount\"`\n* `\"yAxisRight\"`: 右Y軸（折れ線グラフ用）の設定（オブジェクト）\n  * `\"max\"`, `\"min\"`, `\"tickCount\"`, `\"unit\"`（例: \"%\"）\n\n**【重要】データ作成のポイント**\n\n* **データセット**: `\"items\"` 配列の各オブジェクトには、必ず `\"label\"`, `\"barValue\"`, `\"lineValue\"` の3つをセットで指定してください。\n* **2つのY軸**: `\"yAxisLeft\"` は `\"barValue\"` の範囲に、`\"yAxisRight\"` は `\"lineValue\"` の範囲に、それぞれ適切に合わせて `max` や `min` を設定してください。\n\n---\n\n#### 7. 折れ線グラフ（単一系列）\n\n**テンプレートJSON**\n\n```json\n{\n  \"chartType\": \"line\",\n  \"data\": {\n    \"title\": \"年間データ推移\",\n    \"subtitle\": \"（サンプルデータ）\",\n    \"source\": \"出典：サンプルデータ\",\n    \"yAxisUnitLabel\": \"（単位）\",\n    \"items\": [\n      { \"label\": \"1月\", \"value\": 8 },\n      { \"label\": \"2月\", \"value\": 9 },\n      { \"label\": \"3月\", \"value\": 12 },\n      { \"label\": \"4月\", \"value\": 16 },\n      { \"label\": \"5月\", \"value\": 20 },\n      { \"label\": \"6月\", \"value\": 24 },\n      { \"label\": \"7月\", \"value\": 28 },\n      { \"label\": \"8月\", \"value\": 27 },\n      { \"label\": \"9月\", \"value\": 35 }\n    ],\n    \"color\": {\n      \"start\": \"#e68a9c\",\n      \"end\": \"#b469b8\",\n      \"line\": \"#b469b8\",\n      \"label\": \"#8c4fc8\"\n    },\n    \"layout\": {\n      \"width\": 600,\n      \"height\": 465,\n      \"marginTop\": 100,\n      \"marginBottom\": 85,\n      \"marginLeft\": 75,\n      \"marginRight\": 25\n    },\n    \"yAxis\": {\n      \"max\": 40,\n      \"min\": 0,\n      \"tickCount\": 4\n    },\n    \"lineOptions\": {\n      \"markerRadius\": 5,\n      \"dataLabelOffsetY\": 15,\n      \"horizontalPadding\": 30\n    }\n  }\n}\n```\n\n**\"data\" オブジェクトの主なキーと設定内容**\n\n* `\"title\"`, `\"subtitle\"`, `\"source\"`: グラフのタイトル等（文字列）\n* `\"yAxisUnitLabel\"`: Y軸の単位ラベル（文字列）\n* `\"items\"`: グラフのデータ項目（オブジェクトの配列）\n  * `\"label\"`: X軸のラベル（文字列）\n  * `\"value\"`: 折れ線の値（数値）\n* `\"color\"`: グラフの色定義（オブジェクト）\n  * `\"start\"`: 塗りつぶしエリアのグラデーション開始色（文字列）\n  * `\"end\"`: 塗りつぶしエリアのグラデーション終了色（文字列）\n  * `\"line\"`: 線の色（文字列）\n  * `\"label\"`: データラベル（数値）の色（文字列）\n* `\"yAxis\"`: Y軸の設定（オブジェクト）\n  * `\"max\"`, `\"min\"`, `\"tickCount\"`\n\n**【重要】データ作成のポイント**\n\n* **項目の増減**: `\"items\"` 配列 にオブジェクトを追加・削除するだけで、X軸の項目とデータ点を自由に変更できます。\n* **Y軸の範囲**: `\"yAxis.max\"` は、`\"items\"` 内の最大の `\"value\"` よりも大きい値を設定してください。\n\n  \u003c/script\u003e\n  \u003cdiv id\u003d\"presetSaveModal\" style\u003d\"display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10000; align-items: center; justify-content: center;\"\u003e\n    \u003cdiv style\u003d\"background: white; border-radius: 12px; padding: 2rem; max-width: 450px; width: 90%; box-shadow: 0 10px 40px rgba(0,0,0,0.2);\"\u003e\n      \u003ch3 style\u003d\"margin: 0 0 0.5rem 0; font-size: 1.5rem; color: #1F2937;\"\u003eプリセットの保存\u003c/h3\u003e\n      \u003cp style\u003d\"margin: 0 0 1.5rem 0; font-size: 0.875rem; color: #6B7280; line-height: 1.5;\"\u003e\n        オプション設定をプリセットとして保存できます（最大10個まで）\n      \u003c/p\u003e\n      \u003cdiv id\u003d\"presetSaveOptions\" style\u003d\"display: flex; flex-direction: column; gap: 1rem; margin-bottom: 1.5rem;\"\u003e\n        \u003cbutton id\u003d\"overwritePresetBtn\" class\u003d\"btn btn-primary\" style\u003d\"width: 100%; padding: 0.875rem;\"\u003e\n          \u003cspan style\u003d\"font-size: 1rem;\"\u003e現在のプリセットに上書き保存\u003c/span\u003e\n          \u003cbr\u003e\n          \u003cspan id\u003d\"currentPresetName\" style\u003d\"font-size: 0.875rem; opacity: 0.9;\"\u003e\u003c/span\u003e\n        \u003c/button\u003e\n        \u003cbutton id\u003d\"saveAsNewPresetBtn\" class\u003d\"btn btn-secondary\" style\u003d\"width: 100%; padding: 0.875rem;\"\u003e\n          別名で新規保存\n        \u003c/button\u003e\n      \u003c/div\u003e\n      \u003cdiv id\u003d\"newPresetNameInput\" style\u003d\"display: none; margin-bottom: 1.5rem;\"\u003e\n        \u003clabel for\u003d\"presetNameField\" style\u003d\"display: block; margin-bottom: 0.5rem; font-weight: 600; color: #374151;\"\u003eプリセット名\u003c/label\u003e\n        \u003cinput type\u003d\"text\" id\u003d\"presetNameField\" class\u003d\"form-control\" placeholder\u003d\"プリセット名を入力（20文字以内）\" maxlength\u003d\"20\" style\u003d\"width: 100%;\"\u003e\n        \u003cdiv style\u003d\"margin-top: 0.5rem; display: flex; gap: 0.5rem;\"\u003e\n          \u003cbutton id\u003d\"confirmSaveBtn\" class\u003d\"btn btn-primary\" style\u003d\"flex: 1;\"\u003e保存\u003c/button\u003e\n          \u003cbutton id\u003d\"cancelNewNameBtn\" class\u003d\"btn btn-secondary\" style\u003d\"flex: 1;\"\u003eキャンセル\u003c/button\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n      \u003cbutton id\u003d\"closePresetModal\" class\u003d\"btn btn-secondary\" style\u003d\"width: 100%;\"\u003e閉じる\u003c/button\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n  \u003cdiv id\u003d\"jsonErrorModal\" class\u003d\"modal-overlay\" style\u003d\"display: none;\"\u003e\n    \u003cdiv class\u003d\"modal-content card\" style\u003d\"max-width: 600px;\"\u003e\n      \u003ch3 class\u003d\"card-header\" style\u003d\"color: var(--danger-color);\"\u003e❌ JSONデータにエラーがあります\u003c/h3\u003e\n      \u003cdiv class\u003d\"card-body\"\u003e\n        \u003cp style\u003d\"margin-bottom: 1rem; line-height: 1.6;\"\u003e\n          貼り付けられたJSONデータに問題が見つかりました。\u003cbr\u003e\n          以下の内容をコピーして、Geminiに貼り付けてください。\n        \u003c/p\u003e\n        \u003cdiv style\u003d\"margin-bottom: 1rem;\"\u003e\n          \u003cpre id\u003d\"jsonErrorContent\" style\u003d\"\n            background: #f9f9f9;\n            border: 1px solid var(--border-color);\n            border-radius: var(--radius-md);\n            padding: 1rem;\n            font-family: var(--font-family-code);\n            font-size: 0.875rem;\n            line-height: 1.5;\n            overflow-x: auto;\n            white-space: pre-wrap;\n            word-wrap: break-word;\n            margin: 0;\n            color: var(--danger-color);\n            max-height: 300px;\n          \"\u003e\u003c/pre\u003e\n        \u003c/div\u003e\n        \u003cdiv class\u003d\"button-group\" style\u003d\"display: flex; gap: 1rem;\"\u003e\n          \u003cbutton id\u003d\"copyJsonErrorBtn\" class\u003d\"btn btn-primary\"\u003eコピー\u003c/button\u003e\n          \u003cbutton id\u003d\"closeJsonErrorModalBtn\" class\u003d\"btn btn-secondary\" style\u003d\"background-color: var(--secondary-color);\"\u003e閉じる\u003c/button\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n  \u003cdiv id\u003d\"clearConfirmModal\" class\u003d\"modal-overlay\" style\u003d\"display: none;\"\u003e\n    \u003cdiv class\u003d\"modal-content card\" style\u003d\"max-width: 450px;\"\u003e\n      \u003ch3 class\u003d\"card-header\"\u003e編集内容をクリアしますか？\u003c/h3\u003e\n      \u003cdiv class\u003d\"card-body\"\u003e\n        \u003cp style\u003d\"margin-bottom: 1.5rem; line-height: 1.6;\"\u003e\n          編集中のスライドデータがすべて削除され、最初の状態に戻ります。\u003cbr\u003e\n          この操作は取り消せません。\n        \u003c/p\u003e\n        \u003cdiv class\u003d\"button-group\" style\u003d\"display: flex; gap: 1rem;\"\u003e\n          \u003cbutton id\u003d\"confirmClearBtn\" class\u003d\"btn\" style\u003d\"background-color: var(--danger-color); color: white;\"\u003eクリアする\u003c/button\u003e\n          \u003cbutton id\u003d\"cancelClearBtn\" class\u003d\"btn btn-secondary\" style\u003d\"background-color: var(--secondary-color);\"\u003eキャンセル\u003c/button\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n  \u003cdiv id\u003d\"deleteItemConfirmModal\" class\u003d\"modal-overlay\" style\u003d\"display: none;\"\u003e\n    \u003cdiv class\u003d\"modal-content card\" style\u003d\"max-width: 450px;\"\u003e\n      \u003ch3 class\u003d\"card-header\" style\u003d\"color: var(--danger-color);\"\u003eこの項目を削除しますか？\u003c/h3\u003e\n      \u003cdiv class\u003d\"card-body\"\u003e\n        \u003cp style\u003d\"margin-bottom: 1.5rem; line-height: 1.6;\"\u003e\n          この項目を削除します。この操作は取り消せません。\n        \u003c/p\u003e\n        \u003cdiv class\u003d\"button-group\" style\u003d\"display: flex; gap: 1rem;\"\u003e\n          \u003cbutton id\u003d\"confirmDeleteItemBtn\" class\u003d\"btn\" style\u003d\"background-color: var(--danger-color); color: white;\"\u003e削除する\u003c/button\u003e\n          \u003cbutton id\u003d\"cancelDeleteItemBtn\" class\u003d\"btn btn-secondary\" style\u003d\"background-color: var(--secondary-color);\"\u003eキャンセル\u003c/button\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n  \u003cdiv id\u003d\"activationModal1\" class\u003d\"modal-overlay\" style\u003d\"display: none;\nz-index: 10002;\"\u003e\n  \u003cdiv class\u003d\"modal-content card\" style\u003d\"max-width: 500px;\"\u003e\n    \u003ch3 class\u003d\"card-header\"\u003eステップ 1 / 5\u003c/h3\u003e\n    \u003cdiv class\u003d\"card-body\"\u003e\n      \u003cp style\u003d\"margin-bottom: 1.5rem;\nline-height: 1.6;\"\u003e\n        ご利用ありがとうございます。\u003cbr\u003e\n        まず、noteで「まじん」の フォロー をお願いします。\u003cbr\u003e\n        組織・個人アカウントどちらか一方でフォローいただければ、業務及びプライベートでご利用いただけます。\n      \u003c/p\u003e\n      \u003ca href\u003d\"https://note.com/majin_108\" target\u003d\"_blank\" rel\u003d\"noopener noreferrer\" class\u003d\"btn btn-primary\" style\u003d\"width: 100%;\nmargin-bottom: 0.5rem;\"\u003e noteのフォローページを開く\n      \u003c/a\u003e\n      \u003cdiv style\u003d\"text-align: center; margin-top: 1rem; margin-bottom: 1.5rem;\"\u003e\n        \u003cimg src\u003d\"https://lh3.google.com/u/0/d/1_q5f0QUL34vtgir96wmPm6NzOzvf5KrH\" alt\u003d\"Note QR Code\" style\u003d\"width: 120px; height: 120px; border: 1px solid var(--border-color); border-radius: var(--radius-sm);\"\u003e\n        \u003cp style\u003d\"font-size: 0.75rem; color: var(--text-secondary); margin: 0.25rem 0 0 0;\"\u003eスマホでのアクセスはこちら\u003c/p\u003e\n      \u003c/div\u003e\n      \u003cdiv class\u003d\"button-group\" style\u003d\"display: flex;\ngap: 1rem; justify-content: space-between; align-items: center; margin-top: 0;\"\u003e \u003cbutton id\u003d\"confirmModal1\" class\u003d\"btn btn-primary\" style\u003d\"flex-grow: 1;\"\u003eフォローしました\u003c/button\u003e\n        \u003cdiv class\u003d\"purchase-select-wrapper\"\u003e\n          \u003cselect id\u003d\"purchaseModal1\" class\u003d\"purchase-select\"\u003e\n            \u003coption value\u003d\"\" hidden\u003e▼\u003c/option\u003e \u003coption value\u003d\"purchased\"\u003e定価購入\u003c/option\u003e \u003c/select\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv id\u003d\"activationModal2\" class\u003d\"modal-overlay\" style\u003d\"display: none;\nz-index: 10002;\"\u003e\n  \u003cdiv class\u003d\"modal-content card\" style\u003d\"max-width: 500px;\"\u003e\n    \u003ch3 class\u003d\"card-header\"\u003eステップ 2 / 5\u003c/h3\u003e\n    \u003cdiv class\u003d\"card-body\"\u003e\n      \u003cp style\u003d\"margin-bottom: 1.5rem;\nline-height: 1.6;\"\u003e\n        次に、noteの「まじん式 v4 記事」の スキ 登録（ハートマークをクリック）をお願いします。\u003cbr\u003e\n        トップページより記事を検索してご登録をお願いします。\n      \u003c/p\u003e\n      \u003ca href\u003d\"https://note.com/majin_108/n/n192d2136245b\" target\u003d\"_blank\" rel\u003d\"noopener noreferrer\" class\u003d\"btn btn-primary\" style\u003d\"width: 100%;\nmargin-bottom: 0.5rem;\"\u003e noteの記事ページを開く\n      \u003c/a\u003e\n      \u003cdiv style\u003d\"text-align: center; margin-top: 1rem; margin-bottom: 1.5rem;\"\u003e\n        \u003cimg src\u003d\"https://lh3.google.com/u/0/d/1drGgElgg20QDYus7uCZOgwtMags4bwPT\" alt\u003d\"Note QR Code\" style\u003d\"width: 120px; height: 120px; border: 1px solid var(--border-color); border-radius: var(--radius-sm);\"\u003e\n        \u003cp style\u003d\"font-size: 0.75rem; color: var(--text-secondary); margin: 0.25rem 0 0 0;\"\u003eスマホでのアクセスはこちら\u003c/p\u003e\n      \u003c/div\u003e\n      \u003cdiv class\u003d\"button-group\" style\u003d\"display: flex;\ngap: 1rem; justify-content: space-between; align-items: center; margin-top: 0;\"\u003e \u003cbutton id\u003d\"confirmModal2\" class\u003d\"btn btn-primary\" style\u003d\"flex-grow: 1;\"\u003eスキ登録しました\u003c/button\u003e\n        \u003cdiv class\u003d\"purchase-select-wrapper\"\u003e\n          \u003cselect id\u003d\"purchaseModal2\" class\u003d\"purchase-select\"\u003e\n            \u003coption value\u003d\"\" hidden\u003e▼\u003c/option\u003e \u003coption value\u003d\"purchased\"\u003e定価購入\u003c/option\u003e \u003c/select\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv id\u003d\"activationModal3\" class\u003d\"modal-overlay\" style\u003d\"display: none;\nz-index: 10002;\"\u003e\n  \u003cdiv class\u003d\"modal-content card\" style\u003d\"max-width: 500px;\"\u003e\n    \u003ch3 class\u003d\"card-header\"\u003eステップ 3 / 5\u003c/h3\u003e\n    \u003cdiv class\u003d\"card-body\"\u003e\n      \u003cp style\u003d\"margin-bottom: 1.5rem;\nline-height: 1.6;\"\u003e\n        次に、X (旧Twitter) で「まじん」の フォロー をお願いします。\u003cbr\u003e\n        組織・個人アカウントどちらか一方でフォローいただければ、業務及びプライベートでご利用いただけます。\n      \u003c/p\u003e\n      \u003ca href\u003d\"https://x.com/Majin_AppSheet\" target\u003d\"_blank\" rel\u003d\"noopener noreferrer\" class\u003d\"btn btn-primary\" style\u003d\"width: 100%;\nmargin-bottom: 0.5rem;\"\u003e Xのフォローページを開く\n      \u003c/a\u003e\n      \u003cdiv style\u003d\"text-align: center; margin-top: 1rem; margin-bottom: 1.5rem;\"\u003e\n        \u003cimg src\u003d\"https://lh3.google.com/u/0/d/1rO_nEOe7y53jbxfrLFPMGsGYwVZVkhjT\" alt\u003d\"X QR Code\" style\u003d\"width: 120px; height: 120px; border: 1px solid var(--border-color); border-radius: var(--radius-sm);\"\u003e\n        \u003cp style\u003d\"font-size: 0.75rem; color: var(--text-secondary); margin: 0.25rem 0 0 0;\"\u003eスマホでのアクセスはこちら\u003c/p\u003e\n      \u003c/div\u003e\n      \u003cdiv class\u003d\"button-group\" style\u003d\"display: flex;\ngap: 1rem; justify-content: space-between; align-items: center; margin-top: 0;\"\u003e \u003cbutton id\u003d\"confirmModal3\" class\u003d\"btn btn-primary\" style\u003d\"flex-grow: 1;\"\u003eフォローしました\u003c/button\u003e\n        \u003cdiv class\u003d\"purchase-select-wrapper\"\u003e\n          \u003cselect id\u003d\"purchaseModal3\" class\u003d\"purchase-select\"\u003e\n            \u003coption value\u003d\"\" hidden\u003e▼\u003c/option\u003e \u003coption value\u003d\"purchased\"\u003e定価購入\u003c/option\u003e \u003c/select\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv id\u003d\"activationModal4\" class\u003d\"modal-overlay\" style\u003d\"display: none;\nz-index: 10002;\"\u003e\n  \u003cdiv class\u003d\"modal-content card\" style\u003d\"max-width: 500px;\"\u003e\n    \u003ch3 class\u003d\"card-header\"\u003eステップ 4 / 5\u003c/h3\u003e\n    \u003cdiv class\u003d\"card-body\"\u003e\n      \u003cp style\u003d\"margin-bottom: 1.5rem;\nline-height: 1.6;\"\u003e\n        最後に、Xの「まじん式 v4 投稿」に いいね と リポスト をお願いします。\u003cbr\u003e\n        トップページより投稿を検索してご登録をお願いします。いいねは、ハートマークをクリック、リポスト（矢印が２つ回転しているマークをクリック）は引用投稿でも問題ありません。\n      \u003c/p\u003e\n      \u003ca href\u003d\"https://x.com/Majin_AppSheet/status/1989296893198016658?s\u003d20\" target\u003d\"_blank\" rel\u003d\"noopener noreferrer\" class\u003d\"btn btn-primary\" style\u003d\"width: 100%;\nmargin-bottom: 0.5rem;\"\u003e Xの投稿ページを開く\n      \u003c/a\u003e\n      \u003cdiv style\u003d\"text-align: center; margin-top: 1rem; margin-bottom: 1.5rem;\"\u003e\n        \u003cimg src\u003d\"https://lh3.google.com/u/0/d/1e7spO4pcQPccEud2yKiHyBniKnrPEB56\" alt\u003d\"X QR Code\" style\u003d\"width: 120px; height: 120px; border: 1px solid var(--border-color); border-radius: var(--radius-sm);\"\u003e\n        \u003cp style\u003d\"font-size: 0.75rem; color: var(--text-secondary); margin: 0.25rem 0 0 0;\"\u003eスマホでのアクセスはこちら\u003c/p\u003e\n      \u003c/div\u003e\n      \u003cdiv class\u003d\"button-group\" style\u003d\"display: flex;\ngap: 1rem; justify-content: space-between; align-items: center; margin-top: 0;\"\u003e \u003cbutton id\u003d\"confirmModal4\" class\u003d\"btn btn-primary\" style\u003d\"flex-grow: 1;\"\u003eいいね/リポストしました\u003c/button\u003e\n        \u003cdiv class\u003d\"purchase-select-wrapper\"\u003e\n          \u003cselect id\u003d\"purchaseModal4\" class\u003d\"purchase-select\"\u003e\n            \u003coption value\u003d\"\" hidden\u003e▼\u003c/option\u003e \u003coption value\u003d\"purchased\"\u003e定価購入\u003c/option\u003e \u003c/select\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv id\u003d\"termsModal\" class\u003d\"modal-overlay\" style\u003d\"display: none; z-index: 10001;\"\u003e \n  \u003cdiv class\u003d\"modal-content card\" style\u003d\"max-width: 90vw; width: 840px; height: 90vh; display: flex; flex-direction: column;\"\u003e\n    \u003ch3 class\u003d\"card-header\" id\u003d\"termsModalHeader\" style\u003d\"flex-shrink: 0;\"\u003e\n      利用条件 (Terms of Service)\n    \u003c/h3\u003e\n    \u003cdiv class\u003d\"card-body\" style\u003d\"flex-grow: 1; padding: 0.5rem; overflow: hidden; display: flex; justify-content: center;\"\u003e\n      \u003ciframe id\u003d\"termsFrame\" \n              src\u003d\"https://docs.google.com/document/d/e/2PACX-1vSjM9eBeZvqaRzGIlyjPiB_CuhSBSjsJY7eahzMxoch-WQGLwrOcUAaDv1cxOll720J8bib1XoGlG8J/pub?embedded\u003dtrue\" \n              style\u003d\"width: 100%;\nheight: 100%; border: none; border-radius: var(--radius-md); max-width: 840px;\"\u003e\n      \u003c/iframe\u003e\n    \u003c/div\u003e\n    \u003cdiv class\u003d\"card-body\" style\u003d\"flex-shrink: 0; padding-top: 1rem; border-top: 1px solid var(--border-color);\"\u003e\n      \u003cdiv id\u003d\"termsModalActivationButtons\" style\u003d\"display: none;\"\u003e\n        \u003cdiv class\u003d\"button-group\" style\u003d\"display: flex; gap: 1rem; justify-content: space-between; align-items: center;\"\u003e\n          \u003cbutton id\u003d\"confirmModal5\" class\u003d\"btn btn-primary\" style\u003d\"flex-grow: 1;\"\u003e利用条件に同意して開始\u003c/button\u003e\n          \u003cdiv class\u003d\"purchase-select-wrapper\" style\u003d\"display: none;\"\u003e\n            \u003cselect id\u003d\"purchaseModal5\" class\u003d\"purchase-select\"\u003e\n              \u003coption value\u003d\"\"\u003e購入者の方\u003c/option\u003e\n              \u003coption value\u003d\"purchased\"\u003e定価で購入した\u003c/option\u003e\n            \u003c/select\u003e\n          \u003c/div\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n      \u003cdiv id\u003d\"termsModalStandardButtons\" style\u003d\"display: block;\"\u003e\n        \u003cbutton id\u003d\"closeTermsModalBtn\" class\u003d\"btn btn-primary\" style\u003d\"width: 100%;\"\u003e閉じる\u003c/button\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n  \u003cdiv id\u003d\"summaryPromptModal\" class\u003d\"modal-overlay\" style\u003d\"display: none; z-index: 10010;\"\u003e\n    \u003cdiv class\u003d\"modal-content card\" style\u003d\"max-width: 600px;\"\u003e\n      \u003ch3 class\u003d\"card-header\"\u003e要約スライドの追加\u003c/h3\u003e\n      \u003cdiv class\u003d\"card-body\"\u003e\n        \u003cp style\u003d\"margin-bottom: 0.5rem; margin-top: 0; line-height: 1.4; color: var(--text-secondary); font-size: 0.9rem;\"\u003e\n          Geminiで生成した要約画像をスライドに追加します。\n        \u003c/p\u003e\n        \u003cdiv style\u003d\"display: grid; grid-template-columns: 200px 1fr; gap: 1rem; margin-bottom: 1.5rem; align-items: start;\"\u003e\n            \u003cdiv style\u003d\"display: flex; flex-direction: column; gap: 0.5rem;\"\u003e\n                \u003cbutton id\u003d\"copySummaryOnlyBtn\" class\u003d\"btn btn-primary\" style\u003d\"justify-content: flex-start; text-align: left; padding: 0.6rem 1rem; font-size: 0.9rem;\"\u003e\n                    ① プロンプトをコピー\n                \u003c/button\u003e\n                \u003ca href\u003d\"https://gemini.google.com/app\" target\u003d\"_blank\" rel\u003d\"noopener noreferrer\" class\u003d\"btn btn-primary\" style\u003d\"justify-content: flex-start; text-align: left; text-decoration: none; padding: 0.6rem 1rem; font-size: 0.9rem; display: flex; align-items: center;\"\u003e\n                    ② Geminiで画像生成\n                \u003c/a\u003e\n            \u003c/div\u003e\n            \u003ctextarea id\u003d\"summaryPromptTextarea\" class\u003d\"form-control\" rows\u003d\"4\" readonly \n              style\u003d\"font-family: var(--font-family-code); font-size: 0.75rem; background: #f9f9f9; resize: none; height: 100%; min-height: 85px; margin-bottom: 0;\"\u003e\u003c/textarea\u003e\n        \u003c/div\u003e\n        \u003cdiv style\u003d\"border-top: 1px solid var(--border-color); margin-bottom: 1.5rem;\"\u003e\u003c/div\u003e\n        \u003cp style\u003d\"font-weight: 600; margin-bottom: 0.5rem;\"\u003e③ 画像をアップロード（フルサイズ画像推奨）\u003c/p\u003e\n        \u003cdiv id\u003d\"summaryDropZone\" class\u003d\"drop-zone\" style\u003d\"padding: 1.5rem; transition: background-color 0.2s;\"\u003e\n          \u003cspan id\u003d\"summaryDropZoneText\" style\u003d\"color: var(--text-secondary); font-size: 0.9rem;\"\u003e\n            ここに画像をドラッグ＆ドロップ\u003cbr\u003e\n            \u003ca href\u003d\"#\" id\u003d\"summaryFileSelectLink\" style\u003d\"color: var(--primary-color); text-decoration: underline;\"\u003eファイルを選択\u003c/a\u003e\u003cbr\u003e\n            または、画像をペースト (Ctrl+V)\u003cbr\u003e\n            \u003cspan style\u003d\"font-size: 0.8rem; opacity: 0.8;\"\u003e(エリア内ダブルクリックでクリップボードから貼付)\u003c/span\u003e\n          \u003c/span\u003e\n        \u003c/div\u003e\n        \u003cinput type\u003d\"file\" id\u003d\"summaryImageUpload\" accept\u003d\"image/*\" style\u003d\"display: none;\"\u003e\n        \u003cdiv class\u003d\"button-group\" style\u003d\"display: flex; gap: 1rem; margin-top: 1.5rem;\"\u003e\n          \u003cbutton id\u003d\"closeSummaryPromptBtn\" class\u003d\"btn btn-secondary\" style\u003d\"background-color: var(--secondary-color); margin-left: auto;\"\u003e閉じる\u003c/button\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n  \u003cdiv id\u003d\"membershipModal\" class\u003d\"modal-overlay\" style\u003d\"display: none; z-index: 10003;\"\u003e\n  \u003cdiv class\u003d\"modal-content card\" style\u003d\"max-width: 550px; max-height: 90vh; position: relative;\"\u003e\n    \u003cbutton id\u003d\"closeMembershipModalBtn\" class\u003d\"panel-close-btn\" style\u003d\"display: block; z-index: 20; top: 0.5rem; right: 0.5rem;\"\u003e×\u003c/button\u003e\n    \u003ch3 class\u003d\"card-header\"\u003enoteメンバーシップのご紹介\u003c/h3\u003e\n    \u003cdiv class\u003d\"card-body\" style\u003d\"overflow-y: auto;\"\u003e\n      \u003ch4 style\u003d\"text-align: center; font-size: 1.2rem; margin-top: 0; margin-bottom: 0.5rem; color: var(--primary-color);\"\u003e「Majincraft（マジンクラフト）」がスタート！🎉\u003c/h4\u003e\n      \u003cp style\u003d\"font-size: 0.95rem; line-height: 1.6; margin-bottom: 1.5rem;\"\u003e\n        あなたの作業時間を月10時間分（の気持ちで）削減する、超実践的な情報をお届けします。\u003cbr\u003e\n        「まじん」の分かりやすい解説と、「やまじん」のマニアックな技術ハックで、ビギナーからエキスパートまで徹底サポート！\n      \u003c/p\u003e\n      \u003ch5 style\u003d\"font-size: 1rem; font-weight: 700; margin: 1.5rem 0 0.75rem 0; border-top: 1px solid var(--border-color); padding-top: 1.5rem;\"\u003eメンバー限定コンテンツ\u003c/h5\u003e\n      \u003cul style\u003d\"padding-left: 20px; margin: 0 0 1rem 0; font-size: 0.9rem; line-height: 1.7;\"\u003e\n        \u003cli\u003eまじん式 v4.1〜 の先行アップデート\u003c/li\u003e\n        \u003cli\u003eGeminiやWorkspaceの実践的活用術\u003c/li\u003e\n        \u003cli\u003eSVG・フレーム抽出の技術解説\u003c/li\u003e\n        \u003cli\u003eまじん式のガチ開発秘話\u003c/li\u003e\n        \u003cli\u003eメンバー限定ウェビナー\u003c/li\u003e\n      \u003c/ul\u003e\n      \u003ch5 style\u003d\"font-size: 1rem; font-weight: 700; margin: 0 0 0.75rem 0;\"\u003e2つの限定特典\u003c/h5\u003e\n      \u003cul style\u003d\"padding-left: 20px; margin: 0; font-size: 0.9rem; line-height: 1.7;\"\u003e\n        \u003cli\u003eスライドの「クレジットなし」GASコードを提供！\u003cbr\u003e\u003cspan style\u003d\"font-size: 0.8em; color: var(--text-secondary);\"\u003e(社内ルールが厳しい方におすすめです)\u003c/span\u003e\u003c/li\u003e\n        \u003cli\u003e今後公開される単発の有料記事がすべて無料に！\u003c/li\u003e\n      \u003c/ul\u003e\n      \u003cp style\u003d\"font-weight: 700; text-align: center; margin: 2rem 0 1rem 0; font-size: 1rem;\"\u003e\n        あなたのスキルアップと業務効率化を全力で応援します。\u003cbr\u003eぜひご参加ください！\n      \u003c/p\u003e\n      \u003cdiv class\u003d\"membership-footer\" style\u003d\"display: flex; align-items: center; justify-content: space-between; gap: 1.5rem; border-top: 1px solid var(--border-color); padding-top: 1.5rem; margin-top: 1.5rem;\"\u003e\n        \u003cdiv style\u003d\"flex-grow: 1;\"\u003e\n          \u003cp style\u003d\"font-weight: 600; margin: 0 0 0.5rem 0;\"\u003e noteで詳細を見る:\u003c/p\u003e\n          \u003ca href\u003d\"https://note.com/majin_108/membership\" target\u003d\"_blank\" rel\u003d\"noopener noreferrer\" style\u003d\"color: var(--primary-color); text-decoration: underline; word-break: break-all;\"\u003e\n            https://note.com/majin_108/membership\n          \u003c/a\u003e\n        \u003c/div\u003e\n        \u003cdiv style\u003d\"text-align: center; flex-shrink: 0;\"\u003e\n          \u003cimg src\u003d\"https://lh3.google.com/u/0/d/1y1d_pP-akdeRTZGoIv7GxK86UyYnPYxh\" alt\u003d\"note QR Code\" style\u003d\"width: 100px; height: 100px; border: 1px solid var(--border-color); border-radius: var(--radius-sm); margin: 0 auto;\"\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n\u003cdiv id\u003d\"svgEditorModal\" class\u003d\"modal-overlay\" style\u003d\"display: none; z-index: 10050;\"\u003e\n  \u003cdiv class\u003d\"modal-content card\" style\u003d\"width: 95%; height: 90vh; max-width: 1200px; display: flex; flex-direction: column; padding: 0;\"\u003e\n    \u003cdiv class\u003d\"card-header\" style\u003d\"display: flex; justify-content: space-between; align-items: center; padding: 10px 20px;\"\u003e\n      \u003cdiv style\u003d\"display: flex; align-items: center; gap: 15px;\"\u003e\n        \u003cspan\u003eSVGビジュアルエディタ（β版）\u003c/span\u003e\n        \u003cdiv style\u003d\"display: flex; gap: 5px;\"\u003e\n          \u003cbutton id\u003d\"svgUndoBtn\" class\u003d\"btn btn-secondary\" style\u003d\"padding: 2px 10px; font-size: 0.8rem;\" title\u003d\"元に戻す (Ctrl+Z)\" disabled\u003e◀ 戻る\u003c/button\u003e\n          \u003cbutton id\u003d\"svgRedoBtn\" class\u003d\"btn btn-secondary\" style\u003d\"padding: 2px 10px; font-size: 0.8rem;\" title\u003d\"やり直す (Ctrl+Y)\" disabled\u003e進む ▶\u003c/button\u003e\n        \u003c/div\u003e\n      \u003c/div\u003e\n      \u003cdiv\u003e\n        \u003cbutton id\u003d\"svgEditorSaveBtn\" class\u003d\"btn btn-primary\" style\u003d\"width: auto; padding: 5px 15px; margin-right: 10px;\"\u003e保存して閉じる\u003c/button\u003e\n        \u003cbutton id\u003d\"svgEditorCancelBtn\" class\u003d\"btn btn-secondary\" style\u003d\"width: auto; padding: 5px 15px;\"\u003eキャンセル\u003c/button\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n    \u003cdiv class\u003d\"svg-editor-body\" style\u003d\"flex-grow: 1; display: flex; overflow: hidden;\"\u003e\n      \u003cdiv id\u003d\"svgEditorCanvas\" style\u003d\"flex-grow: 1; background: #e5e7eb; display: flex; align-items: center; justify-content: center; overflow: auto; padding: 20px; position: relative;\"\u003e\n        \u003c/div\u003e\n      \u003cdiv id\u003d\"svgEditorSidebar\" style\u003d\"width: 240px; background: #fff; border-left: 1px solid var(--border-color); padding: 15px; overflow-y: auto; overflow-x: hidden; flex-shrink: 0;\"\u003e\n        \u003cdiv style\u003d\"border-bottom: 1px solid var(--border-color); margin-bottom: 1.5rem; padding-bottom: 1rem;\"\u003e\n          \u003cdiv class\u003d\"form-group\" style\u003d\"display: none;\"\u003e\n            \u003cinput type\u003d\"number\" id\u003d\"svgCanvasWidth\"\u003e\n            \u003cinput type\u003d\"number\" id\u003d\"svgCanvasHeight\"\u003e\n            \u003cinput type\u003d\"number\" id\u003d\"svgViewBoxX\"\u003e\n            \u003cinput type\u003d\"number\" id\u003d\"svgViewBoxY\"\u003e\n          \u003c/div\u003e\n          \u003cdiv class\u003d\"form-group\" style\u003d\"margin-bottom: 0.5rem;\"\u003e\n            \u003cdiv style\u003d\"display: grid; grid-template-columns: 1fr 1fr; gap: 10px;\"\u003e\n              \u003cdiv\u003e\n                \u003clabel style\u003d\"font-size: 0.75rem; color: var(--text-secondary); display: block; margin-bottom: 2px;\"\u003eWidth\u003c/label\u003e\n                \u003cinput type\u003d\"number\" id\u003d\"svgViewBoxW\" class\u003d\"form-control\" style\u003d\"padding: 5px; font-weight: bold; color: var(--primary-color);\"\u003e\n              \u003c/div\u003e\n              \u003cdiv\u003e\n                \u003clabel style\u003d\"font-size: 0.75rem; color: var(--text-secondary); display: block; margin-bottom: 2px;\"\u003eHeight\u003c/label\u003e\n                \u003cinput type\u003d\"number\" id\u003d\"svgViewBoxH\" class\u003d\"form-control\" style\u003d\"padding: 5px; font-weight: bold; color: var(--primary-color);\"\u003e\n              \u003c/div\u003e\n            \u003c/div\u003e\n          \u003c/div\u003e\n        \u003c/div\u003e\n        \u003cdiv id\u003d\"svgEditorControls\" style\u003d\"display: none;\"\u003e\n          \u003cdiv class\u003d\"form-group\" style\u003d\"margin-bottom: 1.25rem;\"\u003e\n            \u003clabel\u003eタグ名\u003c/label\u003e\n            \u003cinput type\u003d\"text\" id\u003d\"svgEditTagName\" class\u003d\"form-control\" disabled style\u003d\"background: #f3f4f6;\"\u003e\n          \u003c/div\u003e\n          \u003cdiv class\u003d\"form-group\" style\u003d\"margin-bottom: 1.25rem;\"\u003e\n            \u003clabel\u003eテキスト内容\u003c/label\u003e\n            \u003ctextarea id\u003d\"svgEditText\" class\u003d\"form-control\" rows\u003d\"3\"\u003e\u003c/textarea\u003e\n          \u003c/div\u003e\n          \u003cdiv class\u003d\"form-group\" style\u003d\"margin-bottom: 1.25rem;\"\u003e\n            \u003clabel\u003e全体不透明度 (Opacity)\u003c/label\u003e\n            \u003cdiv style\u003d\"display: flex; align-items: center; gap: 5px;\"\u003e\n              \u003cinput type\u003d\"range\" id\u003d\"svgEditOpacityRange\" min\u003d\"0\" max\u003d\"1\" step\u003d\"0.1\" style\u003d\"flex-grow: 1;\"\u003e\n              \u003cinput type\u003d\"number\" id\u003d\"svgEditOpacity\" class\u003d\"form-control\" step\u003d\"0.1\" max\u003d\"1\" min\u003d\"0\" style\u003d\"width: 60px;\"\u003e\n            \u003c/div\u003e\n          \u003c/div\u003e\n          \u003cdiv class\u003d\"form-group\" style\u003d\"margin-bottom: 1.25rem;\"\u003e\n            \u003clabel\u003e塗りつぶし (Fill)\u003c/label\u003e\n            \u003cdiv class\u003d\"input-group\"\u003e\n              \u003cinput type\u003d\"color\" id\u003d\"svgEditFillColor\"\u003e\n              \u003cinput type\u003d\"text\" id\u003d\"svgEditFillText\" class\u003d\"form-control\"\u003e\n            \u003c/div\u003e\n          \u003c/div\u003e\n          \u003cdiv class\u003d\"form-group\" style\u003d\"margin-bottom: 1.25rem;\"\u003e\n            \u003clabel\u003e塗りの不透明度 (Fill Opacity)\u003c/label\u003e\n            \u003cdiv style\u003d\"display: flex; align-items: center; gap: 5px;\"\u003e\n              \u003cinput type\u003d\"range\" id\u003d\"svgEditFillOpacityRange\" min\u003d\"0\" max\u003d\"1\" step\u003d\"0.1\" style\u003d\"flex-grow: 1;\"\u003e\n              \u003cinput type\u003d\"number\" id\u003d\"svgEditFillOpacity\" class\u003d\"form-control\" step\u003d\"0.1\" max\u003d\"1\" min\u003d\"0\" style\u003d\"width: 60px;\"\u003e\n            \u003c/div\u003e\n          \u003c/div\u003e\n          \u003cdiv class\u003d\"form-group\" style\u003d\"margin-bottom: 1.25rem;\"\u003e\n            \u003clabel\u003e線の色 (Stroke)\u003c/label\u003e\n            \u003cdiv class\u003d\"input-group\"\u003e\n              \u003cinput type\u003d\"color\" id\u003d\"svgEditStrokeColor\"\u003e\n              \u003cinput type\u003d\"text\" id\u003d\"svgEditStrokeText\" class\u003d\"form-control\"\u003e\n            \u003c/div\u003e\n          \u003c/div\u003e\n          \u003cdiv class\u003d\"form-group\" style\u003d\"margin-bottom: 1.25rem;\"\u003e\n            \u003clabel\u003e線の不透明度 (Stroke Opacity)\u003c/label\u003e\n            \u003cdiv style\u003d\"display: flex; align-items: center; gap: 5px;\"\u003e\n              \u003cinput type\u003d\"range\" id\u003d\"svgEditStrokeOpacityRange\" min\u003d\"0\" max\u003d\"1\" step\u003d\"0.1\" style\u003d\"flex-grow: 1;\"\u003e\n              \u003cinput type\u003d\"number\" id\u003d\"svgEditStrokeOpacity\" class\u003d\"form-control\" step\u003d\"0.1\" max\u003d\"1\" min\u003d\"0\" style\u003d\"width: 60px;\"\u003e\n            \u003c/div\u003e\n          \u003c/div\u003e\n          \u003cdiv class\u003d\"form-group\" style\u003d\"margin-bottom: 1.25rem;\"\u003e\n            \u003clabel\u003e線の太さ (Width)\u003c/label\u003e\n            \u003cinput type\u003d\"number\" id\u003d\"svgEditStrokeWidth\" class\u003d\"form-control\" step\u003d\"0.5\"\u003e\n          \u003c/div\u003e\n          \u003cdiv class\u003d\"form-group\" style\u003d\"margin-bottom: 1.25rem;\"\u003e\n            \u003clabel\u003eサイズ (拡大率)\u003c/label\u003e\n            \u003cdiv style\u003d\"display: flex; align-items: center; gap: 5px;\"\u003e\n              \u003cinput type\u003d\"range\" id\u003d\"svgEditScaleRange\" min\u003d\"0.1\" max\u003d\"3.0\" step\u003d\"0.1\" style\u003d\"flex-grow: 1;\"\u003e\n              \u003cinput type\u003d\"number\" id\u003d\"svgEditScale\" class\u003d\"form-control\" step\u003d\"0.1\" style\u003d\"width: 60px;\"\u003e\n            \u003c/div\u003e\n          \u003c/div\u003e\n          \u003cdiv class\u003d\"form-group\" style\u003d\"margin-bottom: 1.25rem;\"\u003e\n            \u003clabel\u003e重なりの順序\u003c/label\u003e\n            \u003cdiv style\u003d\"display: grid; grid-template-columns: 1fr 1fr; gap: 8px;\"\u003e\n              \u003cbutton id\u003d\"svgBringFrontBtn\" class\u003d\"btn btn-secondary\" style\u003d\"padding: 8px; font-size: 0.75rem;\" title\u003d\"最前面へ\"\u003e最前面\u003c/button\u003e\n              \u003cbutton id\u003d\"svgBringForwardBtn\" class\u003d\"btn btn-secondary\" style\u003d\"padding: 8px; font-size: 0.75rem;\" title\u003d\"一つ前へ\"\u003e前へ\u003c/button\u003e\n              \u003cbutton id\u003d\"svgSendBackwardBtn\" class\u003d\"btn btn-secondary\" style\u003d\"padding: 8px; font-size: 0.75rem;\" title\u003d\"一つ後ろへ\"\u003e後ろへ\u003c/button\u003e\n              \u003cbutton id\u003d\"svgSendBackBtn\" class\u003d\"btn btn-secondary\" style\u003d\"padding: 8px; font-size: 0.75rem;\" title\u003d\"最背面へ\"\u003e最背面\u003c/button\u003e\n            \u003c/div\u003e\n          \u003c/div\u003e\n        \u003c/div\u003e\n        \u003cdiv id\u003d\"svgEditorNoSelection\" style\u003d\"margin-top: 2rem; text-align: center; color: #9ca3af;\"\u003e\n          選択されていません\n        \u003c/div\u003e\n      \u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n\u003c/div\u003e\n  \u003cscript type\u003d\"text/worker\" id\u003d\"apng-worker-script\"\u003e\n    // \n    self.onmessage \u003d function(event) {\n        const { frames, delays, width, height } \u003d event.data;\n        try {\n            // \n            const apngBuffer \u003d UPNG.encode(frames, width, height, 0, delays);\n            // \n            self.postMessage({ status: \u0027success\u0027, buffer: apngBuffer }, [apngBuffer]);\n        } catch (error) {\n            console.error(\u0027[Worker] APNGエンコード失敗:\u0027, error);\n            // \n            self.postMessage({ status: \u0027error\u0027, message: error.message });\n        }\n    };\n  \u003c/script\u003e\n  \u003cbutton id\u003d\"appSwitcherBtn\" title\u003d\"ツール切り替え\"\u003e\n    \u003cspan class\u003d\"material-icons-outlined\" style\u003d\"margin-right:6px; font-size:1.1em;\"\u003eswap_horiz\u003c/span\u003e\n    \u003cspan id\u003d\"appSwitcherLabel\"\u003emajinTools\u003c/span\u003e\n  \u003c/button\u003e\n  \u003cdiv id\u003d\"majinToolsContainer\"\u003e\n    \u003cdiv class\u003d\"mt-app-card\"\u003e\n      \u003ch1\u003emajinTools PDF to Slides\u003c/h1\u003e\n      \u003cdiv id\u003d\"mt-drop-zone\" class\u003d\"drop-zone\" tabindex\u003d\"0\"\u003e\n        \u003cinput type\u003d\"file\" id\u003d\"mt-pdf-upload\" accept\u003d\"application/pdf\" style\u003d\"display: none;\"\u003e\n        \u003cspan class\u003d\"material-icons-outlined icon\"\u003ecloud_upload\u003c/span\u003e\n        \u003cp\u003eここにPDFをドラッグ＆ドロップ\u003cbr\u003eまたは \u003cspan class\u003d\"browse-btn\" id\u003d\"mt-browse-btn\"\u003eファイルを選択\u003c/span\u003e\u003c/p\u003e\n        \u003cp style\u003d\"font-size: 12px; margin-top: 8px; color: #9aa0a6;\"\u003e(Ctrl+V で貼り付けも可能)\u003c/p\u003e\n      \u003c/div\u003e\n      \u003cdiv id\u003d\"mt-file-display\" class\u003d\"file-display\"\u003e\n        \u003cspan class\u003d\"material-icons-outlined\" style\u003d\"font-size:18px;\"\u003edescription\u003c/span\u003e\n        \u003cspan id\u003d\"mt-file-name\"\u003efilename.pdf\u003c/span\u003e\n      \u003c/div\u003e\n      \u003cdiv class\u003d\"options-area\"\u003e\n        \u003clabel class\u003d\"toggle-switch\"\u003e\n          \u003cspan class\u003d\"toggle-label\"\u003e画像を編集不可にする（背景化）\u003c/span\u003e\n          \u003clabel class\u003d\"switch\"\u003e\n            \u003cinput type\u003d\"checkbox\" id\u003d\"mt-bg-mode-check\"\u003e\n            \u003cspan class\u003d\"slider\"\u003e\u003c/span\u003e\n          \u003c/label\u003e\n        \u003c/label\u003e\n      \u003c/div\u003e\n      \u003cbutton id\u003d\"mt-convert-btn\" class\u003d\"mt-action-btn\" disabled\u003eスライドを作成\u003c/button\u003e\n      \u003cdiv id\u003d\"mt-status-text\" class\u003d\"status-text\"\u003e\u003c/div\u003e\n    \u003c/div\u003e\n    \u003cdiv id\u003d\"mt-history-section\" class\u003d\"history-section\" style\u003d\"display: none;\"\u003e\n      \u003cdiv class\u003d\"history-header\"\u003e最近作成したファイル\u003c/div\u003e\n      \u003cdiv id\u003d\"mt-history-list\" class\u003d\"history-list\"\u003e\u003c/div\u003e\n    \u003c/div\u003e\n  \u003c/div\u003e\n  \u003cscript\u003e\n    // \n    (function() {\n      const switcherBtn \u003d document.getElementById(\u0027appSwitcherBtn\u0027);\n      const switcherLabel \u003d document.getElementById(\u0027appSwitcherLabel\u0027);\n      const mainAppLayout \u003d document.getElementById(\u0027app-layout\u0027); // \n      const mtContainer \u003d document.getElementById(\u0027majinToolsContainer\u0027);\n      let isMajinToolsMode \u003d false;\n      switcherBtn.addEventListener(\u0027click\u0027, function() {\n        // \n        if (typeof isPreviewVisible !\u003d\u003d \u0027undefined\u0027 \u0026\u0026 isPreviewVisible \u0026\u0026 !isMajinToolsMode) {\n          // \n        }\n        isMajinToolsMode \u003d !isMajinToolsMode;\n        toggleMode();\n      });\n      function toggleMode() {\n        if (isMajinToolsMode) {\n          // \n          mainAppLayout.style.display \u003d \u0027none\u0027;\n          mtContainer.style.display \u003d \u0027block\u0027;\n          switcherLabel.textContent \u003d \u0027まじん式\u0027;\n          switcherBtn.classList.add(\u0027active-mode\u0027);\n          // \n          if(typeof MajinTools !\u003d\u003d \u0027undefined\u0027) MajinTools.loadHistory();\n        } else {\n          // \n          mainAppLayout.style.display \u003d \u0027grid\u0027; // \n          mtContainer.style.display \u003d \u0027none\u0027;\n          switcherLabel.textContent \u003d \u0027majinTools\u0027;\n          switcherBtn.classList.remove(\u0027active-mode\u0027);\n        }\n      }\n      // \n      // \n      const originalShowPreviewPane \u003d window.showPreviewPane;\n      window.showPreviewPane \u003d function() {\n        if(originalShowPreviewPane) originalShowPreviewPane.apply(this, arguments);\n        updateSwitcherVisibility();\n      };\n      const originalHidePreviewPane \u003d window.hidePreviewPane;\n      window.hidePreviewPane \u003d function() {\n        if(originalHidePreviewPane) originalHidePreviewPane.apply(this, arguments);\n        updateSwitcherVisibility();\n      };\n      function updateSwitcherVisibility() {\n        // \n        if (typeof isPreviewVisible !\u003d\u003d \u0027undefined\u0027 \u0026\u0026 isPreviewVisible) {\n          switcherBtn.style.display \u003d \u0027none\u0027;\n        } else {\n          switcherBtn.style.display \u003d \u0027inline-flex\u0027;\n        }\n      }\n      // \n      updateSwitcherVisibility();\n    })();\n    // \n    const MajinTools \u003d (function() {\n      const dropZone \u003d document.getElementById(\u0027mt-drop-zone\u0027);\n      const fileInput \u003d document.getElementById(\u0027mt-pdf-upload\u0027);\n      const browseBtn \u003d document.getElementById(\u0027mt-browse-btn\u0027);\n      const fileDisplay \u003d document.getElementById(\u0027mt-file-display\u0027);\n      const fileNameSpan \u003d document.getElementById(\u0027mt-file-name\u0027);\n      const convertBtn \u003d document.getElementById(\u0027mt-convert-btn\u0027);\n      const statusText \u003d document.getElementById(\u0027mt-status-text\u0027);\n      let selectedFile \u003d null;\n      let pdfDimensions \u003d { width: 0, height: 0 };\n      let generatedSlideUrl \u003d null;\n      let timerInterval \u003d null;\n      let startTime \u003d 0;\n      function init() {\n        browseBtn.addEventListener(\u0027click\u0027, (e) \u003d\u003e {\n          e.stopPropagation();\n          fileInput.click();\n        });\n        fileInput.addEventListener(\u0027change\u0027, (e) \u003d\u003e {\n          if (e.target.files.length \u003e 0) handleFile(e.target.files[0]);\n        });\n        [\u0027dragenter\u0027, \u0027dragover\u0027, \u0027dragleave\u0027, \u0027drop\u0027].forEach(eventName \u003d\u003e {\n          dropZone.addEventListener(eventName, preventDefaults, false);\n        });\n        [\u0027dragenter\u0027, \u0027dragover\u0027].forEach(eventName \u003d\u003e {\n          dropZone.addEventListener(eventName, () \u003d\u003e dropZone.classList.add(\u0027dragover\u0027), false);\n        });\n        [\u0027dragleave\u0027, \u0027drop\u0027].forEach(eventName \u003d\u003e {\n          dropZone.addEventListener(eventName, () \u003d\u003e dropZone.classList.remove(\u0027dragover\u0027), false);\n        });\n        dropZone.addEventListener(\u0027drop\u0027, (e) \u003d\u003e {\n          const dt \u003d e.dataTransfer;\n          if (dt.files.length \u003e 0) handleFile(dt.files[0]);\n        });\n        // \n        document.addEventListener(\u0027paste\u0027, (e) \u003d\u003e {\n          const container \u003d document.getElementById(\u0027majinToolsContainer\u0027);\n          if (container.style.display \u003d\u003d\u003d \u0027none\u0027) return; // \n          const items \u003d (e.clipboardData || e.originalEvent.clipboardData).items;\n          for (let index in items) {\n            const item \u003d items[index];\n            if (item.kind \u003d\u003d\u003d \u0027file\u0027 \u0026\u0026 item.type \u003d\u003d\u003d \u0027application/pdf\u0027) {\n              handleFile(item.getAsFile());\n              break; \n            }\n          }\n        });\n        convertBtn.addEventListener(\u0027click\u0027, () \u003d\u003e {\n          if (generatedSlideUrl) {\n            window.open(generatedSlideUrl, \u0027_blank\u0027);\n          } else {\n            processPDF();\n          }\n        });\n      }\n      function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }\n      async function handleFile(file) {\n        if (file.type !\u003d\u003d \u0027application/pdf\u0027) {\n          showStatus(\"PDFファイルを選択してください\", \"error-msg\");\n          return;\n        }\n        selectedFile \u003d file;\n        fileNameSpan.textContent \u003d file.name || \"pasted_file.pdf\";\n        generatedSlideUrl \u003d null; \n        resetButtonState();\n        dropZone.style.display \u003d \u0027none\u0027;\n        fileDisplay.style.display \u003d \u0027inline-flex\u0027;\n        showStatus(\"\");\n        try {\n          const arrayBuffer \u003d await file.arrayBuffer();\n          const pdf \u003d await pdfjsLib.getDocument(arrayBuffer).promise;\n          const page \u003d await pdf.getPage(1);\n          const viewport \u003d page.getViewport({ scale: 1.0 });\n          pdfDimensions.width \u003d viewport.width;\n          pdfDimensions.height \u003d viewport.height;\n        } catch (e) {\n          console.error(\"PDF解析エラー\", e);\n          showStatus(\"PDFの読み込みに失敗しました\", \"error-msg\");\n        }\n      }\n      async function processPDF() {\n        if (!selectedFile) return;\n        const isBgMode \u003d document.getElementById(\u0027mt-bg-mode-check\u0027).checked;\n        startTimerAnimation(); \n        convertBtn.disabled \u003d true; \n        showStatus(\"高画質画像を生成しています...\", \"\");\n        try {\n          const arrayBuffer \u003d await selectedFile.arrayBuffer();\n          const pdf \u003d await pdfjsLib.getDocument(arrayBuffer).promise;\n          const numPages \u003d pdf.numPages;\n          let images \u003d [];\n          for (let i \u003d 1; i \u003c\u003d numPages; i++) {\n            showStatus(`画像を生成中 (${i} / ${numPages})`, \"\");\n            const page \u003d await pdf.getPage(i);\n            const viewport \u003d page.getViewport({ scale: 3.0 }); \n            const canvas \u003d document.createElement(\u0027canvas\u0027);\n            const context \u003d canvas.getContext(\u00272d\u0027);\n            canvas.height \u003d viewport.height;\n            canvas.width \u003d viewport.width;\n            await page.render({ canvasContext: context, viewport: viewport }).promise;\n            images.push(canvas.toDataURL(\u0027image/jpeg\u0027, 0.95)); \n          }\n          showStatus(\"Googleスライドを作成しています...\", \"\");\n          // \n          google.script.run\n            .withSuccessHandler((url) \u003d\u003e {\n              stopTimerAnimation();\n              generatedSlideUrl \u003d url; \n              convertBtn.innerText \u003d \"スライドを表示\"; \n              convertBtn.classList.add(\u0027completed\u0027);   \n              convertBtn.disabled \u003d false; \n              showStatus(\"完了しました\", \"success-msg\");\n              setTimeout(() \u003d\u003e window.open(url, \u0027_blank\u0027), 500);\n              loadHistory();\n            })\n            .withFailureHandler((err) \u003d\u003e {\n              stopTimerAnimation();\n              resetButtonState(); \n              showStatus(\"エラー: \" + err.message, \"error-msg\");\n            })\n            .mt_createSlideFromImages(images, selectedFile.name || \"Converted.pdf\", pdfDimensions.width, pdfDimensions.height, isBgMode);\n        } catch (error) {\n          stopTimerAnimation();\n          resetButtonState();\n          showStatus(\"処理エラー: \" + error.message, \"error-msg\");\n        }\n      }\n      function startTimerAnimation() {\n        convertBtn.classList.add(\u0027processing\u0027);\n        startTime \u003d Date.now();\n        timerInterval \u003d setInterval(() \u003d\u003e {\n          const elapsedTime \u003d Date.now() - startTime;\n          const seconds \u003d (elapsedTime / 1000).toFixed(2); \n          convertBtn.innerText \u003d `スライド作成中... ${seconds}s`;\n        }, 30);\n      }\n      function stopTimerAnimation() {\n        if (timerInterval) clearInterval(timerInterval);\n        convertBtn.classList.remove(\u0027processing\u0027);\n      }\n      function resetButtonState() {\n        convertBtn.disabled \u003d false;\n        convertBtn.classList.remove(\u0027processing\u0027);\n        convertBtn.classList.remove(\u0027completed\u0027);\n        convertBtn.innerText \u003d \"スライドを作成\";\n        convertBtn.style.backgroundImage \u003d \u0027\u0027; \n        if(timerInterval) clearInterval(timerInterval);\n      }\n      function showStatus(msg, className) {\n        statusText.textContent \u003d msg;\n        statusText.className \u003d className ? `status-text ${className}` : \u0027status-text\u0027;\n      }\n      function loadHistory() {\n        google.script.run.withSuccessHandler(renderHistory).mt_getHistoryList();\n      }\n      function renderHistory(historyArray) {\n        const historySection \u003d document.getElementById(\u0027mt-history-section\u0027);\n        const listContainer \u003d document.getElementById(\u0027mt-history-list\u0027);\n        if (!historyArray || historyArray.length \u003d\u003d\u003d 0) {\n          historySection.style.display \u003d \u0027none\u0027;\n          return;\n        }\n        historySection.style.display \u003d \u0027block\u0027;\n        listContainer.innerHTML \u003d \u0027\u0027;\n        historyArray.forEach(item \u003d\u003e {\n          const a \u003d document.createElement(\u0027a\u0027);\n          a.className \u003d \u0027history-item\u0027;\n          a.href \u003d item.url;\n          a.target \u003d \u0027_blank\u0027;\n          a.innerHTML \u003d `\n            \u003cdiv class\u003d\"history-name\"\u003e\n              \u003cspan class\u003d\"material-icons-outlined\" style\u003d\"font-size:18px;\"\u003earticle\u003c/span\u003e\n              ${item.name}\n            \u003c/div\u003e\n            \u003cdiv class\u003d\"history-time\"\u003e${item.timestamp.split(\u0027 \u0027)[0]}\u003c/div\u003e\n          `;\n          listContainer.appendChild(a);\n        });\n      }\n      // \n      init();\n      // \n      return {\n        loadHistory: loadHistory\n      };\n    })();\n  \u003c/script\u003e\n  \u003c/body\u003e\n\u003c/html\u003e"}]}